<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[jdk8-32-groupingBy 源码分析]]></title>
      <url>%2F2017%2F04%2F30%2Fjdk8-32-groupingBy-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[jdk8 集合的工厂类 Collectors 提供了两个很好用的静态函数。 groupingBy partitioningBy groupingBy 实现类似 Mysql 中分分组功能。返回一个 Map; 而 partitioningBy可以看做是 groupingBy 的特殊形式。我们后面会接着介绍。 使用的是比如统计每个城市人的“姓”，可以这么写 1Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); 那么，他到底如何利用 Collector 的各个接口来实现的呢？下面我们将深入 JDK 的 Collectors 的源码中，分析一下他是如何工作的。 groupingBy1 第一个重载方法, 要简单就别那么多要求，给你个List不错了分组 groupingBy 有三个重载方法。一个比一复杂。 先看最简单的 12345678/** * @param &lt;T&gt; the type of the input elements * @param &lt;K&gt; the type of the keys*/public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier) &#123; return groupingBy(classifier, toList()); &#125; 这里 T 是输入集合的元素类型， K 是最后产生的 Map 的主键key 的类型。 函数需要传入一个 Function 的函数式接口，Function 的中作就是分类器，比如传入的类型是T 是一个 Person类型 ， 通过 apply() 方法，返回 Person 的属性 name；因为我们要按照 name 来分组。 所以，如果 name 的类型是 String ； 那么 K 就是 String 故而，这个 groupingBy(function) 的功能就很清晰了，就是通过 function 对传入的 T 类型进行分类。然后调用 toList() 方法，也就是说每个分类的Person 会放进一个 List&lt;Person&gt; 中 最终返回的类型就是 Map&lt;String, List&lt;Person&gt;&gt;. 而如果你不想返回的是一个List , 希望是一个 Set. 你就要使用第二个重载方法~ 他允许你定义最后的输出函数。 2 第二个重载方法：我要输出Set看一下函数的定义： 12345678910111213/** * @param &lt;T&gt; the type of the input elements * @param &lt;K&gt; the type of the keys * @param &lt;A&gt; the intermediate accumulation type of the downstream collector * @param &lt;D&gt; the result type of the downstream reduction * @param classifier a classifier function mapping input elements to keys * @param downstream a &#123;@code Collector&#125; implementing the downstream reduction*/public static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream) &#123; return groupingBy(classifier, HashMap::new, downstream); &#125; 这个函数，明显比上一个要复杂，可以看到，多了一个 Collector 的 downstream , 可以自定义输出的集合。上面那个简单版本的函数是是写死的 List 这个函数有四个泛型。 T 原始元素类型，比如我们这是 Person K 返回 Map 的 key, 即最终返回的Map 的建的类型。如果你想按照人的名字分类，那T就是 String, 如果按照年龄分类，那就是 Interger A 是 downstream 的 accumulation 的中间结果类型 D 是最终输出 Map 的 Value 的类型。比如 List 或者 Set 这个方法会调用第三个重载函数，比第二个函数，多了中间的 HashMap::new； 这个是最终返回的 Map 的类型，这里写死的是 HashMap, 如果你想用其他类型，就需要使用最终的也是最复杂的第三个重载函数。 越是你用起来简单的函数，背后的实现就越来越复杂。 3 第三个重载方法: 能看懂就随便你怎么玩12345678910111213141516171819202122232425262728293031323334353637383940414243/*** @param &lt;T&gt; the type of the input elements* @param &lt;K&gt; the type of the keys* @param &lt;A&gt; the intermediate accumulation type of the downstream collector* @param &lt;D&gt; the result type of the downstream reduction* @param &lt;M&gt; the type of the resulting &#123;@code Map&#125;* @param classifier a classifier function mapping input elements to keys* @param downstream a &#123;@code Collector&#125; implementing the downstream reduction* @param mapFactory a function which, when called, produces a new empty* &#123;@code Map&#125; of the desired type*/ public static &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream) &#123; Supplier&lt;A&gt; downstreamSupplier = downstream.supplier(); BiConsumer&lt;A, ? super T&gt; downstreamAccumulator = downstream.accumulator(); BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123; K key = Objects.requireNonNull(classifier.apply(t), "element cannot be mapped to a null key"); A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get()); downstreamAccumulator.accept(container, t); &#125;; BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner()); @SuppressWarnings("unchecked") Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory; if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123; return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID); &#125; else &#123; @SuppressWarnings("unchecked") Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher(); Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123; intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v)); @SuppressWarnings("unchecked") M castResult = (M) intermediate; return castResult; &#125;; return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID); &#125; &#125; 这个函数有5个泛型，除去上面说的 T，K，A，D多了一个 mapFactory 的 Supplier() , 用于得到最终返回的 Map 的类型，第二个重载函数写死的 HashMap，这就可以进行自定义。 这个函数有连个值得注意的点： 所有的Collectors 中函数，如果函数内部还要做集合处理的，都是使用 downstream 这种模式，利用 downstream 的各种已有的的 Supplier Accumulator等，修改来实现自己的功能。比如在 groupingBy 这个函数，一开始就获取了 downstream 的各个组件，组合成自己需要的收集器，进而用于完成分类的行为。（你还可以去看一看 collectingAndThen() 这个函数） groupingBy 函数中有有两处强制类型转换。这里其实很难理解，为何可以直接成功的转换呢？ 第一处 第二处 两处其实都是将最终结果泛型 D 转成 中间结果 A。对于第一处， mapFactory 是作为一个 Supplier 出现，而他的目的是提供中间结果类型，而他上面的 accumulator 的中间结果类型，就是K,A， 所以这样的强转是一定可以成功的 第二处也是一样的，因为全称都使用了 A，其实 A 和 D 在这里，是等价的。所以转换都可以成功。 你去可以从这么一个角度思考问题： 你最终需要生成 D 类型，为何中间要给自己生成一个不一样的 A 类型添堵呢？ 你 4 不 4 sa？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-31-工厂方法收集器Collectors的中的常用函数]]></title>
      <url>%2F2017%2F04%2F13%2Fjdk8-31-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86%E5%99%A8Collectors%E7%9A%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[1 collectorImpl Collectors 中的 的基础 collectorImpl 两个构造方法一个有 finisher(), 一个没有。这个很容易理解，一个需要转换中间结果，一个中间结果和最终结果一致，所以不需要使用 finisher() 方法 2 两种实现方式对于工厂类 两种实现方式 CollectorImpl 来实现。 reduceing 来实现， 而 reducing 方法归根还是用的是 CollectorImpl 方法来实现 3 常见函数1） toList() &amp; toCollection 两个最常用的方法 toList() &amp; toCollection toSet() 方法是也是 toCollection 的特化。 2） joining() joining 三种重载方法 3） mapping() mapping() 将输入元素转换成输出元素 1234Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity= people.stream().collect(groupingBy(Person::getCity,mapping(Person::getLastName, toSet()) // Mapping , 将Person 转换成String , 提供给下游 Collector 使用)); 4） collectingAndThen() collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher) 先过完上层收集器 downstream ，在进行一次 finisher() 转换结果 比如说，你在 toList() 之后，想将它转换成一个 immutableList() 就可以如下使用 List&lt;String&gt; people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList)); 实现其实很有意思 5） counting() , minBy() , maxBy() counting() , minBy() , maxBy() 用 reducing() 实现, reducing() 又是基于 CollectorImpl 实现 6） summingInt() , averagingInt() , averagingDouble() summingInt() 对每一个元素使用 toIntFunction 在累加，实现很有意思 Supplier() 采用生成了一个 长度为1 的 int 数组，而不是直接使用的整形数字？因为数字是一个 值， 值是无法传递的，而数组是一个 引用， 引用是可以传递的。 averagingInt() 求平均值 对于averagingDouble() 的实现可以再去看一下，他的初始数组长度为4，他们视为浮点数计算的补偿产生的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-2-流初步以及Function详解]]></title>
      <url>%2F2017%2F02%2F14%2Fjdk8-2-%E6%B5%81%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8AFunction%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[一 流初步java 8提供一种更加方便的操作集合方式，即流~ StreamStream的概念其实类似于 liunx 操作系统的中的 PipeLine 的概念，可以将数据传输； 流 分为两种： 中间流：数据通过后还返回一个流，不是数据的终点 节点流：数据流入后不再返回流，操作结束，没有返回 使用java8 中的 List 来写一个例子，这个例子是将集合中的所有元素，全部变为大写，而后将元素逐一输出12345678910111213141516171819202122public class Test3 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list1 = Arrays.asList("min.zhu", "yi.yu", "nai.nai");// list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; System.out.println(item)); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); // 流的操作方式 类似 linux 的管道功能 // 流 分为： 中间流 和 节点流 // map 称之为 映射 与 mapper-reducer 阶段的map 功能是一致的，给定一个值，返回会一个由于之映射的值 list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; list2.add(item)); // 函数引用的做法 // String::toUpperCase 其实 和 item -&gt; item.toUpperCase() /** * 一致，都是有输入有输出，而 toUpperCase 的输入，就是调用他的实例对象 * 因为一个类是无法调用他的实例方法的，一定是实例才可以调用实例方法 */ list1.stream().map(String::toUpperCase).forEach(System.out::println); list1.stream().map(String::toUpperCase).forEach(list2::add); &#125;&#125; java8 的调用流的方式，是使用集合的 stream() 方法， 这个方法会返回一个流，之后就可以调用 map() 方法对 list 中的元素做一定的处理。 map() 函数，还是返回了一个流，这个流也有 forEach 方法，这个时候我们还可以调用 forEach 方法对流中的数据进行逐一的处理。 需要注意的是，forEach 函数中, 需要传递的函数的参数是一个 Consumer 的函数式接口，这个接口的抽象方法 accpt() 是没有返回值的，所以，他不在可以返回一个可以继续操作的流。 而我们在看看 map 方法中，需要传递的是一个我们没有见过的 Function 的函数式接口，这个函数式接口，有两个参数，一个是输入参数，一个是返回值。他的唯一的抽象方法中，是接受一个参数，返回一个值。具体见下图，唯一的方法是 apply 方法，它是有返回值的，这一点和现实中的函数很像 我们之前说过，java8 中，新增了很多个函数式接口，分别用于不同的场景如之前说的 Consumer 接口，他是没有返回值的一个场景，专用于处理数据以及今天说的有返回值的 Function 接口 那么这个 Function 的函数式接口，就是我们今天的重点。 二 Functon 接口 以及 BiFunction简介我们可以用一个例子来完整的说明问题： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 函数式接口 Function 的经典案例 * jdk 8 新增很多 函数式接口 * 之前看的 forEach 方法中的 Consumer 接口 ，他的作用就是 对给定的参数进行一系列操作，不返回值 * 而现在的 以及 Test3 中流的 map 方法中 Function 接口 ，他唯一的操作 是apply , 他有返回值，一个value 一个 Return ，与现实当中数学的函数很类似 * * jdk 8 中，接口中 除了可以有 default 方法以外， 还可以有一个 static 方法， static 方法可以有默认的实现 * 可以参考 Function 这个函数式接口 */public class FunctionTest &#123; public static void main(String[] args) &#123; FunctionTest functionTest = new FunctionTest(); // 函数式接口，以及 lambda 表达式，让我们可以在函数操作的时候，传递函数，即传递行为 // 而之前的编程方法，行为必须已经确定，而后进行调用 // 故而 之前的编程方法称之为命令式编程，而后面的方法称之为 函数式编程 // 而 可以传递，或者 返回函数的函数，称之为高阶函数（ js 中随处可见高阶函数 System.out.println(functionTest.compute(1, item -&gt; 2 * item)); // 这种返回方式是 statement 方法 // 上面那种方式是 expression 方式 // 一个是一个标准的语句，而一个是一个表达式 /* * 表达式是不需要分好结尾的 * 而使用 标准语句，则必须要 ； 而且要 &#123;&#125; */ System.out.println(functionTest.compute(1, item -&gt; &#123;return 2 * item;&#125;)); System.out.println(functionTest.compute(2, item -&gt; item * item)); System.out.println(functionTest.convert("hello", item -&gt; item + " world !!")); &#125; public int compute(int value, Function&lt;Integer, Integer&gt; function) &#123; return function.apply(value); &#125; public String convert(String value , Function&lt;String, String&gt; function) &#123; return function.apply(value); &#125;&#125; 主要去看代码的注释，上面写完了所有重点的内容，我们再去看看 Function 这个函数式接口的实现，我们知道，java8 允许接口有 default 方法，而 Function 接口中有两个默认方法： 利用这个两个方法，可以做函数的组合，用一个函数的输出，作为一个函数的输入。 compose 方法，是先执行 before 这个function, 在执行本身这个function； andThen 方法，则是先执行 Function 本体的 apply 方法，在执行传入的 after 的方法 我们来写个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class FunctionTest2 &#123; public static void main(String[] args) &#123; FunctionTest2 functionTest2 = new FunctionTest2(); // 12 System.out.println(functionTest2.compute(2, item -&gt; item * 3, item -&gt; item * item)); // 36 System.out.println(functionTest2.compute2(2, item -&gt; item * 3, item -&gt; item * item)); // 25 System.out.println(functionTest2.compute3(2, 3, (a,b)-&gt; a+b , result -&gt; result * result)); &#125; public int compute (int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; /** * compose 就是 先执行 function2.apply * 再将 function2.apply 的返回值，作为 function1 的输入 * 此时再执行 function1 apply */ return function1.compose(function2).apply(a); &#125; public int compute2 (int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; /** * compose 就是 先执行 function1.apply * 再将 function1.apply 的返回值，作为 function2 的输入 * 此时再执行 function2 apply */ return function1.andThen(function2).apply(a); &#125; /** * 如果想做有两个参数的Function 就需要使用BiFunction * 而 BiFunction 只有一个 andThen , andThen 的输入 是 Function， * 因为是将 Apply 的结果返回，结果只有一个，所以 参数只能是 Function , 而不是 BiFunction * 所以 BiFunction 方法不可能有 compose 方法 * * 对应的 consumer 也有着 BiConsumer 同时，二者因为没有返回值，所以也只可能有 andThen 方法 * @return */ public int compute3 (int a, int b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function) &#123; return biFunction.andThen(function).apply(a,b); &#125; compose 和 andThen 的功能可以从例子中很好的看出来，例子中还有一个新的接口叫 BiFunction, 这个函数式接口是给定两个输入，返回一个输出，解决了有两个参数的函数的问题，对应的，其实 Comsumer 接口也还有一个对应的 BiConsumer 接口。 而当我们去观察这俩 Bi 的接口，都只有一个 andThen 的接口，为啥没有 compose 方法呢？给读者自己思考吧~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-1.1-方法引用：lambda表达式的语法糖]]></title>
      <url>%2F2017%2F02%2F12%2Fjdk8-1-1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
      <content type="text"><![CDATA[方法应用其实是 jdk 8 中的对于 lambda 表达式给予的一种 语法糖 而方法引用一共分为 4 种； 1 类名::静态方法名 2 对象名::方法名 3 类名::实例方法名 4 构造方法引用::new 我们有intellj 编写 lambda 表达式的时候，编译器总是标黄来告诉你，这里可以使用方法引用的方法来进行代码的简化 而方法引用，method reference 其实就是lambda表达式一种语法糖但是 不是所有的 lambda 表达式，都可以用方法引用的方式来编写复杂的 lambda 表达式还是需要老老实实写相关代码 我们通过一个例子来分别讲解这四种方法引用的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static void main(String[] args) &#123; // 第一种 Student student1 = new Student("zhumin1",10); Student student2 = new Student("zhumin2",20); Student student3 = new Student("zhumin3",40); Student student4 = new Student("zhumin4",80); List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4); // jdk 1.8 的新方法 List 中新增加了 sort 方法 // 传统的 lambda 表达式 students.sort((studentP1, studentP2) -&gt; Student.compareByScore(studentP1, studentP2)); // 第一种方法引用的方式 类名::静态方法名 // 不需要传参数，因为可以自动推断出 Student 类型 students.sort(Student::compareByScore); // 第二种 对象名称::方法名称 // 其实和第一种很类似 StudentComparator studentComparator = new StudentComparator(); students.sort((studentP1, studentP2) -&gt; studentComparator.comparator(studentP1, studentP2)); // 对象名称::方法名称 (方法引用的第二种方式) students.sort(studentComparator::comparator); // 第三种方法 类名::实例方法 /** * 比较难理解的的地方是，你会看到调用的函数，和 lambda 表达式需要的参数个数不一致， 会少一个 * 而且类名是没法调用方法名的 * 而理解方式是：调用方法的实例，就是传入lambda 表达式的第一个参数，而剩下所有参数，都作为 调用的实例方法 的参数 * 我们看下面的例子 ， Student 类调用的是其的实例方法 compare（Student） 只有一个参数 * 而 List 的默认方法需要的 Comparator 的函数式接口需要两个参数，看似对应不上，而且，类名也无法调用实例方法 * 实际是，传入的第一参数就是 comare（student）这个函数的调用者，而第二个参数以及后续所有的参数（如果有跟多也是一样），是作为实例方法的参数传入 * 所以少一个参数也没什么 * 而更为关键的是这个就是一个语法糖，为了简化代码而生。理解就好 * 如此一来； 这个第三种方式就很好理解了 * * 类名::实例方法 * 即 lambda 表达式的第一参数就是 实例方法 的调用者，后续所有的参数就是 实例方法的传入参数 */ students.sort(Student::compare); // 再看一个例子 List&lt;String&gt; cities = Arrays.asList("haha","lala","nihao","memeda"); // 对比二者 Collections.sort(cities, (city1, city2) -&gt; city1.compareToIgnoreCase(city2)); Collections.sort(cities, String::compareToIgnoreCase); // 对于第四种，构造方法引用，对于带参数和不带参数的都可以，编译器会自动的进行腿短 MethodRefrenceTest methodRefrenceTest = new MethodRefrenceTest(); // 点击 new 看看会跳到那个方法里去 methodRefrenceTest.getName(String::new); // 点击 new 看看会跳到那个方法里去 methodRefrenceTest.getName2("haa", String::new); &#125; public String getName(Supplier&lt;String&gt; supplier) &#123; return supplier.get() + "haha"; &#125; public String getName2(String name, Function&lt;String ,String&gt; stringFunction) &#123; return stringFunction.apply(name); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-1-函数式接口&lambda表达式]]></title>
      <url>%2F2017%2F02%2F11%2Fjdk8-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[1 lmabda表达式首先看两段对比代码:为jbutton 添加一个时间监听器12345678910// 老写法: 匿名内部类jButton.addActionListener(new AbstractAction() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println("Hello Button"); &#125;&#125;); // lambda 表达式写法jButton.addActionListener(e -&gt; System.out.println("Hello Button")); 对比两个写法，lambda表达式的写法会简单很多，如果你有多行处理逻辑：12345// 加个大括号jButton.addActionListener(e -&gt;&#123; System.out.println("Hello Button!!!!"); System.out.println("Hello Button2!!!!");&#125;); 这里的e，没有声明类型，并不是表示java 不是一个静态语言了，而是，编译器的类型推断告诉可以推断出来这个 e 的类型肯定是一个 AbstractAction, 所以无需去写，当然如写上也没有问题，需要加上括号 1234jButton.addActionListener((AbstractAction e) -&gt;&#123; System.out.println("Hello Button!!!!"); System.out.println("Hello Button2!!!!");&#125;) 所以 lambda 表达式的基本结构如下（根据单个参数和单个操作可以有一定的省略）1234(event e1, event e2 ...) -&gt; &#123; action1; action2;&#125; 一开始可能不是特别好理解，我们可以结合 java8 新增的另一个特性 函数式接口 来一起理解为何我们可以如此编写代码 2 函数式接口什么叫函数式接口呢？ 函数式接口是 jdk1.8 中新增的一个接口类型，为此还新增了一个注解 @FunctionalInterface 用于标注函数接口；我们通过阅读 @FunctionalInterface 的 jdk 文档来进行概念认知。总结起来： 当一个接口 有且只有一个抽象方法，并且这个抽象方法不是继承自 Object 的方法，就会被当做一个 函数式接口 当一个接口被 @FunctionalInterface 注解时，可以当做一个函数式接口 当一个接口被 @FunctionalInterface 注解，但不满足第一个条件的时候，编译器会报错。 当一个接口 没有被 @FunctionalInterface 注解标注，但是满足函数式接口的条件，也会被当做函数式接口 这里的第一条后半部分很重要，如果一个接口，有两个抽象方法，但是其中一个是继承自 Object 类（因为其实万类师祖）, 他仍然是一个函数式接口。 例如以下实例就是一个完整的函数式接口，即使他有2个抽象方法，但是toString是继承自 Object 的方法，所以不会算作函数式接口的抽象方法，所以其中的 test() 方法, 是函数式接口认定的唯一的抽象方法。同理，如果下面的例子只有 toString() 方法，而没有 test() 方法，同时又有 @FunctionalInterface 注解的话，那么编译器会报错。1234567891011121314@FunctionalInterfaceinterface MyInterface &#123; /** * 函数式接口，只能有唯一的抽象方法 */ void test(); /** * 因为改抽象方法，继承自 Object，所以不算函数式接口的抽象方法 * 故而，接口可以算作一个函数式接口 */ String toString();&#125; 我们可以看一下 @FunctionalInterface 的jdk文档，里面有一句: 意思就是说，函数式接口的实现，可以通过 lambda 表达式 方法引用 以及 构造方法引用 的方式来实现。其实我们上面的 lambda 表达式的例子，就是实现的函数式接口。我们来新写一个例子。 12345678910111213141516171819public class Test2 &#123; public void testInterface(MyInterface myInterface) &#123; System.out.println("start ------------------"); myInterface.test(); System.out.println("end --------------------"); &#125; public static void main(String[] args) &#123; Test2 test2 = new Test2(); /* * 因为函数式接口的里唯一的抽象方法test里面，没有参数 * 但是（）不能省略 * 参考Test1 程序里面的Jframe 里的ActionListener */ test2.testInterface(() -&gt; &#123; System.out.println("函数式接口接口实现"); &#125;); &#125;&#125; 我们可以看到，testInterface 方法需要传递一个 testInterface的接口，而我们使用的方式就是 lambda 表达式来实现了一个函数式接口。 可以运用下面的形式来理解。 (函数式接口唯一的抽象方法的参数列表) -&gt; {唯一抽象函数的实现} 这个时候，我们看一下最开始的那个给 button 加 action 的例子。其实实现就是 ActionListener 这个函数式接口的唯一的抽象方法：虽然该类没有 @FunctionalInterface 注解，但是满足条件，只有一个抽象方法，所以他也是一个函数式接口，所以我们可以去使用 lambda 表达式去实现他。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[new start]]></title>
      <url>%2F2017%2F01%2F11%2Fnew-start%2F</url>
      <content type="text"><![CDATA[重新开始维护这个网站。让自己配得上这个不错的域名 movingon.cn! 我14年买了这个域名，本来想自己要好好做，实在不行，这域名也是一个不错的督促。 然而，自己维护了一段时间之后，就忘记了要去维护。 但是这一次，我用这里记录自己的技术成长以及个人感悟，作为自己的成长的记录。]]></content>
    </entry>

    
  
  
</search>
