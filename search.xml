<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[《增长黑客》读书笔记（上篇）：你应该有的理论基础]]></title>
      <url>%2F2018%2F04%2F19%2F%E3%80%8A%E5%A2%9E%E9%95%BF%E9%BB%91%E5%AE%A2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8A%E7%AF%87%EF%BC%89%EF%BC%9A%E4%BD%A0%E5%BA%94%E8%AF%A5%E6%9C%89%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[If you are not growing, then you are dying! 一句话道出了增长这一企业的永恒真理。增长黑客的职业因此慢慢发展。虽说国内第一本增长黑客的书是大佬 范冰 的《增长黑客》，但是真正的增长黑客之父是在2010提出增长黑客概念的 肖恩·艾丽斯。也就是这一本《增长黑客》的作者。所以这本书应该更加值得一读。 fackbook 有单独的增长部门，头条的200人增长团队支撑了头条系列app近几年来的飞速增长。滴滴也开始组建增长部门，各个创业公司拼多多，小红书，即刻都在招用户增长的产品经理（别问我怎么知道），这个职业可能是目前比较火的职业。 但是到底是什么是增长黑客？可能你是通过各种增长黑客的文章了解到各类看上去很轻松的四两拨千千的策略使得产品获得爆发式的增长，内心澎湃不已。 但这都是你观察的表面现象，就像我们不能只按表面需求做产品一样，在我们应用各种增长方法之前，我们首先要理解他的起源，适用场景。而不是看了皮毛就以为自己已经修炼的心法。（别对号入座，说的是我，不过欢迎你加入我） 作者写这本书的目标，也是系统的介绍增长黑客的起源，多年实践下来的理论，以及实战经验。全书分为我划分为三个部分： 理论部分，1-4 章。增长理论。 实战部分，5-8 章节。获客，激活，留存，和变现 良性循环， 第一部分包括如何搭建增长团队，好产品的对于增长的重要性，如何确定增长杠杆，以及快节奏的实验 下面一块一块来看。 1 搭建增长团队想要更好的执行增长策略，很重要的一点就是 打破筒仓。搭建跨职能的增长团队，让各个部门之间可以进行合作。 因为工程师和产品设计师能找到满足用户喜好的方式，但是他们远离用户。不知道他们喜欢什么。 而如果你想要较为顺利执行你的增长计划，一些必要高层支持就非常必要。（你懂得）一般有两种团队模式： 公司有一个专门增长团队，有专门的增长副总裁，增长团队都向副总裁汇报 增长负责人由产品负责人兼任，增长由产品部门负责 团队推进一些事情的时候一定会遇到资源问题的阻力。公司管理得当，利益共享，在很大程度上是可以减少一些阻力的。 一个合个的增长团队应该有以下角色： 增长负责人：理解战略，懂得增长方法论，懂得如何管理团队 产品经理：监督产品以及功能的实现过程。一般由增长团队所负责的产品的产品经理加入 软件工程师：实现构想。同时也是团队中重要的意见来源。 数据分析师：懂得确保数据的严密性并且在统计上有效果。 大体上的工作流程分为以下四个步骤： 分析数据&amp;洞察�收集 想法产生 排定优先级 试验执行 但是在做增长团队之前，有几点需要注意：首先增长不是一簇而就，一开始做的时候可以从某一个小的点开始，不断向外延展。如果你希望尝试一下增长黑客，也最好先能获得一定的支持。因为过程中难免会犯错，这是试验的必经之路，这个时候有人的支持就会很不一样。 最最重要的一点是，如果你的产品被喜爱，花再多心思都无济于事。因为：好产品是增长的根本 2 好产品是增长的根本要记住无论营销的投入有多大，用户都不可能爱上一款不合格的产品。一味的追逐增长，可能会让你灰飞烟灭。BranchOut 就是一个过早展开增长攻势但产品却一般，最终到导致被低价收购的反面例子。 所以增长黑客在着手工作前要明白： 你的产品对用户是否不可获取 目标用户什么，核心价值是什么 最终的产品的核心价值可能不一定是最初的愿景，而你必须找到 是爱创造的增长，不是增长创造了爱 而要赢得用户的喜爱，就要创造产品的 啊哈时刻。 找到产品的“啊哈时刻” 啊哈时刻 ： 就是用户真正发现了他们能从产品中获得什么（核心价值）的时刻。 淘宝的啊哈时刻是能够买到各种想要的东西。微信的啊哈时刻是可以联系到看到好久不见的朋友。点评的啊哈时刻是可以找想要去的店。优步的则是点一下手机，8分钟之内有车来接你。 你要问问自己的是，你是否知道用户的啊哈时刻的点在哪里？ 而这些点可能难以确定，所以挖掘用户数据和反馈就很重要。这可以帮助你找到那些真正热爱你的产品的人的相似之处，找到他们已经获得而其他用户还未获得的价值。就像推特通过分析发现“关注了30个人用户活跃度很高”。 但是如何找到或者实现自己产品的啊哈时刻呢？作者给出了自己答案：我总结为三点：调研，分析，实验。 （其实做产品的大致流程也如此。只不过大部分人在做没有调研的数据分析，或者没有分析的实验。） 第一步调研，首先你需要在你的活跃用户中进行调研，确认你的产品是否对用户来说不可或缺。如果问卷调研的结果超过40%，则算合格。调研的对象最好是活跃用户，因为从不怎么使用产品的用户那里获得的反馈往往没什么作用。 第二步分析，线上去获取用户的基础数据，线下深入用户群体去和用户进行更加深层次的交流。以便获取用户真正需要的是什么，阻碍你产品成功的因素和障碍是什么 （大部分时间，我们都是在拍脑袋，不是么。） 展开调研和分析是为了获取洞见，有些人觉得浪费时间，但其实这是误区。首先你不去调研做产品就有些本末倒置，其次，调研有时候根本不需要花费很多时间。也许几百分问卷，也许和几个用户深度交流就可以伴你找到在数据分析中发现的用户行为 背后的动机 第三步试验，在大版本试验之前，快节奏小成本的不断的进行AB测试，或者多变量测试是增长黑客的基本原则。我们通过不断的测试可以知道那些改动是真正有效的。但是这些测试都有数据表面性 的问题，因为他们只能告诉你某种行为的转化率高，但是不代表最终是否成功黏住了用户，所以数据需要最终测试用户的生命周期。 通过调研分析和试验的过程，我们最终会构建一个完整的数据仓库，最终分析师要通过这些数据找到活跃用户最常使用的功能以及他们使用产品的逻辑，发现产品的 啊哈时刻，然后让更多的人体验到，从而提高其他用户转化成活跃用户的概率。 我们做的所有工作，都是为了找到你能够给客户提供的啊哈时刻。在这个过程中，我们还是要记住，在找到之前，我们和客户都不知道他们需要什么。 3 确定增长的杠杆通过一系列方法找到了啊哈时刻后，剩下的就是制定明确的增长战略，然后严密的执行。因为如果没有全力的增长，那么即使真正出色的产品也会面临失败。（警示） 聚焦战略在影响力最大的因素上增长初期，通过快速实验找到并优化 最具有潜力的增长因素。因为初期增长团队必须专注于高影响力的目标。如果不确定是否有高影响力，那也需要非常有说服力的说明。初期的增长实验的机会成本很高，所以一定要想办法获得高影响力，对小公司来说就是要获得大幅提升，因为用户量上去之后，才可能测试更多的利基领域。 聚焦战略我们需要做到以下几点 1 确定核心指标，列出基本增长公式 这其实是最难的一个部分。也是最重要的一步。因为后面的所有操作都会围绕着核心指标开展。 要确定核心指标首先要知道用户对产品价值体验最直观的行为在哪里。我们需要跟踪用户达到啊哈时刻之前每一个步骤，以及这些步骤的频率。 明确产品的相关的特殊指标非常关键。每个产品都有自己共同的增长因素，比如获得新客，高转化和留存。但是每个产品可能更具自己的啊哈时刻的不同有着特定的因素组合。比如uber是司机的数量和乘客的数量。yelp是被评价的商家和商家的评价数。 基本增长公式就是所有重要因素的体现。比如ebay的可能是： 发布商品的卖家 发布物品的数量 买家数量 * 成功交易数量 = 总商品增长数量 虽然他很简单，但是在数据爆炸时代，跟踪到对你而言最为重要的指标会防止你在数据中迷失。 比如Arbnb，他重要的是订房率，每日虚高的日活对他而言意义不大。ylep 每个人每周打开一次就已经很高的，有些产品在用户使用的频率上本身就有局限性。但是对于facebook来说，日活就非常重要。 2 确定北极星指标， 然后我们要做的就是选择一个关键的能够决定成败的指标，以此指导所有增长活动。这应该是产品和企业为用户创造的核心价值的体现。 比如Arbnb的订房率。北极星指标让我们开展实验的时候不会走偏方向。不会为了提高某个指标而做实验，最终都要以 “北极星指标” 作为依据。 3 数据分析和定性研究同样重要 数据的收集统计和分析，是我们找到增长因素的关键。所以优秀的团队已经会花时间做好数据的手机和分析。但是数据只能告诉你表面原因，用户不会通过数据告诉你为什么，所以线下的定性分析依旧很重要。 最后别忘了用简单明了的趋势图，向公司和团队展示工作进展，监控核心指标的变化。 4 快节奏实验增长黑客的巨大成功往往来源于一连串小成功的积累。复利的效果是很惊人。快节奏的学习和实验就显得非常重要。高效的团队每周可能有20-30次的试验。 但一开始，团队应该放缓步调，遵循流程站稳脚跟在起步，不要陷入无止境的头脑风暴中。 增长黑客的循环：1 分析数据，2 形成想法，3 排定优先级，4 运行实验，就此循环。 具体描述下来是这样，一个团队开始快速实验之前要和团队明确的是之前的数据分析，核心指标，北极星指标，用户的啊哈时刻到底是怎么样的。然后设定每周的实验的节奏，每个人的分工，然后就可以开始有条不紊的开展实验 首先是分析：剖析用户路径，对用户进行分组，找到核心用户的路径与其他用户的不同，线下用户的使用习惯，他们里体会到啊哈时刻还有多远，什么阻碍了他们体验到这种时刻。 比如假设京东的啊哈时刻是当天定时送达，体验到这个点的用户的复购率显著高于其他用户，那么通过调研和分析得到：阻碍用户体验到这一点的可能是运费门槛。然后可能要分析接近活跃用户的那群人的平均客单价如何，用来决定后续的策略 第二根据分析提出想法：这里很关键的一点是建立想法库，团队所有成员都可以像里面填充想法。但是每个想法都要很明确，可以是如下模板： 1 名称：根据场景给用户推送商场相关的美食优惠的套餐可以增加用户访问场景和频次2 描述：如何产生，可能如何发挥作用3 假设：简要说明预期的因果关系，以及预期的结果。4 待测指标：需要追踪那些指标 这个提出想法的阶段参与的人越多越好，目标就是提出尽可能多的想法。而且不要局限于本团队，外部成员有时候会提供很好的洞见。 但是在接受意见之前，我们要确保我们已经告诉了他们增长杠杆和核心指标到底是什么 ，否则我们可能收到很多模糊的请求。 第三就是排定优先级，作者给出了ICE原则用户排列。分别是 impact(影响力)，confidence（信心），ease(简易性)然后团队就可以在在关注的核心领域知道得分最高的一批想法进行试验。其中核心关注领域的分类作用很关键。比如一段时间内我们关注的核心指标是留存率，那么即使某一个实验能在拉新的领域有更好的ICE得分，我们也不会采用。 但是这个得分可能不是最终的执行顺序。实际情况可能比预判的要复杂，但是这可以给我们一个大致范围的筛选。 这些流程，可以通过每周一次的增长例会进行协同选择。 第四就是测试了，每次测试的机会都要珍惜，因为一次糟糕的实验就浪费了一次学习的机会，因此作者指出每个实验都能产生统计上的效果。并给出了两个意见： a. 采用99%的置信区间。以的降低假阳性的影响。 假阳性（第一类错误）： 把不具备特征的对象当成了具备特征的对象捉错了好人 假阴性（第二类错误）：把具备特征的对象，当做不具备特征 对象错放了坏人一般情况下，第一类错误的影响是超过第二种的。你看看那么些冤案的社会影响就知道了。 b. 坚持用对照组作为依据。差的情况很快可以反映，而好的不是很明显的情况下，为了不让辛苦的实验白费，对照组就很重要了。 最后，要再回到第一阶段，进行分析和学习。要写下完整的实验分析，关键指标，假设与结果，可能的干扰因素等等。也要记得将成功的实验告诉团队，帮助公司的了解增长的工作进展。（你如果想分享失败的经验也不是不可以） 这一章节的最后，作者给出了一个完整增长会议的流程，帮助我们在会议的时候注意思路的梳理。记录如下 每周二召开会议（周一留给数据整理） 15分钟：回顾指标，并更新关注领域（核心指标，北极星指标的变化，下面要关注哪一个增长杠杆，短期目标是否有变化） 10分钟：回顾上一周工作 15分钟：从结果分析中获得主要收获 15分钟：选择下一周的增长实验（大家可以提名，然后根据ICE筛选，讨论达成共识，负责人拍板） 5分钟：检查增长想法储备库（确保有有源源不断的想法） 5 朱老师的废话总结全书的上半部通过四个章节有条理的讲述了完整的增长黑客的流程。总结起来就是，首先搭建一个团队，然后找到产品对用户增长，提升活跃度最为核心的价值点（啊哈时刻），然后通过一个严格执行的增长实验流程，让更多的人体验到啊哈时刻，从而获得增长。 但是，我们做的似乎总是丢掉了最重要的东西。 有一句印象深刻：“记住是爱创造的增长，而不是增长创造了爱” 实践“转发点赞表示期待吧”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《游戏化思维》读书笔记： 如果没有外部激励你还会不会继续玩下去]]></title>
      <url>%2F2018%2F04%2F12%2F%E3%80%8A%E6%B8%B8%E6%88%8F%E5%8C%96%E6%80%9D%E7%BB%B4%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A-%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E5%A4%96%E9%83%A8%E6%BF%80%E5%8A%B1%E4%BD%A0%E8%BF%98%E4%BC%9A%E4%B8%8D%E4%BC%9A%E7%BB%A7%E7%BB%AD%E7%8E%A9%E4%B8%8B%E5%8E%BB%2F</url>
      <content type="text"><![CDATA[这本书读起来真的很巧。前一天我听说这本书，然后我下了单。第二天书到了，然后我去看了《头号玩家》，我觉得我对游戏的认知总是差一些。感知不到那份乐趣，让我有一些失落。在我的小时候基本和游戏绝缘，我也一直认为游戏没什么用。浪费时间而已。而这本书改变了我的认识，游戏是一门很深的学问，游戏化的作用也超乎我的想象。 当时我的不屑一顾，我现在反思起来，只是自我保护：1 我玩不到， 2 我玩不好。 （打脸承认这些事儿） 如果用三个关键字来提炼出我感受最深的三个点，那就是目标，动机，有趣。 这是一本实用类型的书，作者强调游戏化的核心是“帮助人们从必须做的事情中发现乐趣，通过流程有趣而产生吸引力”，同时也系统的告诉我们游戏化的关键元素，以及通过一些通过实践证明过的将游戏化应用到商业中和我们日常的项目中的方法论。 为此，像游戏升级一样，通过leve1-level6，作者循序渐进的与我们分享了他的游戏化思维。 level1 : 了解游戏化的基本感念 level2 : 想游戏设计师一样去思考，学会判断场景是否适用 level3 : 了解用户的动机，如何最有效的去驱动用户 level4 : PBL 与游戏的动机、机制、组件等基本元素 level5 : 如何整合元素使得游戏化更加有效 level6 : 理性思考：游戏化的风险 下面一个个认识与颠覆。你觉得你理解的，其实都是零碎的感觉。 leve1 什么是游戏化概念游戏化的目标不是建立一个完备的游戏，他主要是指： “在非游戏情景中使用游戏元素和游戏设计技术” 。 这里有三个重要感念，游戏元素， 游戏设计技术， 非游戏场景。一个个来看~ 游戏元素： 一个游戏有很多元素组成。一般分为对象，关系，和规则。这里还有很多细分属性。我们可以把它当做我们我们设计游戏的一个工具箱。这些工具很重要。因为游戏化的关键就是将游戏元素应用到非游戏的活动之中。 比如排行榜，是一个现在几乎被每个社交平台都使用的元素，良好的场景可以更好的激发员工的工作积极性。这个后面有更详细的描述。 游戏设计技术： 游戏设计技术要解决的是， 改如何决定哪些游戏元素应用在哪里，如何使得整个游戏化体验大于各个元素之和 首先要明确的观点是，游戏化设计真的很难，否则世界大型游戏公司如索尼也不会时不时的损失几百万美金去开发一款失败的游戏。 在别的场景适用的游戏元素，不是搬到另外一个地方就会变成自己的游戏化场景。游戏设计师需要接解决 为何做 和 如何做 这两个关键问题（其实做产品不就是要解决这两个问题么~）。除了需要一些技巧和技术，那些来之不易的关键失败经验，也会给我们提供宝贵的提示。 非游戏场景 游戏化有基本三大实践类型：内部游戏化，外部游戏化，行为改变游戏。 内部游戏化：企业内部实行，员工就是你的玩家，目标是提高生产效率，企业创新等等。外部游戏化：玩家是你的顾客，你希望通过游戏化提升客户的参与度，对产品的认同度，并最终提升盈利。行为改变游戏：旨在帮助大家养成更好的习惯 我们做游戏化一定会有一些商业目的和社会目的。而用户也有自己的需求。所以在游戏化的过程中如何平衡这两者，对游戏元素进行合理的利用就显得尤为重要。 为什么游戏化很有意义游戏化的意义体现在以下三点核心价值： 提高参与： 游戏化可以通过激励等游戏元素满足人们的被看见，被反馈的渴求，提升人们的参与度。而参与度的提升会存成消费。 这里有个一很相关的概念叫做 鸡蛋理论 or 宜家效应源于消费者的一种行为特征，我们对于一个物品付出的劳动或者情感越多,,就越容易高估该物品的价值。 实验： 游戏化中人们可能因为激励开展出游戏设计的时候根本无法想象的可能性。 成果：好的游戏化是会带来很好的效果。 level2 游戏化思维，像游戏设计师一样思考 这里出现一个很关键的点 乐趣 什么是游戏和游戏化思维不知道你是否记得一度在有土鳖上很火的楼梯钢琴，人们为了这种乐趣会放弃做电梯。这就是有趣的力量。甚至还有一个理论就叫 乐趣理论 而游戏化思维就是：以一种有计划，有方向的方式来获得乐趣的思维 而我们要做的利用这种思维，创造出引人入胜的体验，从而驱动玩家做出你想要的行为 游戏能做很多事： 鼓励你解决问题问题 保持用户进阶路上的兴趣 促进团队合作的乐趣 给玩家带来现实中很难有的掌控感 但就和做产品一样，你需要像了解你的用户一样了解玩家，知道他们使用购买你的产品的根本原因是什么 我们要避免玩家思维，因为两者是完全不同的。 玩家思维是为了赢 设计者是为了吸引玩家去玩就想一个有限的游戏和无限的游戏。推荐阅读（《有限和无限的游戏》） 对我们来说，因为游戏是一个过程，而不是一个结果。在游戏的过程中要去把控玩家的心理，要在游戏中赋予他们掌控感，因为这是他们选择游戏的很重要的原因之一。 但游戏化并不能解决所有问题，所以我们在决定是否使用游戏化的时候要考虑下面四个问题： 四个问题 1 动机： 如何从被激励的行为中获取价值？ 这个问题很关键，要学会去判断该不该使用游戏化思维，比如苹果的顾客已经很有热情的情况下使用游戏化机制，可能会降低品牌销售 2 有意义的选择：你设置的目标活动都是有趣的么？ 选择是否给玩家带来乐趣。他们是否有掌控感，能发挥自主意识，感受到参与感。用户得到了自己想要的反馈才会在新鲜感过去之后努力继续玩下去。 3 结构：预期的行为可以被固定的程序模式化么？ 游戏需要有量化的指标衡量游戏的质量和用户的行为。 4 潜在的冲突：游戏可以避免与现有激励机制之前的矛盾么？ 你现在的游戏化排行榜，与公司内部的会员奖励机制冲突么？ 理想的游戏化是需要上面四个因素同时生效，但其中最重要的是给用户更加有意义的选择 同时我们要学会区分哪些事情可以做游戏化，哪些不可以。强加游戏化可能适得其反。要多问问自己 游戏化能达到什么需求，为什么要达到这种需求 level3 内部动机和外部动机 这里有另外一个关键词 动机; 到底是什么在东西在驱动这人们开始去做一些事？ 两种动机动机是一个活动产生的基础。可以很直白的分为两种：内在动机和外在动机。 想做某件事儿的冲动，是内在动机 不得不做莫一件事儿的感觉，是外在动机 这是两种截然不同的态度，决定了你对一件事儿的热情，参与程度与忠诚度。 行为主义心理学家认为增强外部动机是激励人们行动的途径。而自我决定理论则专注于则将将行为归咎于人们的内在需求。 自我决定理论将人们的需求分为3类： 能力需求：又被成为掌控力。意味着积极处理与外部环境关系的能力 关系需求：希望与其他人构建关系，沟通的渴望 自主需求：想一想做的是自己喜欢的事情的那种发自内心的愉悦感 （这总让我想起马斯洛的层次需求理论。反思的点是，我只是听过，从没看过） 想想我们为什么玩游戏，没有人强迫，我们自愿参加。因为游戏给到我们一段过程，让我们满足到我们的自主决定系统。 当然不是说外部动机不重要。想想《头号玩家》中为了彩蛋激励而疯狂的玩家，再比如游戏比赛中的奖金。这些都是强大的外部动机。 问题在于，游戏设计者需要决定激励哪里一个层次的动机，以及如何激励。 我们需要认识到游戏不仅仅应该是一堆苍白激励的组合。他要能够满足玩家的需求，让他们感到愉悦，以此形成一种内在动机，驱动这他完成我们的想要他完成的动作。 我不玩微博，因为没人搭理我，满足不了我的关系需求，自主需求。他给我钱，我会玩（当然不可能）。但是一旦停止给钱，我就会离开。这也是我为什么会放弃朋友圈去玩即刻。所以我觉得即刻的产品对人性的洞察绝对是很高的水平。很多事他们看破不说破，看着我们逐渐产生粘性，丰富社区。 外在激励可能会让内在动机失效，我们要做的始终是让参与度提高，这一点几乎没有捷径可以走。正如下面五个游戏化的经验教训说的那样。 五个游戏化的教训 1 奖励会挤出乐趣 不要盲目的将外在动机附着在内在动机上。 挤出效应：外在奖励会显著降低玩家的内在动机。（有一本书很好的总结了过分奖励的现象《奖励的惩罚》） 在做一件有趣的事情的时候，如果外在奖励可预期，实实在在，内在动机就会慢慢消失。 举个例子：当你读书是为了获取某些外部奖励，钱，点赞，认可，吹捧。你在读书的时候，就只是想着这些事情。慢慢感受不到读书的乐趣。当外部奖励一旦停止，你就不愿意再去读一本书。 2 外在动机适合本质上不有趣的项目 用户从事漫无目的的工作的时候，外在动机可以产生积极的效果。 3 协调你的反馈 反馈是成功游戏的必要不充分条件，但有三条经验。 1 变量奖励方案：用户喜欢意想不到的惊喜。2 用户希望在他自己表现如何上得到反馈。3 用户可以根据提供的标准调整自己的行为。如果你将标准定为用户满意度而不是销售额，那么员工也会开始重视用户满意度。 4 整合内外动机 外在动机可以被整合成内在动机。 不得不去做的游戏任务，可以因为排行榜或者徽章的存在变成可以炫耀，可以融入更大社群的一部分而内化成内在动机系统的一部分。 不得不完成的作业，也会以为想登上学校的排行榜，获取同学的羡慕而逐渐内化为内部动机。 5 不作恶 想起谷歌。游戏化是一种通过为人们提供真正意义上愉快的方式来是想自己的目标思维。 不要忘了自己的初衷。 level4 游戏元素：你知道的PBL只是很小的部分熟悉的PBL点数（points）、徽章（badges）、排行榜（leaderboards）几乎是现在游戏的标配。如果使用得当当然可以发挥巨大潜能。前提是了解他们的优缺点。 点数： 给用户体用反馈，积分，成就，构建和外在奖励之间的关系，同时也可以给游戏设计师提供玩家行为数据。 徽章： 点数的集合，具有很大的灵活性。可以给用户提供游戏方向，也可以传达玩家关心什么，可以给玩家一种虚拟的认同感。 不同的徽章代表着想要你完成的不同任务。所以徽章几乎是无限灵活的。 榜单：榜单是最好也最难应用的。可以是激励机制，也可能是打击机制。但是排行榜也可以多中多样，可以在不同维度去鼓励玩家去进行竞争。 PBL很容易想到，有巨大的价值，但也不是唯一途径。超越PBL ，才可以获得游戏化的最大价值。 DMC: 动力、机制与组件。三个层面的概念。组件形成机制，机制影响动力。我们刚刚说的PBL，只是组件的一部分而已。 动力：约束，情感，叙事，进展，关系。使我们需要考虑的抽象的概念。但是没法直接应用在游戏中。但却是游戏的顶层设计。 机制: 是推进游戏进程的基本流程。有以下十种常用机制。挑战， 机会，竞争，合作，反馈，资源获取，奖励，交易，回合，获胜状态。每个机制都是对一个或者多个动力系统的实现。比如随机的奖励（情感），比如合作（关系） 组件：PBL只是其中的一部分。每个组件也会都与一个或者多个机制元素相关联。下面是15个重要的组件元素：成就，头像，徽章，打怪，收集，战斗，内容解锁，赠予，排行榜，等级，点数，任务，社交图谱， 团队，虚拟商品 他们其实是一个金字塔的分层关系，我们要更具自己想要实现的目标，采用合适的组件，组合创造一个引人入胜的游戏服务。PBL不是所有在所有的工作任务都适用。 但是要如何组合？就是下一层级作者要告诉我们的。建立游戏的6个步骤。 level5 构建游戏化系统的6大步骤1 明确商业目标这其实是告诉我们要以终为始。我们必须明白游戏化的特定目标。这个其实和产品的思维一致。在《用户体验要素》一书中就是 战略层的内容。指定目标的流程如下如四个步骤。 删除机制是为了更加重要的基础的目标必须确保完成。明确目标之后请在每个目标后加上如何让你的企业or产品收益 2 规划目标行为我们要为我们要达成的目标设定明确的用户的目标行为。这些行为最好可以通过一些有些组件，如点数，进行量化。 同时要确保用户可以不断的玩下去，而不是因为摸个获胜状态就结束游戏。等级一级难度的不断提升是一个值得考虑的方式。 最后我们要学会如何分析这些用户数据用于不断改进游戏的设计。比如DAU; GMV等等，这还是要看你的目标。要相互匹配。 3 描述你的用户明确你的目标用户，为不同的而用户心理可以设置不同的游戏化功能。拿魔兽世界距离，有人喜欢组队打怪，有人喜欢一个人探索。 有人将用户区分成：成就者（收集徽章)，探险家(独自探寻) ，社交家（在线互动），杀手（取胜）。我们多多少少都有这些特质在身上，好的游戏化产品要给这些人以空间。 另外在游戏化中，我们要考虑到玩家的生命周期，要给 新手，熟练玩家，专家 以不同的兴奋点。 4 制定活动周期游戏化的发展有两种模式，一种是参与回路，一种是进阶。 参与回路中最重要就是反馈，例如在社交中，人们发出行为如果获得反馈，然后会继续这么做。朋友圈的每次的红点都值得期待，即刻中的每次黄色信封也令人期待。这里 反馈的随机性很重还要但游戏中不能这样，如果第1次反馈和第100次都一样，玩家就会失去兴趣。 所以就有了第二种，进阶。一级一级增加难度。每一关都不一样。每一层的奖励也随机。惊喜不断。参与度就会很高。 5 不要忘了乐趣游戏最重要的那一点，你应该没有忘记，要有趣。你问问自己，当你的游戏没有激励的时候，你还会不会去玩。 6 部署适当工具你需要有工具，有拥有不同技能的伙伴帮你去分析游戏化的有效性，帮助你不断提升对玩家行为的理解。不断优化的你系统。也就是说你要不断去分析游戏化产生的反馈。 level6 避免那些让游戏失败的陷阱前面废话太多，最后一章就是三点总结~ 注意让游戏真正有趣，而不是只靠外在激励。那样游戏可能昙花一现。无法帮你达成目标。 不要把游戏化当成一个简单的营销工具。想办法让用户因为内在动机而持续的玩下去。 不要违反法律，隐私，知识产权等，在中国，你还需要。。。。 要记住让你玩家有掌控感 个人感受整本书在告诉我们如何使用游戏化思维，来使我们玩家能够更多由于自己的内在动机的驱使，完成我们想让他完成的任务。 全书的重点我觉得在前四章。前四章的重点在前两章。因为重点是理解什么是游戏化思维。后面介绍的是实用的工具与方法。 当然不是说方法不重要，但是思路对了，才有可能作对事情。毕竟做产品，还是问问，你为什么要做这件事。 玩游戏最重要就是，你找到了自己想要的乐趣。（也许我错了）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2018 读书进度更新]]></title>
      <url>%2F2018%2F04%2F08%2F2018-%E8%AF%BB%E4%B9%A6%E8%BF%9B%E5%BA%A6%E6%9B%B4%E6%96%B0%2F</url>
      <content type="text"><![CDATA[在读图书：A 认知提升 ：这一些书有一些共同性；交叉阅读；体验更加深刻 《学会提问》 ： 进度 1/2 《有限与无线的游戏》：进度 2/3 《增长黑客》2本： 进度 2/5《影响力》：进度 5/6 B 睡前读物睡前半小时读物： 《千面英雄》《禅与摩托车的维修艺术》《设计中的设计》《乔布斯专》 读书笔记账本：《投资中不简单的事》 已经完成《游戏化思维》《高效能人士的7个习惯》《原则》《需求》《用户体验要素》《习惯的力量》《如何阅读一本书》]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《高效能人士的7个习惯》读书笔记：被书名毁了的书]]></title>
      <url>%2F2018%2F04%2F06%2F%E3%80%8A%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%847%E4%B8%AA%E4%B9%A0%E6%83%AF%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%A2%AB%E4%B9%A6%E5%90%8D%E6%AF%81%E4%BA%86%E7%9A%84%E4%B9%A6%2F</url>
      <content type="text"><![CDATA[[toc] 如果要我评选我看过的书中；被书名毁掉的好书排名，《7个习惯》应该是首当其中了；排名第二的我推荐《把时间当朋友》。这两本书的道理简单而深刻。坚持应用；一定会产生很好效果。无奈很多人都是只听过书名而已，然后就判断这是鸡汤文学。 说到鸡汤文学，我看过不少，大多数是在缓解你的焦虑；但这并不是我们将其视作是无用文章的理由。之所以鸡汤无用，只是你只喝汤而没有行动而已。 说回这本书；柯维博士这本书卖了25年依旧畅销，我想一定是有他的理由的。我记得刘润老师在他的《5分钟商学院》中说到，这是他此生参加过的最重要的培训；没有之一。也足够说明这本书的优点。 虽然我听过别人解读过很多遍；但是我现在越来越有一种感觉，别人解读的虽然好，但那都不是我的东西。我现在理解那些解读，都是推荐而已，别人的解读在你真的看过这本书之前，就是书的腰封而已。 所以；我决定认真的阅读这一本书；并且写下这些读书笔记。 1 前言： 别为了更多金蛋去杀下金蛋的鹅其实前言部分给我触动最大。因为他指出你要想达到自己的目标；你就必须要找到一些原则。并依据个人特点；应用好这些原则。 同时指出了我们都面对的痛苦的表现形式（而这正是我有的感觉）《原则》中也有提到相似的描述： 我们从常常觉得恐惧和不安； 也总是缺乏耐心，想要急切的得到一件东西； 总是喜欢抱怨环境 容易绝望和无助 缺乏生活的平衡；总是处理不好家庭关系。 渴望理解；渴望被重视；但却不愿理解他人。只想表达自己。 最终导致分歧；并让自己停滞不前。 但是如果要改变；也只能自己打开那扇“只能向内打开的” 改变之门。我们有能力改变自己的习惯（《习惯的力量》是很好的教材）但是改变必须付出痛苦；因为“得之太易者必不珍惜” 作者告诫我们由内而外的改造自己的品德成功论，是通往成功正确的道路。我们要改变自己希望速成的思维定式。首先是承认自己的无知；然后才能学习去改变自己对问题的看法；才能改变自己；才能改变环境。 同时我们要认识到效能原则；注意产能与产出的平衡；提醒我们我们要平衡短期与长期利益。这个效能原则是后面7个习惯的基础。 “不要为了金蛋而去杀鹅” 2 习惯一：积极主动；你可以改变那些你认为你无法改变的人与动物之间的差别就是我们可以“思考自己思考的过程”；他帮助我们客观的看待自己的行为；进而更好的了解他人。 积极主动的可以分开看： “积极” 和 “主动”；我的理解就是；主动选择积极的态度与做事方式。 真正的伤害；不是伤害本身；而是我们回应这些伤害的方式。 积极主动的人对刺激理性的做出符合价值观的选择；不受外部环境的影响。因为“除非你愿意没有人能伤害你”；我们有主动权；有能力选择出更加积极处理方式。 多从自身的问题出发；积极主动的思考和解决问题。警惕平时我们言语透露出来的消极与被动。我们要听听自己平时说的话；看看自己是否总是将选择归咎于环境与他人，而不是自己主动做出选择。比如；要是老板真的懂就好了；要是我有时间就好了。都是在推卸责任给外部；而不是主动承担。 积极主动不是胆大妄为；而是像“斯多葛派的哲学”那样；更加切合实际，懂得在在自己可以控制的范围内积极的面对；做到最好。而对于不能改变的泰然处之。 3 习惯二：以始为终；没有目标，你的焦虑无处安放 以始为终；先就是确定方向与目标；然后依据你的价值观和原则坚持做下去。 时刻要记住；我们希望成为什么样的人。因此当务之急是什么。如果你先确定了目标；你的洞察力会大大改善。你会忽略当前环境的干扰。 任何事物都需要两次创造；一次头脑；一次行为上的。做事如此；创业如此；教育子女也是如此。人生也是如此。我们要成为自己的第一次创造者。确认自己的方向与目标。 作者书中拿领导与管理举例：领导关心的是“做正确的事”；而管理关系的是“正确的做事”；领导确定方向和目标；是第一次创造。而管理负责执行，是第二次创造。如果梯子搭错了墙；爬的再快也是枉然。为了更好的以始为终；最好的方式是撰写自己的使命宣言。即将自己的价值观；目标；以及处事的原则写下来。日后做事；最好就以原则为中心；这样；我们可以不被外部环境干扰；可以获得稳定的安全感。人生也会充满力量与智慧。如果我们以他人为中心；或者以自我为中心的话，就会情绪起起落落；缺乏固定的人生方向。也不会活的稳定的安全感。这是人生最大的痛苦之一。所以以终为始；就是先确定目标与方向；然后将它与以后要遵守的原则与价值观写下。以他们为自己的生活中心。就能建立高效的思维定式。 我们需要积极主动的选择；做自己的人生剧本的第一次创造者；然后以始为终；坚持原则的执行。并应用到自己生活的方方面面（需要注意的是；原则是不变的；但是对原则理解可以改变） 我要去写我自己的角色与个人使命宣言了~ ( 我在公司看这本书，大家纷纷表示自己也有，从来没看过，我现在想，为他们可惜。因为他们总想忙完这一阵…然而，每一阵都是这一阵 4 习惯三：要事第一： 自我管理的原则 要事第一就是指的是要对自己进行有效的管理；就是自律与条理。 你需要通过你积极主动的思考；以始为终的设置你的个人使命与原则；然后；按照你的角色，目标，与原则；来确定什么是重要的事。为此你需要能够利用你的独立意识；控制非理性冲动；使自己的行为服从你的个人价值观。学会对不重要的事勇敢的说不。 可以利用时间管理四象限；将自己从琐事中抽离出来；不要尝试管理时间（你无法管理时间）；你只能控制自己。 第二类事务是重要而不紧急的事；这不仅仅是我们需要花费精力最多的部分；更重要的，他也是一种思考事情的角度与方法。 德鲁克说过：“高效能人士脑子里装的不是问题；而是机会”；即使遇到问题；也要尝试与第二类事务的角度思考：是否可以做一些日后预防的或者根本性的措施；避免头疼医头脚疼医脚。 有一本书叫《灰犀牛》；用了一本书的篇幅；其核心思想就是多做第二类事；在重要而不紧急的事情编程紧急的事情之前；做好预防和准备。 作者给出了训练以要事（第二类目标）为中心的思维定式的关键步骤，一周为维度； 1 确定角色；（不同角色不同目标不同任务） 2 确定每个角色的周目标；（一定要有几个第二类目标） 3 为每一项目标安排进度 4 每日调整（所以并不死板；也避免的每日计划） 接下来的事就是根据你自己的原则为中心；将计划付诸实践。这样做可以帮你确认自己的目标；平衡自己生活；将人际关系和结果放在第一位；避免做管理时间的无用功。 总结起来就是：要从重要性而不是紧迫性的角度来观察一切事物；同时在一些特殊情况下懂得的因人而异的变通也是不可缺少的。 （这本书我读的很仔细；不像我读其他书总想一次性读完；如果不实践；那就是白读了。明天是周日；我之前发的动态；日历排列从周日开始；就是为了给我们做一周计划用的吧 🤔） 5 习惯四：双赢思维 ，人际领导的原则人际交往有六种模式，利人利己，损人利己，两败俱伤，独善其身。舍己为人，好聚好散。无疑，现实生活中，双赢一定是最好的模式。 因为，长远来看，没人愿意会永远吃亏，所以不是双赢，就会两败俱伤。 长期的赢输模式，会在平静的外表下，积累很深的压抑的情绪。 这里我想起一个万维刚老师说过的一个毛利人的故事。充分的说明这点。 那如何双赢呢？作者给出了五个要领。 1 双赢品德 分为三个，诚信，成熟，和知足。诚信不用说，作者对于成熟的定义很绝“成熟就是敢作敢为和善解人意之间的一种平衡”其实也就是平衡产能和产出。找到平衡点，是双赢的基础知足，更多是一种富足的心态，他相信资源充足，人人有份。不会因为别人得到而极度。 2 双赢关系 这里说的是你的人情账户。当你有了双赢品德，时间会帮你积累出充足的情感账户。这是你双赢的基础之一。甚至，有时候，这些人会因为充分的信任，即使反对你，也会真心帮助你。(这一点，在我们的产品很技术，视觉需求中，都是很重要的，我体会也很深刻。我看着其他产品不顾一切打成自己需求，而不注意自己的信任账户透支，后面需求评审的时候，可能连说需求的机会都没有，很多时候，都是因为不成熟，不从别人的角度考虑问题。) 3 双赢协议 有了关系，通过落地的协议，去绩效，奖惩。可以将从属关系变为合作关系，上级监督变为自我监督。让人注重结果，激发自我驱动力。 4 双赢体系 双赢体系存在，双赢才能存在。因为，体系中鼓励什么，你就会得到什么。这里很多常见例子，都是倡导双赢，却奖励赢输。。 5 双赢过程 关键是将人和利益分开，注重利益而不是立场。要创造出大家都能获益的方法。分为四个步骤， 从对方角度看问题， 认清主要问题和顾虑(不是立场) 找到大家都能接受的结果 找到解决途径(我在工作中，看到各种斯资源，其实就是只想要自己获利的赢输思维，有时候，付出也不是真心。立场不同，不看利益，却张口说别人”格局太小”，只能哑然) 但是现实生活中，有些情况，就是和零和游戏，就是无法双赢，也没必要勉强。所以作者说，如果不能双赢，就不如好聚好散。 6 习惯五：知彼解己 - 移情沟通的原则 一句话：要想让自己与他人的沟通更加有影响力；要首先通过移情来理解他人。 我们现在大部分人的问题就是自以为是；不喜欢花时间去深入的了解问题；会联想到自己的经历；给出“善意”的建议；试图快刀斩乱麻的解决问题。所以沟通的时候要警惕四种自传式回应 1 价值判断 ： 对别人的意见只有接受或者不接受 2 追根求底 ：依自己的价值探查别人的隐私。 3 好为人师 ：以自己的经验提出忠告（这种错误我常犯） 4 自以为是 ：以自己的行为和动机去衡量别人的行为和动机 事实是；在与人交流时；你如果想影响我；一定是理解我的人。一定是一个可以耐心聆听我们的人。而大部分人聆听只是为了做出回应。但只有通过移情聆听；理解他人诉求和苦衷；我们影响力才能发挥作用。同时；这也是情感投资的最好的方式之一。这并不容易；因为在影响对方之前；你必须先被影响（因为你要真正理解对方）；所以之前说的以原则做事；积极主动；要事第一；以终为始；是自己内心的壁垒。 一个简单的例子；心情不好的时候；如果有一个人在旁边善解人意的倾听；我门 会坦诚到毫无保留的程度。这种投资；虽有风险，但绝对值得。 沟通的时候；也是有技巧可以遵循： 把品德和情感放在12位；而把我们左脑的理性推理放在第三位。不要心急；耐心的理解别人的思路与担忧；表达的自己的态度和建议；你的可信度会大大增加。表达就是根据自己的对他人的理解诉说自己的观点。而理解他人的前提；就是用心聆听。无论在汇报；答辩；或者1v1 中；都是适用的。 反思一下：我平时有好为人师的毛病；在理解聆听父母的事情上做的不好。事实上，我理解他们。但我我的父母在理解我的方面做的似乎也不够好。不知道，如果我先改变；他们会不会一起变化。 7 习惯六： 统合综效； 实质是尊重差异、建立优势并弥补弱点 这个习惯；建立在前五个习惯之上。统合综效就是实现整体大于部分之和。其中的原因是；作者认为；“关系”；也是整体的一部分；而且是最具激发力和创造力的部分～统合综效的精髓；就是尊重差异取长补短。 要做到统合综效；有以下几点值得注意 敞开胸怀；博彩众议 接纳一切奇怪的想法；本身的原则给你安全感和自信；相信一切都会变得更好。当然；有创新要不怕失败；勇于尝试。（有些对失败根根于怀；再也不肯做第二次尝试）这里其实很像《原则》里说的；拥有极度开放的头脑；不要自以为是；常常反问；你怎么知道，你自己就是对的呢？ 学会寻找第三条路 当有冲突的时候；可以利用第5个习惯知彼解己；先理解他人；在表达自己；再利用第4个习惯；找到双赢的道路。为此你需要：从“非此即彼”的思路中走出来。不要做嘴上说双赢；其实却想着控制别人的事儿。这就像开车的时候，想要前进；却不肯松开刹车；而一位的踩油门。后果是双输。这样的人一般缺乏安全感；他们不知道关系中最宝贵的就是差异。因为相同不代表统一；统一也不等于团结。所以我们需要注意： 尊重差异 所见略同的沟通意义不大；有分歧才有收获。与人合作最重要的就是通过习惯5知彼解己；重视和理解不同个体的才能；心理；以及他们眼中的世界。千万不要成为自以为是的人；总以为自己最为可观（这里我要反思自己；我再怼别人的时候；是不是也同样是这种心理？） 要明白：两种完全不同的意见；也是都可以言之成理的。问题不在于逻辑；而在于心理；不要非此即彼 化阻力为动力 动力积极合理；阻力不合逻辑；两者在现实中都存在；如果不设法削减阻力；之增动力；就像给弹簧加力；或者不松刹车的踩油门；迟早会反弹或者导致受伤。而你几次失败之后；就会产生很强的挫败感。积极主动的找大家共同目标；知彼解己的理解他人；表达自己；告诉他们统合综效的好处是1+1&gt;2的双赢结局～不要一开始；就用各种规则；心理；限制住统合综效的可能性。 8 习惯七: 不断更新 不断更新：再小的事儿都是会产生惊人的效果 这是第七个习惯；是最后一个习惯；像是一个提醒。不是看完六个习惯就想喝了杯六个核桃就结束了。不去实践；学习；再实践；是没有用的。所以作者单独拿出一个习惯；目的是告诉我们要不断的更新自己。从来没有速成；也没有一步到位的方法。多多磨刀。习惯七不断更新；指的就是不断提升自己的个人产能。从以下四个方面（都属于第二类事务：重要而不紧急）；均衡的不断提升： 1 身体层面 每周坚持3-6小时；有氧练耐力；伸展瑜伽练韧性；无氧肌肉运动练习力量。当然；你需要哪种练习；什么程度的联系；需要更具的环境来定。关键是不断的持续。（说到这里我表扬下我自己；已经跑了1300km；每天50-70俯卧撑已经做了4个月；感觉不错） 2 精神层面 冥想；思考。反思。记住动机不纯则诸事不顺。坚持冥想；我没有学习过；我就是坐着；注意自己的呼吸；听呼吸的声音。15分钟不算长。每次结束都很清醒。 3 智力层面 读书；每周读书。写作；强迫自己写下来自己的感悟（现在我有点屁事儿就写在即刻上）；通过输出；强迫自己理清自己的思路。强迫自己再看一遍刚刚看的内容。多和别人交流；感受别人的思想；这里也可以利用习惯5知彼解己；不要肤浅只看实物表面；还是往里多看一样；多问一句为什么。 4 社会，情感 心理学说；关系就是一切。我们的情感；源自于和他人关系；每个人都是社会镜的一部分；照出别人的样子；而大多数情况下；我们也是通过别人更好的认识我们自己。人与人之间的交往；都在我们日常点滴中；所以我们要将与他相关的公共关系的三个习惯：双赢思维；知彼解己；统合综效在生活中不断应用。尊重差异；详细有双赢的第三种可能。 每天都花费至少一小时来做123；这种投资是十分值得的；他会给你内在的安全感。让你的影响圈扩大。让你更好的在社会情感中相处；给你力量。因为你知道自己在不断变好。还有什么比这个更能激励你呢？ （道理都是很简单；关键就是坚持。而是否能坚持下去，就看是否有回馈。是否有回馈；看你舍得目标是否合理；不要想一口吃成胖子；也不要想一次计划永远可以永远生效。） 全笔记完。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《用户体验要素》读书笔记：要理解为何这样做产品]]></title>
      <url>%2F2018%2F03%2F15%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%A6%81%E7%9F%A5%E9%81%93%E8%BF%99%E6%A0%B7%E5%81%9A%E4%BA%A7%E5%93%81%2F</url>
      <content type="text"><![CDATA[《用户体验要素》是一本实用类书，试图回答如何以用户体验为中心进行产品设计。作者通过构建自下而上的五层模型：战略层，范围层，结构层，框架层，表现层；来将以用户体验用户需求为中心的设计方式层次清晰的表达出来。并指出；一开始对战略层的深思熟虑，会帮助我们在整个产品设计中节约大量的时间。 作者这本书写于pc时代，大多案例都是网站的建设。但是整个思考产品的思路，直到今天；都没有过时。 一、 以用户体验为中心设计产品用户体验是指产品如何与外界发生接触，也就是用户如何接触和使用你的产品。这并不仅仅是你的产品外观如何设计，功能如何齐全；这些细节入微的细节，都显示出你做产品最本源的想法。 你为什么要做这个产品？你是否真的想过用户的所想和所需。 一个好的产品形态并不应该是功能特性而决定，而是”用户自身心理感受与行为”所决定的。而当前；我们更多的是按照自己的喜好在做产品。 那如何以用户体验为中心设计产品呢？作者给出自己的模型答案。用户体验要素的五层设计模型 二、 五层模型五层模型，通过分解以用户体验为中心的设计过程，更好的解决产品设计的问题。从上而下分别是： 表现层：如何将框架图以合适的视觉样式展现给用户 框架层：如何将结构层的功能以符合用户使用习惯的方式在页面上呈现 结构层：范围层确定的产品功能如何转化为有层次逻辑的产品 范围层：战略层定义的产品目标和用户需求提供用那些功能承载 战略层：产品目标和用户目标；我们想做什么；想给用户提供什么；我们为什么要做 下面逐一介绍下几个层次；以及在在我个人产品经验中现实中的分工大概如何。 2.1 战略层：目标 这一部分需要项目的产品经理或者领导经过一番调研工作后确定。 做一件产品，要回答两个问题。 我们做这件产品的目标是什么？ 对应的用户需求是什么？用户能得到什么？ 我们在项目开始的初始；团队的成员就要对此有 明确 的认识。 对战略明确的认识会在后面的过程中提供一把标尺；引导我们按照正确方向走。因为我们越是明确知道用户想从我们这里获取什么，我们就能够更好的服务他们。 产品目标可以是商业目标，赚钱；可以是达到品牌宣传的目的。为了确保我们达到了目标，我们还要指定衡量的指标。 为了了解用户需求，我们就要对用户进行分析的调研。先通过市场营销的手段细分用户，找到产品真正的目标客群（这很重要；也需要很客观；避免陷入幸存者偏差）；对在对用户进行场景化分析，以确定产品真正可能使用到的场景。 最后，这些需要落成文档；简介明了并切入要点。并让团队成员清晰的了解。 需要注意的是，战略并不是不可以修改。通过后续工作的开展；可以不断的演进。 2.2 范围层：为了达成目标要提供什么 依旧是产品经理要去想的事儿 我们确认了目标，就要想想要提供哪些给用户，能满足他们的这些需求，能达到我们的产品目标。 这一层你要做三件事： 1 定义需求： 明白该做什么，不该做什么。 2 定优先级： 明白什么是必须做的，什么可以缓一下。根据战略；技术实现难度时间成本来判断 然后同样的；我们需要把这些需求点记下来；但不是精细到细节；而是将可能存在冲突的点记下来。作者提供了几个原则，值得参考： 乐观：永远描述如何防止错误的事儿，引导用户做出正确的行为，而不是描述“不应该这么做” 具体：一个功能点的具体要求要明确，因为不明确就会造成实现上的误解 客观：描述尽量使用意义明确的场景 2.3 结构层：提供的功能如何完整的结构化流程化 产品经理的活；有经验的交互有时候也会提供意见 这就好比你把一个个确定好的功能点；整理成一个层次清晰的脑图。对每一个功能点需要一个完整流程图。 对结构是否有质量的的标准是：用户是否功能的每一个步骤都是合理的。 这里我们会产出一个可以给交互设计师的文稿。 2.4 框架层： 结构层的具体化 主要由交互设计师操刀；产品把控方向 这个阶段需要将结构层的变得清晰更加实在。在我们平时的产品设计中就是让交互出原型图。（有时候；我们只有一个点子就让交互去做原型图；简直就是流氓啊） 这个阶段，需要注意让设计尽量符合用户的习惯。 要注意突出重点；让人一眼看到重点的部分。 不要为了所有人的所有偏好做设计。（这与程序员要考虑所有异常不同） 在合适的地方权衡利弊用合适的组件。 这里在平时的产品设计中会产生交互图；并交由视觉设计师；做表现层的设计。 2.5 表现层：框架层的感知化 视觉设计师主导；产品经理根据战略方向把控（你懂一些设计必要的） 将交互稿交给设计师，根据用户感知和战略方向，做出产品的最终呈现形态。视觉设计师不能仅仅考虑美学问题；也要考虑视觉设计有没有破坏产品结构，有没有帮助更好的完成战略目标。 好的视觉设计忠于眼球；用户的眼球移动路径流畅。 通过差异和一致突出页面重点内容；但又不太杂乱。 注意内部一致性（同一个页面的设计语言是否统一）和外部一致性（同一个公司的设计语言是否统一） 配色和字体排版可以有差异化；不用为了统一而牺牲设计；但差异化要用户肉眼可以分别 最终这一阶段；我们会产出视觉稿；结合之前的PRD；产出可给开发提需求的需求文档。 三、一些听起来是废话的总结这五个层面的设计是一个流程；也是一个思路。通过自下而上的设计流程，让产品设计遵循以用户为中心，先确定目标和用户需求，想清楚要为什么用户提供什么价值，再不断往上推进。保证我们不会走偏方向。在底层花的时间越多越充分，后期的流程应该越顺利，因为那些目标需求与价值都明确的记在心中。 但是科普过五层模型的人，却似乎大部分都不是这么做的。也许是他们并没有看完吧。 对于五层模型有两个注意点： 这个五个层面的设计；下层的改动一定会导致上层的设计的变动；而较高一个层的设计改动也要考虑到是否会影响到下一个层次。这种双向联动的效应是一个常识。我们要很注意。因为我们时常做到最后就忘记了我们最开始的目标是什么，或者说；因为上层的改动，已经无法实现我们最初的设想而不自知。 第二；五个层次的工作相连的部分略有重合是一种比较好的节奏；如果一味的要求我们把上一个层次的事儿的做完了；在做下一个层次的事儿；可能会导致一种你和用户都满意个割裂感。也就是说，考虑范围层面的时候，依旧可以对战略进行一定的调整。 最后；我提醒自己一直要记住：知道你在解决什么问题；并知道你为什么要这么做。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《如何阅读一本书》读书笔记：四个层次的阅读]]></title>
      <url>%2F2018%2F03%2F05%2F%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1%E7%9A%84%E9%98%85%E8%AF%BB%2F</url>
      <content type="text"><![CDATA[这是一本实用性书籍。我阅读绝大部份；我没有仔细阅读的部分包括14-19章节；这些章节讲述的是如何阅读一本具体的书籍。我快速掠过；如果我以后要看到这类相似书籍再说。 这是一本教读者如何读书的书；通过四个层次的阅读；可以更好的理解一本书的内容。花费了大量的篇幅讲述了阅读一本书的第三个层次 分析阅读 15个原则；帮助抓住框架；理解内容；找到答案。并且给出了阅读不同类型书籍的方法。在你拿到一本书；不知道如何开始的时候，这是一本很好的读书指南；起码；让你不跑偏。 阅读的四个层次阅读一本书；一本好书的目的；是增加自己的理解能力。而只有一种阅读方式是真正的；就是 你什么都没有；只凭借内心的力量；慢慢提升自己；从模糊的概念；到更加清楚的理解为止。 但是；只有我们知道如何去读的时候才能真正的读懂一本书。书中将阅读分为四个层次： 1 基础阅读：能读懂一句话的文字表面意思 2 检视阅读：系统化略读；短时间抓住一本书的重点 3 分析阅读：追求理解一本书（针对好书） 4 主题阅读：比较阅读同一主题下的多本书；主动分析列举观点相同之处。 这四个层次不是循序渐进的；高层次的会包含低层次的特性。最高的层次的阅读；也就包含了所有层次的阅读特性。 基础阅读：能认得人就可以了。“我这话句说的没毛病。” 你能读懂这句话；却没在意我 “话” 与 “句” 写反了。就不用管这一个阶段了。 检视阅读： 交流前的打量这个层次需要你能够快速抓住一本书的重点；以判断这本书到底值不值得读。因为只有一小部分值得用分析阅读。 检视阅读可以分为两个部分： 第一层次： 有系统的略读或者粗读：快速的弄明白这本书的主题与架构。 重点是 主动专心；但是不花费太多的时间； 可以根据以下步骤： 书名和序言：将书本归类；这到底是一本什么类型的书 研究目录：了解一本书的地图 如果有附录中有重点索引；快速了解书中议题，找到重点主题 了解作者简介 挑几个和主题相关章节进行阅读；注意开头结尾和摘要。 随机挑选阅读；但不要太多；留意与主题相关的内容 第二层次 粗浅的阅读：重点是不停的读下去想了解一本书；如果一开始就陷入细节；会很难有有勇气读下去。所以检视阅读的重点是：不停的读下去；碰到不懂的地方也不要停下来思考与查询。从头读到尾。即使只了解全书的50%；也比半途而非什么都不了解强。 我们通过上面两个步骤就可以快速了解一本书大概的内容；但是想要读的更好；我们就要有自我要求。 提问题：四个基本问题：看完书需要回答的问题 所谓主动阅读；就是能够提出问题。 1 整体来说这本书在谈些什么 2 作者有什么论述；论点；想法等细节；都是如何表达的 3 这本书说的有道理么？全部或者部分。 4 这本书和你有什么关系？ 你是否真的需要去了解这些信息；是否还给你了其他的启发。 读懂一本书；核心就在于提出问题；然后回答或者找出作者的答案。 做笔记：能表达出来的想法；才是有意义的想法读书的时候；你要去记录你自己的想法。用语言表述出来。这可以帮助你记住作者的思想。如果你说你都知道；但是你不知道如何去表达；其实你也许根本不知道自己在想些什么。 分析阅读：与作者交流；去真正理解一本好书。作者总结了一般的规则。分为3个阶段；15个原则。很详实。 阅读一本书；就是和作者的思想的交流。所以可以从交流的角度来理解这些阶段和规则；交流在这里是广义的交流；老师上课是一种交流；同长者聊天也是一种交流。但总体可以分为以下三个部分；我听；我想；我说。 我听：了解作者想说什么？谈话性质： 区分这本书是一本理论的书还是实用性的书。或者小说与文学。因为这会决定我们用一些不同的方式（态度）去阅读（谈话）。比如这一本书；就是一本实用性著作；他有目的性；教你如何阅读一本书。你阅读完会根据是同意作者来决定是否按照作者的建议行动。 谈话主题与套路： 通过阅读能够可以用很小一段文字描述文中主线。并且列出核心的框架。 同时我们可以根据一本书的结构给出自己理解的大纲。这会比较有助于我们理解这本书。我们谈话的时候；总是会用一些开场，或者事实等去丰富我们描述的观点。所有的这些都是在让整个谈话不是特别干。但是透过这些“润色”；我们可以是整个内容脉络更加清晰的展现。 谈话目标 找到对方的目的；想要问的问题或者解决的问题；（我们要找到答案；或者自己回答） 我想：理解作者想表达的主旨；他提出的问题是否解决这一个阶段；通过抓作者的关键字；关键语句；以及一些观点的论点来找到作者想标的的主旨。这是作者的态度；也是他想传达的信息。根据他的描述；我们要找到他这么认为的前因后果。 重点就是可以站在作者的角度去理解这本书；这个时候不去评判；理解和同意 不是一个意思。 然后；我们可以判断；他在谈话目标中提出的问题；哪些已经解决了。哪些是还没解决的。 我说：读懂之前不评论；记住学习才是真理。在于作者的交流中；他是一个弱势的地位。因为他没法对你说“倾听我说完” 所以；我们要遵守思维的礼节；我们最关心的；也是善意对话最关键的；就是我们能学到些什么。除非我们真的了解了一本书；在这之前最好不要说同意与否。 当你不同意作者观点的时候；你的论述最好有理论依据。你能够证明理论是错误的这可以让你避免进入情绪的控制，而说出一些诸如“我不知道你在说什么，但你就是错了”的话来。 因为你一定要切记 赢不是目标；学习才是真理。 主题阅读：博采众议；独立思考。找出统一主题的多本书；配合阅读；列出想要了解的问题；找到多本书对相同主题的描述；进行分析讨论。这里需要注意的是；主题阅读的目标是主题；而不是全书。你需要找到不同书对同一主题的内容。 这一部分我有所体会；之前听得到的时候；各位老师分享读书经验中都有分享过；买统一类目下的两本书；对照阅读。通过客观的分析；你对相关概念会有更加深入的理解。 需要说明的是；四个层次是读一本的理想状态；现实中需要根据不同情况进行调整。不要忘了目标；是理解一本书；而不是用正确的方式读一本书。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《习惯的力量》读书笔记：改变习惯的黄金法则]]></title>
      <url>%2F2018%2F02%2F18%2F%E3%80%8A%E4%B9%A0%E6%83%AF%E7%9A%84%E5%8A%9B%E9%87%8F%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E6%94%B9%E5%8F%98%E4%B9%A0%E6%83%AF%E7%9A%84%E9%BB%84%E9%87%91%E6%B3%95%E5%88%99%2F</url>
      <content type="text"><![CDATA[最近一周看的东西很杂，买了6本书。然后上周末在很down的心情下；看完了《习惯的力量》这本书。和大家分享一下书中核心观点。 1 习惯的运作：三个步骤你有没有想过；你的行为大部分都是习惯？上楼梯的时候先迈左脚还是右脚；写文章的时候喜欢喝咖啡；每到一个时间就很想吃点什么东西等等。 这些不用思考；有身体自动产生行为；都可以称之为习惯。即使你大脑失去记忆；你的身体的习惯依旧会保留。 习惯是怎么发挥作用的呢？神经科学家通过多个典型案例的研究；结合实验室在小白鼠身上做的试验；发现了习惯的回路。分为以下三个步骤：暗示； 惯常行为； 奖赏关系如下图所示： 我们日常行为都是得到一个暗示； 这会触发我们的惯常行为；通过这个行为；我们会得到所谓奖赏；然后重复这个回路。 我们的各种你意识到的，你没意识到的习惯；都是如此 2 习惯产生的关键：大脑的渴求但是光是暗示 与 奖赏 不足以促使我们形成习惯；关键是 奖赏 能不能激发出我们 大脑的渴求 也可以说是 欲望。 因为对巧克力这种食物有渴求；小白鼠能够在听到“滴答”声音后；做出相同的动作；找到最终的 奖赏 对于产品的广告而言；要想效果好；一定要勾起观众内心对奖赏的渴求。 例如；药膏广告勾起了用户对”健康洁白牙齿”的渴求；所以每次都想寻求刷完牙口腔中蛋蛋刺激感这种 奖赏 所以更加准确的习惯流程就是： 你可以利用这个套路养成健身的习惯： 选择一个暗示；比如每天晚上9点就去跑步 选择一个奖赏；比如结束一杯香草奶昔 最后让自己的身体产生对奖赏的渴求这种对预期奖赏的渴求；会让你去选择去跑步；最终养成跑步的习惯。 成功的营销就是找到简单明了的暗示；定义明确的奖赏；让用户产生渴求感。 从这里我们还可以得出一个观察；就是你要创造一个习惯；比如使用一款产品的习惯；你要选择 正确的奖赏。所谓正确；就是让使用的用户获得更美好的体验。而不是承认之前的不美好。 3 一个习惯黄金法则： 习惯不能消除；只可以 改变 刚刚说到习惯的三个要素：暗示；惯常行为；奖赏那边改变习惯的关键就是： 不改变原有的暗示 不改变原有的奖赏 更换新的惯常行为 那个新的惯常行为就是你要要改变的或者要养成的习惯。 A 老习惯： B 新习惯 除了中间的行为；啥都不用改；这就是改变习惯的黄金法则。 所以；一旦我们意识到了我们习惯的回路；改变习惯就成功了一半。因为你只要提供相同的暗示与奖赏；然后做不同行为；持续一段时间就可以了~ 弄清楚你渴求的是什么样的奖赏；这个就是关键了。 4 习惯的作用书中介绍了星巴克让用户养成应对不同情绪顾客的行为习惯；这样可以减少员工情绪奔溃的情况；有利于提升稳定的优质服务。 他们做的就是将自律成为习惯。 书中提出一个观点；我非常赞同； 意志力是一种力量 你白天用的多；晚上能用的就少。所以人们晚上的意志力总是容易松懈。但是；当你把耗费你宝贵意志力的事情；变成你身体的自发意识；也就是习惯的时候；就不会过度消耗你的意志力了。 所以，你看起来那些人自律似乎很痛苦；早起；跑步；健身；读书。这些事；已经成为他们的自发意识；热门早就乐在其中。 而你还在原地害怕。 喂喂喂；说你呢？明天早起的奖赏想好了不？今天早睡的。。 （算了，不可能的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《原则》读书笔记：知道保持开放与如何成长]]></title>
      <url>%2F2018%2F02%2F15%2F%E3%80%8A%E5%8E%9F%E5%88%99%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%9F%A5%E9%81%93%E4%BF%9D%E6%8C%81%E5%BC%80%E6%94%BE%E4%B8%8E%E5%A6%82%E4%BD%95%E6%88%90%E9%95%BF%2F</url>
      <content type="text"><![CDATA[这本原则最近非常火；据说创投圈的人都在读。我在得到app上听过万维钢老师的解读；也写过一些笔记。但是总觉得东西理我自己很远。于是我买回来自己再阅读一次。 在看书这件事儿上；我能看实体书还是愿意看实体书；一个是因为有读书的感觉；一个是不容易分心（因为我注意力冗余分散）；第三读书笔记记录方便。写下来比打出来记忆更加深刻。最后一个是回顾的时候很方便；你要找自己划线做特殊标记的地方太容易了~ 所以我之前的策略是电子买一本；实体书买一本；但是。。现在电子书的价格节节攀升。。还是只看实体书好了 总结（末尾还有几乎一遍一样的；但有惊喜）：整本书上半部分的重点很清晰： 1 正视现实；有方法的（5步流程）追求你想要的东西。2 通过头脑开放；认识自己的障碍；理解人的大不相同；感谢深思熟虑的意见分歧；从失败中吸取教训。问自己：“你怎么知道自己是对的呢”3 不断成长和进化；作出更好的决策；成为更好的自己。 说起来简单；然而知易行难。但即使如此；知道总是改变的第一步。 这本书最大的作用；是让我开始反思自己去年一整年的想法；做事的方法。几乎都是情绪控制着我。有一种“恍然大明白”的感觉；我真的做错了很多事，做错了很多决策。 感谢原则。保持头脑开放；继续前行。 引言&amp;个人历程重点： “独立思考；即使会犯错；保持谦虚和开放的态度” “你怎么知道自己是对的呢” “体验痛苦；从中探索自然想让你学会的东西” 看样子是鸡汤；但是当我看到后面的内容就觉得满身冷汗；说的就是如此自以为是的我的现状。 雷达里奥（下面都成为Ray）在导言中说；《原则》分为上下两部；这是第一部；主要讲述的 生活 和 工作 的原则。下一部将会是 经济 与 投资 原则。期待中。 全书一共分为三个部分 ： 第一部分是个人经历的介绍；第二部分是生活原则的描述；第三部分是工作原则的描述。我看完了前两部分；发现全书才看了一半300多页；下面还有300多页全都是 第一部分是说的个人经历：主要描述了成长；遭遇重大失败；从重大失败中吸取教训；重整桥水；并在这个过程中；逐渐形成并完善了自己的做事的原则。并整理成册。 在其中；对他打击最大的一起失误；因为过度自以为是，导致桥水破产；自己甚至筹集不到去见潜在客户的钱。痛苦无比；但也正是这次痛苦的经历，让他学会了可信度的加权决策；凡事都要多问问自己“你怎么知道自己是对的呢？” 在个人经历的最后一章节，雷达里奥说他把痛苦当做大自然的提醒；告诉他有一些重要的东西要学习。他不会为痛苦沮丧；他开始学会体验痛苦；探索自然（我觉得就是潜意识）想通过痛苦给我们什么收益。甚至开始成为他的一项游戏。 后面重点的第二部分：生活原则 生活原则：1 拥抱现实；应对现实 不要欢笑愿望与现实 不要担心自己形象；而关心能不能实现你的目标 要重视后续的结果以及后续的后续 不要让痛苦妨碍自己的进步 不要把不好归咎与任何人；从自己身上找原因 1.1 做一个超级现实的人在乎梦想；但是扎根于现实 梦想 + 现实 + 决心 = 成功的生活1.2 理解现实；是任何良好结果的根本依据因为当真相与愿望不服的时候；大部分人抗拒真相。 这种认知偏差；有很多心理学现象与之相关；如房间里的大象等。在《需求》 和 《思考快与慢中》都有过相关的论述。说到底；就是要扎根现实。理解现实，然后，改变自己；改变现实 1.3 头脑需要极度开放：头脑极度开放；极度透明有利于快速学习与改进这几乎是整个生活原则中最重要的一条原则了你头脑越是开放，越是不会自欺欺人。其他人给你的反馈就会更加诚实（“你如果是喜欢听与自己意见一样的话；就会得到的反馈就越是虚假”） 如果这些人是可信的人 ；你将会收货很多。 不要担心其他人的看法；那会成为你的障碍你必须以你认为最好的独特的方式行事；这样做一定会收到反馈；我们必须以开放的头脑思考这些反馈。 尽管你的极度透明会让你感觉到不舒服；但是这样对你是最好的。 这一点我略微保留意见~ 得看你身处的环境是否适合极度透明 极度求真，极度透明会带来更加有意义的工作和更好的人际关系1.4 观察自然；学习现实规律两种视角； 自上而下 找事务背后规律： 理解市场；供求关系；宏观大势 自下而上去验证具体情况 ： 验证具体情况是否相符合 不要固守你认为事物 “应该” 是什么样子保持客观： 不要让偏见；使我们无法认识客观情况。 当看到一个认为自然是错误的想法的时候；先假设自己是错的；然后想办法弄明白为什么自然如此是合理的。一个例子： 大草原上鬣狗吃了小幼马；我们会心生同情。但是事实上这是自然法则；自然会走向整体最优；而不是个体最优化。 人也是一样；人们会把对自己或者自己相关的人不利的事情叫做坏事；而忽略更大的好。 群体中也有这种倾向。如宗教歧视。 只根据事务对个人的影响就判断绝对的好与坏是不合理的。（这点很难做到） 一个东西要好；必须符合现实规律；并促进整体的进化；这会带来更大的好进化是宇宙中最强大的力量这里推荐一本书：《基因之河》； 关于进化：还有一本书; 《自私的基因》； 也非常开脑洞 1.5 进化是生命最大的成就和回报个人激励机制必须符合群体目标比如自然给了性行为个体巨大的快乐激励；来达到群体的不断进化迭代 现实为了趋向整体最大化；而不是个体为了整体做贡献，你就有可能收到回报。自然选择让更好产品得以保留；结果是整体的最优化。 通过快速试错以适应现实是无价的实验和适应能带来更快的进步 要意识到你即是一切；又什么都不是。并决定你想成为什么样子“个人即是一切；又什么都不是；这是一个巨大的悖论” 你的未来取决于你的视角 你的未来取决于你的如何看待事物；关心什么事物。 必须决定你多大程度将别人的利益放在你的自己利益之上 拥抱现实，从自然的角度俯视自身很美妙 1.6 理解自然提供的现实教训收益递减规律任何东西在从太少变太多的过程中；边际收益都会递减 没有痛苦就没有收获“人需要困难，这对健康来说是必须的” 1.7 痛苦 + 反思 = 进步如果以正确的态度面对痛苦；感到痛苦就是你的幸运！！ ： 即使反思痛苦 最好的就是在痛苦的当时就进行反思。 1.8 考虑后续与再后续的结果直接结果很可能是诱惑或者痛苦；如果因为直接结果的痛苦而不去做；就很难获得大的成功如果因为直接结果的诱惑而去做了；就会遭遇更大的失败 1.9 接受结果 ： 内控点在生活中不论遇到什么情况；如果你能够负起责任；进行良好的决策；而不是抱怨你无法控制的事情；你将更加容易知找到幸福 不要为喜不喜欢自己的处境担忧；你必须根据自己的愿望找到实现愿望的途径；然后 骨气勇气坚持下去后面的`五部流程会给到你一定帮助 1.10 从更高的层次腐蚀机器想想自己是一个大机器里的一个小机器；拥有改变自己而变得更好的能力通过比较你实现的结果和你的目标；你就能确定如何改进你的机器却别作为机器设计者的你和作为机器中工作者的你最难的事情是在自身所处的环境中 客观的看待我们自己；不高看自己；不承担不应该承担的任务。 擅于请教领域达人；因为你很难客观看待自己；所以你需要依赖他人的意见以及证据如果你头脑开放；足够有决心；你几乎可以实现任何愿望2 五部流程；实现你的人数愿望 1 明确目标 2 找到阻碍目标的问题；并且不容忍问题 3 准确诊断问题，找到问题根源 4 规划可以解决问题的方案 5 做一切必要的事儿来践行这些方案，实现成果 这五个步骤形成一个循环。需要注意的点是： 专注每个点；设定目标的时候就设定目标；不要想实现和出错（延迟批判） 当你诊断问题的时候；就不要想如何解决问题混淆这两个问题会导致你无法发现真正的问题 坚持这些规则；挫折；会让你难受；不完美永远存在；好消息是你可以从错误中吸收学习和成长；坚持下去你就会有收获。 2.1 有明确的目标：排列目标优先级；你几乎可以得到你想要的任何东西；但你无法得到所有东西分清目标和欲望 目标是你真正需要的东西 欲望是你想要但会阻碍你实现目标的东西（比如偷懒） 不要因为某个目标无法实现就否觉他伟大的期望创造伟大的能力 拥有灵活性和自我归咎；那没什么能组织你知道如何应对挫折很重要逆境中；重要的是守住优势；减少损失。你的任务永远是做出尽可能少的选择 吴军老师也说过；成功不难；关键在于 少犯错误 2.2 找出问题但是不容忍令人痛苦的问题待当做考验你潜在进步的机会当你遇到一个问题；那就是一个机会。 大多数人不喜欢这么做。 不要逃避问题；承认问题是改变的第一步忍痛前行；痛苦会给你汇报 不要把某个原因当做问题本身我无法得到很好的睡眠是一个原因我工作效率低是一个问题；前者可能是后者的原因。 重点解决大问题2.3 找到问题根源弄清楚问题；这需要时间去诊断一次良好的诊断一般需要 15-60分钟 区分直接与根本原因2.4 规划方案前进之前先回顾设置方案；写来来所有人都能看到；严格执行规划先于行动；好规划不应定要很多时间2.5 坚定的从头到尾执行方案2.6 保持谦逊； 与其他人高质量交流 保持谦逊；你可以从别人那里得到你需要的东西 找到你最大的弱点；并处理掉2.7 理解自己的认知；理解他人与你不同；保持谦逊提升认知能力；保持头脑开放；从他人那里获得帮助；你可以实现很多事情 3 做到头脑极度开放这一章几乎是生活原则中最重要的一章。(雷达里奥说；这也是全书最重要的一章)主要重点有两个： 一个是为什么要保持头脑开放；一个是什么情况下你是头脑封闭的认识到第二点其实很重要；这会帮助你的日常反思。 认识到自己的障碍和不足； 寻求可信度高的人的意见；设身处地思考和理解；对比自己的；最终做出更好的决策。 3.1 认识你的两大障碍障碍一：意识障碍；理解你的自我意识障碍主要是你潜意识里的防备机制； 使你难以接受你的错误和缺点。 我们有一些根植于内心的需求： 被爱 被需要 害怕死亡 害怕失去 害怕自己无意义 不能让“想要自己正确的需求 ” 压倒 “找出真相” 的需求当有人和你意见不一样；并且要求你解释的时候；你的大脑会把这样的东西当做 攻击；你会变得愤怒。 如果你想要成功；你需要克制这一点。 这样的人你也可以观察一下；身边到处都是。你也可以反思一下；你自己是不是这样的人。（怎么判断自己有这种倾向在后面会说到） 障碍二；思维障碍；理解你的思维盲点障碍人很难理解自己看不到的东西；《需求》 这本书里也有说到 塞缪尔思反射 。如果你一心只想告诉对方自己的认为正确的想法；你就是 一个头脑封闭的人 这样的话；当其他人给你展示各种可能性威胁和批评的时候；你可能会看不见。也无法领会。 3.2 奉行头脑极度开放；不仅仅是“承认自己可能错了”如果你知道自己有盲点；你就能找到一种解决办法。头脑开放不仅仅是“承认自己可能错了”；但是依旧坚持自己的观点。这样作用不大。 a. 诚恳的想想自己也许并不知道最好的解决办法是什么；能不能妥善处理“不知道”很重要很多糟糕的决定是因为他们相信自己是对的。而头脑极度开放的人知道；找到问题的答案很重要。 b. 决策有两个步骤： 1 分析所有相关信息；2 决策听听其他人的观点并加以思考；不会削弱你独立思考；自主决策的自由。只会帮你拥有更广的角度 c. 不要担心你的形象；只担心如何实现目标做出优秀决策的人；很少坚信自己已经掌握了最好的答案；承认自己有缺点 和 盲点 ；并试图了解更多；客服缺陷和盲点。 d 不吸收； 产出也不大好。e 从他人的角度；设身处地；才能评估另一种观点的价值高度接受自己错了的可能性；鼓励别人告诉自己错在哪里 f 记住；你是在寻找最好的答案；不是自己能得出最好的答案知道自己不知道；无比重要。 自问一下；我是不是只是从自己的角度看问题 g 搞清楚你是在争论还是在试图理解一个问题；根据可信度；想想哪种更加合理可信度 有两个特征； 反复的在相关领域成功找到答案（至少三次；拥有硬履历） 再被责问的情况下能对自己的观点做出很好的解释 3.3 领会并感激：深思熟虑的意见分歧沟通方式要让对方觉得：你是试图在理解你需要提问；而不是做出陈述；心平气和的进行讨论，并鼓励对方也这么做。 （某些时候）人们在产生分歧时变得愤怒是毫无意义的当讨论陷入僵局；最没效果的就是；你试图在脑子中将所有的事情都弄得清楚。 3.4 和可信的；愿意表达分歧的人一起审视你的观点既单独询问专家；也鼓励专家在我面前展现意见分歧。 为最坏的做准备。使其看起来不那么糟糕。 3.5 （重要）识别你头脑封闭的迹象a 封闭的人：不喜欢看到自己的观点被挑战不开放：会因为无法说服他人而沮丧；而不是好奇对方为何看法不同。开放： 更想了解为什么会有分歧；明白自己可能是错的 b 封闭的人：喜欢做陈述而不是提问开放的人；可信度很高的人；经常会提出很多问题。并真诚的相信自己可能是错的 c 封闭的人: 更关心自己是否被理解；而不是理解他人封闭的人： 通常担心自己没有被理解开放的人：觉得有必要从他人的视角看问题。 d 封闭的人：“我可能错了。。。但这是我的观点”这是一个敷衍的回答；人们借此来固守自己的观点最好提出一个问题；而不是做出一个断言 e 封闭的人 ： 封闭的人，阻挠别人的发言开放的人更喜欢倾听发言；鼓励表达 f 封闭的人 : 很难同事拥有两种想法同时持有两种想法；并且能保持独立思考。 g 封闭的人 ： 缺乏谦逊开放的人： 时刻担忧自己可能是错误的。 3.6 如何做到头脑开放？ 利用自己的痛苦进行高质量的思考 一旦觉得愤怒；冷静下来；以深思熟虑的方式看待眼前问题 一定要客观；愿意倾听 重视证据 冥想 4 理解人与人大大不相同 要理解：左脑思考偏逻辑；右脑思考偏情感。 要理解：最长发生的斗争就是意识与潜意识；情绪和思考的斗争。 如果你意识不到你的潜意识的存在；你的行为就会像西奥迪尼在《影响力》中做的那个比喻一样；是一个带着按钮的录音机；一按就播放。比如；听到别人反对时候的被侵犯感。 要知道：我们可以改变；通过习惯。 5 如何做出正确的决策好决策最大的敌人是坏情绪如果你被情绪绑架；你讲不可能作出好的决策。作出决策时候必须用逻辑；理性；事实。 正如荣格所说：“如果你不知道潜意识的存在；否则潜意识就会主导你的人生；而你；称之为命运” 先了解；后决策1 是什么 ：先了解决策的基础知识；既包括“是什么”；也包括宏观的因果关系 “习惯性的问自己；我在了解相关情况吗？我已经掌握了决策的所有知识了么？” 为了了解： 要知道应该问什么人 不要高估自己的可信度 不要不区分别人的可信度（在相同领域有过3次以上成功经验的硬简历） 区分事实和观点；不要听到什么信什么；别人说的和做的很可能不一样。 80/20原则：你从20%的信息获得80%的价值；明白关键性的20%是什么 不要完美主义；完美主义的边际效用是 递减的 2 怎么做 ：权衡结果；考虑结果；后续的结果；后续的后续的结果 总结：骗你的，没有惊喜；《原则》说了；别什么都信 23333。 整本书上半部分的重点很清晰： 1 正视现实；有方法的（5步流程）追求你想要的东西。2 通过头脑开放；认识自己的障碍；理解人的大不相同；感谢深思熟虑的意见分歧；从失败中吸取教训。3 不断成长和进化；作出更好的决策；成为更好的自己。 说起来简单；然而知易行难。但即使如此；知道总是改变的第一步。 这本书最大的作用；是让我开始反思自己去年一整年的想法；做事的方法。几乎都是情绪控制着我。大错特错。 感谢原则。保持头脑开放；继续前行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[抖音的产品体验]]></title>
      <url>%2F2018%2F02%2F15%2F%E6%8A%96%E9%9F%B3%E7%9A%84%E4%BA%A7%E5%93%81%E4%BD%93%E9%AA%8C%2F</url>
      <content type="text"><![CDATA[说下体验抖音感受吧 第一，沉浸，高清，人好看，体验确实比同类好不少。也让我眼前一亮。再打开其他的就有一种失落感。因为看到第一眼就是视频里的样子，而其他的，都给你一张他妈都不认识的封面，点击一看…我就不说了… 第二，运营好，相比于快手的不干扰用户让用户自我发展的策略，他做了很多运营工作。有很多明星入驻，带用户一起玩。并且受众年轻化。 第三，我们感觉到的内容同质化严重，就是抖音做了很多运营主题，这就有点给了像一个有趣的命题作文，其实给用户了好用的模版，可以低门槛的产生优质内容，参与度也会高。 之后是无根据扯淡， 抖音的受众群体年轻，我属于🌚，（但我第一反应是，我妈他们看不懂也不会喜欢，他们更佳喜欢火山和快手。 看了十来个直播和小视频的内容，给我一种抖音里的人都好好看好有钱或者好有才的感觉。（这和推荐算法一定也有关系） 而其他直播也好，短视频也好的都是挺正常的。但我看完抖音以后，有一种空虚感，但又想接着刷。让我想起《等待》里的一句歌词 “明知辉煌，过后是暗淡，仍期待着把一切从头来过”🌚 都什么乱七八糟的… 我不想再刷了… 补充：两个多月过去；抖音制造了很多爆款模板。运营可谓相当用心。也捧红一些音乐，这些人和网易云音乐应该有不少重合性。因为我的网易电台里听到的歌有不少部分都是抖音里听过的。 我妈有一次在我女朋友的案例下下载了抖音；每次一刷都能刷半小时。再一次感叹这种首页的设计真的是直接抓住吸引力；基本不给你拒绝时间。而当没有你的大概画像的时候，把受众最广的一部分内容不断推给你；最大程度的留住你，留不住也没关系；因为你可能不是目标用户。陪我妈刷的内容；大部分都是我几周之前看过的，可爱类的居多。人畜无害。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《需求》读书笔记：创造需求的6个关键]]></title>
      <url>%2F2018%2F01%2F25%2F%E3%80%8A%E9%9C%80%E6%B1%82%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%9B%E9%80%A0%E9%9C%80%E6%B1%82%E7%9A%846%E4%B8%AD%E9%AD%94%E5%8A%9B%2F</url>
      <content type="text"><![CDATA[这是一本讲需求创造者的书。书名叫 Demand ； 和我们常常说的 Requirement 是不同的，前者更加偏向于人们内心的渴求。而不是明确的索求。 创造需求的大师；就是可以想群众之想。 通过观察用户的麻烦地图，创造有魔力的产品；提供用户之前不存在的需求；并且不断精进，解决用户的烦恼。 但是书并不是一本创造需求的指导手册。他是通过一些原创的案例的分析；将创造需求的可行的以及需要注意的方向进行总结，变成6个关键点。阅读这些案例与总结；可以为我们提供一定的借鉴意义。但绝不要希望可以按照书中的内容就可以知道现实中的产品如何商业化。 创造需求；首先要做的是理解人真正创造需求的大师，会把所有的精力都投入到对 “人” 了解中。 一个人；一个问题；一个点子 我们都不了解自己的需求的时候，需求创造者 就已经看透了我们的内心，他们创造出我们无法抗拒的产品 从情绪中看需求 看出我们 不可理喻，满腔热情，焦虑苦恼，捉摸不定；我们到底需要什么，讨厌什么呢，什么样的东西能够令我们无法抗拒 从麻烦中看需求 我们真正想要的东西，和我们购买的东西之间，总有一道鸿沟； 这就是创造新需求的机会。他们认识到，人们实际购买行为和心理需求之间差异巨大 哈斯汀斯因为还录像带迟了要交罚款感到痛苦，发现了其中的麻烦，并解决。最终创造了奈飞。 诺基亚的1100 洞察了渔民的需求而大卖。 所以，优秀的需求创造者都知道以下6个关键点。同时知道如何传递这些能力给到团队里的其他人 6个关键点这6个关键点，越到值得说道的地方越少，重复性的内容与无用的描述月来越多。只用看标题；就可以大体上知道这一章的主要到底是什么。这样书来作者的总结能力还是很强的 可以说；这本书的核心是案例。脱离的案例；理论就毫无意义。可是这也是一个悖论；你的案例是来说明的你理论；但是否也可以说案例是经过挑选而展现在你的眼前的；为了证明你所说的话是正确的。 我也无法证实我的想法；因为特例总是存在的 关键1 ：魔力：创造无法割舍的情感共鸣魔力M = 卓越功能F X 情感诉求 案例： zipcar；魏格曼超市卷首语： 赢家需要创造情感共鸣；并把握市场方向 需求没有必然可言；提供用户不具备的选择 zipcar : 密度产生魔力zipcar 初始做共享汽车；理想丰满；上线后市场几乎毫无反应。尽管他拥有很好的理念；卓越的功能，但并不能形成魔力产品。因为当时车辆的距离注册的会员很远；用户用车很不方便。所以用户没有使用的动力。 公司立足的鸿沟是 ： 一遍是客户购买汽车的费用和麻烦 ； 一边是 说走就走的自由 找出现有产品的缺陷并没有用，需要有足够的魅力激发客户的激情；吸引用户的关注。 需求的关键，通常是不起眼的小事。 他走向成功的点是密度 。 在典型用户分布区域，在用车高分期进行高密度投放。同时做好营销宣传与细节的掌控，（因为需求很脆弱）可以唤醒用户的心理需求：不被一辆机械绑架的自由。 需求从来没有必然可言。zipcar 创造并满足了这一需求。 魏格曼超市；以减少麻烦为目的；关注用户的情感诉求；提供用户不具备的选择“关注行业新趋势；赶在其前面；敢于提供当时不具备的选择” 形成魔力的6大行为方式；需求创造者需要： 努力减少消除产品和服务中的不便等各种问题 魏格曼超市形成了自己的魔力；他们提供各种不具备的选择：深夜营业的药房；“没有糖果” 的收银台；儿童房间等等。 知道如何调动客户情感上的兴奋度 邀请大厨；退出廉价方便的主菜；提供菜单等等。帮助用户更加愉悦的购物 为每一位员工赋予创造需求的力量 给员工实现自己的创造需求的能力；这样员工才会主动帮助公司做的更好；比如下雨天；给客户提供撑伞到车内的服务。 敢于认真听取顾客的意见 需要孜孜不倦的实验 保护自身的特性把事情作对；比做快重要 关键2 ：麻烦地图：解决用户没告诉你的困扰可以在头脑中绘制麻烦地图；每一个引起失望的结果；都是一个个麻烦点。 “每个没有必要存在的步骤；都是摩擦点；每个摩擦点代表一个需求创造的机会”“需求；是以解决顾客问题为中心的” 苹果：一键世界的先锋 化摩擦为动力；苹果下载一首歌的点击次数是5次，而其他品牌要18 -35次。“想到李明远对百度音乐的定义： 搜得到；能下载” 绘制麻烦地图的过程中； 你需要想用户的心理活动是什么样的；他们希望从人生中获得什么？如何满足？什么样的麻烦让人用户气愤而无奈；是否存在一些；用户没发现但是我们可以解决 一键世界三大维度： 1 外观设计（奈非改了150版本信封的设计）；2 用户体验（每次微调；减少用户的麻烦）； 3 商业系统 CareCore: 协作式医疗的典范 减少麻烦；而不是减少成本。CareCore为用户提供个性化的医疗服务；费用虽然高；但是麻烦却很少；很专业。强调沟通；从用户出发。真正延长用户的寿命。 去倾听用户的声音；他们不会说出真实的动机和欲望；“比如买奔驰想让隔壁邻居看着眼红” “你只要去看，就能观察到很多情况” corecare 为病人提供免费交通的事情，大多数人都想不到 关键3 ：背景因素：那些看似与产品无关的，却决定产品的命运决定一款产品成功与否力量；常常在你看不见的地方。背景因素就是如此。它构成的基础设施与消费需求之间是相辅相成的。 案例：kindle的成功和Librie的失败。 索尼的电子墨水阅读器比kindle要早出好多年，质量和设计也都不差；却没有取得成功的关键原因是可阅读的书籍的不足。因为出版商觉得这会影响他们自己的收入，不愿提供给到索尼优质的电子书的资源。 浮田嘉孝（索尼CD机的设计师，索尼最富设计天赋的人之一）的失败就是没有观察到这些背景因素对产品成败的影响 kindle则不同；发布的当日就有88000本图书可以下载，比索尼要多的多。 贝索斯说，当自己不知道要怎么做的时候，总是问问自己：“怎么样做对用户更好？” 他也确实这么做了。例如：你再次购买一件你曾经买过的书以及CD的时候，下单的时候会弹出提示框来让你确认。 关键4 ：激发力：让潜在的需求变成真正的需求人的行为很大程度上被自己的各种情绪；偏好所左右；需求像发动机；在激发力的驱使下，一拧就着。 激发力可以让冷淡的骑墙派变得热情；并心甘情愿的变成用户 案例：奈飞；配送速度就是激发力它在增长的阶段发现了湾区的注册数字与人数都高于其他地区；讨论需求没有结果；于是，哈斯汀斯调研发现；只有一个地方不同就是 配送速度；因为奈飞的配送中心就在湾区； 高效便捷的第二天就送达的服务；就是用户兴奋的关键点 后来奈用建立配送中心的地方；注册用户数就会立刻翻倍。 关键5 ：精进曲线：缓慢改进就等于平庸快速迭代；甩开竞争者；才能成为最后的赢家案例懒得写了。。 关键6：去平均好：你不能讨好所有人，一次只满足一类客户设计满足所有人的产品；永远是浪费钱和时间。案例懒得写了。。 产品发布：避免阿克琉斯之踵全书我觉得最值得读两遍的一整节；虽然读下来很有一种心理学与行为经济学的混合。（如果你读过思考快与慢，就不用读第二遍了。）但是一切需求；最终都要回归到人本身。所以更好的了解我们，了解群体，总是有好处的。 用数据说话 做一个现实的人。 决定产品发布成败的是人的思维方式。正确的思维方式是用数据说话；俗话说眼见为实；但是 塞默尔斯反射 却直接指出人性弱点：仅仅凭借数据并不能改变现状；很可能没有人会相信你说的话。（只有我信以为实，才能看得见）；强烈的信念和客观数据之间的竞赛；数据永远是输家 想起三本书：《影响力》；告诉我们如何去影响别人的六大武器。如果塞默尔斯知道，也不会英年早逝。《思考快与慢》《原则》一个告诉我们人们思考问题的误区与人性；一个告诉我们要保持极为开放的头脑；时刻反思；我怎么知道我是正确的呢？ 以防止我们陷入同样的陷阱中。 做事前检查预期性后见之明： 沃顿商学院的米切尔与康奈尔大雪的拉索以及科罗拉多大学的彭宁顿研究发现；想象某个事件已经发生会让你 预见结果、分析能力提升30% 《能量之源》的作者盖里·克莱恩人文： 事前分析能让人们表达心中焦虑；如果没有这样的机会；人们倾向于隐藏；担心表现出来之后会显得自己不忠实；或者打击团队信心。 想象灾难发生；问问自己为什么失败了，将所有可能的失败列出来；尽你所能去避免这些失败。 一个案例值得说的思维方式转变的案例：监管局不是敌人；而是重要客户著名制药公司默克公司采取不同的态度对待FDA； 将他看成客户； “这位重要的客户在做决策的时候，需要哪些信息” 而尽力去提供；而不是“怎么不惹麻烦而绕开监管局” 如此依赖，他们的审批就比其他的公司快很多]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[kotlin学习2 kotlin的编译与反编译以及与java的关系]]></title>
      <url>%2F2017%2F10%2F14%2Fkotlin%E5%AD%A6%E4%B9%A02-kotlin%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E4%B8%8Ejava%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
      <content type="text"><![CDATA[这篇文章主要描述 kotlin 的简单编译与反编译的流程。以及与 java 的关系。之前说到 kotlin 是一个静态的代码语言。他也是需要编译的。需要编译就有编译器；而他和java又是可以相互调用的。所以隐隐约约感觉应该编译出来的东西和应该也和java 相关；下面就来看一下。 下载安装编译器方式在官网上都有；我这里选择的是下载压缩包；你通过sdkman；homebrew等安装当然都是 ok 的。官网链接 点我大帅比。 下载完之后，解压，配置好路径；如下：退出；source 一下你的bashrc或者zshrc 文件；而后验证一下 如此一来，你的编译器就安装好了。下面就是测试。 编译与运行kotlin文件首先；vim 编写一个简单的 hello world 文件 HelloKotlin.kt； 123fun main(args:Array&lt;String&gt;) &#123; println("Hello World")&#125; 第二：编译与运行；与 java 类似；kotlinc HelloKotlin.kt 编译； 运行 kotlin HelloKotlinKt 执行；如下图。 这里需要注意的是；编译的时候产生的文件如下：一个 class 文件；以及一个配置文件的文件夹。这个 class 文件就是我们执行的文件；而编译器在文件末尾加上了 Kt 两个字母用于标记这个Kotlin 的编译文件。 反编译 class 文件既然是 class 文件；可以和java相互执行；javap 反编译一下看看 class 文件的结构。因为kotlin 文件中；我们是没有指定类的；那在class 文件中，一定是会生成类的；否则就和 java 的基本逻辑产生了冲突。我们看一下： 可以反编译的更加彻底一点看下方法内部实现；命令是 javap -c可以看到；调用的都是 java 内部的方法。 打包成jar既然是在 jvm 上运行；一定是可以打成 jar 来执行的；kotlinc 提供了支持。1kotlinc HelloKotlin.kt -include-runtime -d HelloKotlin.jar -include-runtime 是将 kotlin 运行时所需要的包都包含进去的参数。 而后就可以用 java -jar 来执行。得到一样的结果 总结：以上说了如何编译和反编译kotlin 以及如何打成 jar 包运行。当然了一般情况下我们用不到这么麻烦，intellij 提供了很好的支持，但这有助于帮助我们理解 kotlin 与 java 的关系。也有注意我们更好的学习 kotlin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[kotlin学习1 为何学习kotlin]]></title>
      <url>%2F2017%2F10%2F14%2Fkotlin%E5%AD%A6%E4%B9%A01-%E4%B8%BA%E4%BD%95%E5%AD%A6%E4%B9%A0kotlin%2F</url>
      <content type="text"><![CDATA[1 为何使用kotlin 这是一门强势技术 语言那么多；不可能什么语言都学习。学习的一定是要有支撑有前景的语言。比如苹果的swift；即使是有呢么多问题；但是由于有苹果的背书 他可以和java进行相互的调用 他解决了java无法通过迭代解决的问题 已经成为安卓的官方支持语言，发展前景很好 spring5 也提供了对kotlin的原生支持 官方文档齐全好用 http://kotlinlang.org/docs/reference/basic-syntax.html可执行 1.2 kotlin 的特点 简洁；一行代码解决所有 getter 和 setter; it 语法糖等等 安全；使用 optional 避免NPE 相互操作；兼容所有jvm 和 Android的第三方库 良好的工具支持 2 简单代码示例通过 intellij；新建一个 kotlin 的项目；新建一个 kotlin 文件； 官网上有清晰的教程： http://kotlinlang.org/docs/tutorials/getting-started.html 1234567891011121314151617181920212223package com.zhumin.kotlin.demoimport java.util.function.Consumerfun main(args: Array&lt;String&gt;) &#123; print(&quot;hello world&quot;) val list : List&lt;String&gt; = listOf(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;) // 遍历 for(str in list) &#123; println(str) &#125; println(&quot;--------------------&quot;) list.forEach (Consumer &#123;println(it)&#125;) println(&quot;--------------------&quot;) list.forEach(System.out::println)&#125; 可以看到引入的是java中的包；对consumer的用法和java8也几乎是一模一样。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Netty 对 WebSocket的简单实现与剖析]]></title>
      <url>%2F2017%2F06%2F07%2FNetty-%E5%AF%B9-WebSocket%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%89%96%E6%9E%90%2F</url>
      <content type="text"><![CDATA[本文主要描述 netty 对 WebSocket 的支持。并编写一个简单 demo; 对 WebSocket 的内容做了简单剖析。 通过文章会了解为何 WebSocket 是 HTTP 协议升级而来； netty 是如何实现对他的支持等。 WebSocket 的由来HTTP 协议的问题HTTP 协议无状态，为了保持状态，引出了 session &amp; cookies等技术。 HTTP 是基于 请求 和 响应 的，请求一定是客户端发出的。（1.1 还有 keepAlive, 持续连接，在一定时间可以进行连接的复用。） 导致的问题， 服务器无法推送数据。所以早期有客户端轮训技术。会导致资源和网络带宽的浪费。因为 Header 数据每次都要构建。 WebSocket 可以做到什么？WebSocket 来自 Html5; 所以是 HTTP 协议的一个升级版本 协议可以建立浏览器和服务器之间的长连接。 可以实现服务端的push 只需要在一开始建立连接的时候构建 Header；其他时间都不需要再有 Header 信息 因为是基于 HTTP 的，所以建立连接的时候，发的请求是一个标准的 http 请求。只不过是在 Header 中添加了信息。 虽然是基于 Http 的，但是不仅仅在 浏览器上使用也可以通过第三方的工具包在 app 端使用 netty 对 webSocket 的简单实现netty 功能众多，可以实现对 HTTP 的支持，可以实现高性能异步 RPC 的功能。同样，他也支持对 WebSocket 的支持。 虽然用过 netty 的人都说 netty 复杂，但是他无论简单和复杂的应用，写起来都是样的复杂，这样一来平均一下，只要你了解了规则，还是比较简单的2333 netty 实现 websocket 服务端三个步骤 Server Initializer Handler Server因为你无论写什么 Server 都基本是这个套路：贴代码 12345678910111213141516171819202122232425/** * 这个示例主要用来阐述 * netty 对于 WebSocket 连接的支持 * 以及如何写一个简单的WebSocket demo */public class WebSocketServer &#123; public static void main(String[] args) throws Exception &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new WebSocketChannelInitializer()); ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(8899)).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 这里简单解释下为什么有连个 group; 其实一个也没有问题。如果你才会用两个 group；那么 bossGroup 负责接收请求；而 workerGroup 负责处理请求 Initializernetty 的各种复杂功能都是由各个 handler 实现的，实现 WebSocket 也是如此。没啥好说的，贴代码，看注释。 12345678910111213141516171819202122public class WebSocketChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); // 因为是基于HTTP 协议之上的，所以需要使用到 HTTP 的编解码技术 pipeline.addLast(new HttpServerCodec()); // 按照块来写数据 handler pipeline.addLast(new ChunkedWriteHandler()); // http request 和 response 的一个聚合类 // netty 会对http 请求做分段的处理；所以在第一个 http 的示例中，有些会调用多次 pipeline.addLast(new HttpObjectAggregator(8192)); // web socket netty 的特殊支持 // 其中 "ws" 是指的是 websocket 协议路径 // 通常形式 ws://localhost:8899/ws // 8899/ws 后面的 ws 就是我传入的 /ws 路径。 pipeline.addLast(new WebSocketServerProtocolHandler("/ws")); // 插入自定义的 TextWebSocketFrameHandler pipeline.addLast(new TextWebSocketFrameHandler()); &#125;&#125; TextWebSocketFrameHandlerWebSocket 协议的传输是是以 Frame 作为单位的。这里我们处理的是 Text 这种类型的 Frame。传统，贴代码： 12345678910111213141516171819202122232425public class TextWebSocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception &#123; System.out.println("接受到消息：" + msg.text()); // 这里我们接受客户端传来的消息，返回我们当前时间 ctx.writeAndFlush(new TextWebSocketFrame("服务器时间：" + LocalTime.now())); &#125; @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; System.out.println("连接建立 : " + ctx.channel().id().asLongText()); &#125; @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123; System.out.println("连接断开 : " + ctx.channel().id().asLongText()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println("出异常"); ctx.close(); cause.printStackTrace(); &#125;&#125; Frame 一共有六种，我们可以从类的继承上看六种分别有不同的用途，从字面上都比较容易理解至于为什么是六种？ 那是因为 WebSocket 协议就是这么规定的。 简单的网页客户端为了方便，我们就只用简单的 JS 来进行 WebSocket 的调用 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script type="text/javascript"&gt; var socket; // 判断浏览器是不是支持 if(window.WebSocket) &#123; socket = new WebSocket("ws://localhost:8899/ws") socket.onmessage = function (event) &#123; var ta = document.getElementById("responseText"); ta.value = ta.value + "\n" + event.data &#125; socket.onopen = function (event) &#123; var ta = document.getElementById("responseText"); ta.value = "连接开启" &#125; socket.onclose = function (event) &#123; var ta = document.getElementById("responseText"); ta.value = "连接关闭" &#125; &#125; else &#123; alert("浏览器不支持 WebSocket") &#125; // 发送消息 function send(message) &#123; if(!window.WebSocket) &#123; return; &#125; if(socket.readyState == WebSocket.OPEN) &#123; socket.send(message) &#125; else &#123; alert("连接尚未开启") &#125; &#125;&lt;/script&gt;&lt;form onsubmit="return false;"&gt; &lt;textarea name="message" style="width: 400px; height: 200px"&gt;&lt;/textarea&gt; &lt;input type="button" value="发送数据" onclick="send(this.form.message.value)"/&gt; &lt;h3&gt;服务端输出：&lt;/h3&gt; &lt;textarea id="responseText" style="width: 400px; height: 200px"&gt;&lt;/textarea&gt; &lt;input type="button" value="清空数据" onclick="javascript: document.getElementById('responseText').value=''"/&gt;&lt;/form&gt; 测试 启动服务器： 启动客户端 简单的做发你可以在 IntelliJ 中直接运行 html 他会帮你起一个服务。或者你可以用 Python 1python -m SimpleHTTPServer 8080 我采用第一种： 客户端显示连接已经建立 此时，你可以在服务器端看到我们要打出的信息 然后你可以通过客户端给服务器发送消息：比如我发送 敏哥好帅还用你所？ 服务端会收到： 客户端也会收到服务端的时间： 至此，我们可以的这个例子就成功运行了，你停止服务器会看到客户端输出 连接关闭； 你关闭客户端，会看见服务端输出 连接断开。 更近一步，基于 frame ? 基于 http ?基于 frame 的信息传递刚刚说到，WebSocket 在建立长连接后，不需要在传递头信息。我们可以代开 Chrome 的控制台看一下： 我们能看到的是 ws 的连接的信息里有个 Frames 的标签，你传输的信息都在这里。 WebSocket 连接是基于 HTTP 升级的？我们可以刷新一下你的客户端的网页，观察下 network 的输出： 注意看出了 js 之外的连个请求：第一个就是基本的 http 请求，状态的 304 重点在看一下下面的 ws , 他是一个 WebSocket 请求： request 中还有一个1Upgrade:websocket 的内容，就是它将协议由 http 协议升级成为了 websocket 协议。所以就是这么回事 所以，websocket 需要浏览器的支持。 环境 jdk8 netty 4.1.10.Final gradle]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[老妈的生活哲学]]></title>
      <url>%2F2017%2F05%2F07%2F%E6%9C%B1%E8%80%81%E5%B8%88%E4%B8%8E%E8%80%81%E5%A6%88%E7%9A%84%E7%94%9F%E6%B4%BB%E7%BB%86%E8%8A%82%2F</url>
      <content type="text"><![CDATA[最近家里人感冒的多，姐姐的双胞胎，小的那个被我们带到舅舅家。 中午，我去我妈那里; 我：老妈，今晚舅妈有事儿，我带小宝贝，你给我送点饭。 老妈：你中午剩的饭你热热就好啦。 我 ： 。。。那我叫外卖。。 老妈 ： 那我也去吃 😌 – The End –]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux 上搭建 Anaconda, 远程访问 juypter]]></title>
      <url>%2F2017%2F05%2F05%2FLinux-%E4%B8%8A%E6%90%AD%E5%BB%BA-Anaconda-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE-juypter%2F</url>
      <content type="text"><![CDATA[1 什么是 AnacondaAnaconda 能让你轻松安装在数据科学工作中经常使用的包。你还将使用它创建虚拟环境，以便更轻松地处理多个项目。Anaconda 简化了我的工作流程，并且解决了我在处理包和多个 Python 版本时遇到的大量问题。 Anaconda 实际上是一个软件发行版，它附带了 conda、Python 和 150 多个科学包及其依赖项。应用程序 conda 是包和环境管理器。Anaconda 的下载文件比较大（约 500 MB），因为它附带了 Python 中最常用的数据科学包。如果只需要某些包，或者需要节省带宽或存储空间，也可以使用 Miniconda 这个较小的发行版（仅包含 conda 和 Python）。你仍可以使用 conda 来安装任何可用的包，它只是没有附带这些包而已。 除了管理包之外，conda 还是虚拟环境管理器。它类似于另外两个很流行的环境管理器，即 virtualenv 和 pyenv 环境能让你分隔你要用于不同项目的包。你常常要使用依赖于某个库的不同版本的代码。例如，你的代码可能使用了 Numpy 中的新功能，或者使用了已删除的旧功能。实际上，不可能同时安装两个 Numpy 版本。你要做的应该是，为每个 Numpy 版本创建一个环境，然后在适用于项目的环境中工作。 在应对 Python 2 和 Python 3 时，此问题也会常常发生。你可能会使用在 Python 3 中不能运行的旧代码，以及在 Python 2 中不能运行的新代码。同时安装两个版本可能会造成许多混乱和错误。而创建独立的环境会好很多。 也可以将环境中的包的列表导出为文件，然后将该文件与代码包括在一起。这能让其他人轻松加载代码的所有依赖项。pip 提供了类似的功能，即 1pip freeze &gt; requirements.txt。 2 为什么使用 conda 而不是 virtualenv? 3 安装过程1 下载 ，上传到机器你也可以在机器 wget 1https://repo.continuum.io/archive/Anaconda2-4.3.1-Linux-x86_64.sh 2 安装1sh Anaconda2-4.3.1-Linux-x86_64.sh 选择安装目录。为了节约 根目录空间，安装在 12# 目录事先必须不存在/data/min.zhu/anaconda2 下面 source 一下 .bashrc 1source ~/.bashrc 3 设置国内Anaconda源1234# 添加Anaconda的TUNA镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/# TUNA的help中镜像地址加有引号，需要去掉# 设置搜索时显示通道地址conda config --set show_channel_urls yes 4 安装需要的环境比如安装 3.5 的python 1conda create -n lr3 python=3.5 激活 1source activate lr3 之后进入虚拟环境 可以在通过 conda 进行包的管理 1conda install xxx 5 修改 pip 源为阿里源因为有些包点评直接就没有 比如 tflearn 和 tensorflow 123vim ~/.pip/pip.conftrusted-host=mirrors.aliyun.comindex-url=http://mirrors.aliyun.com/pypi/simple/ 6 远程juypter 访问首先，不建议使用root , 当你使用 root 的时候，需要使用如下方法。 1jupyter notebook --allow-root 第二，远程服务器访问需要做一些配置 可以参考如下文章 1http://blog.leanote.com/post/jevonswang/远程访问jupyter-notebook 进行配置 4 管理环境如果你安装了多个环境，但是不记得名字，或者想修改的话，通过 conda-env 这个命令就可以看到你所有的环境了。 可以看到附带所有操作 比如 conda-env list 就是查看所有命令的格式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS 6.x 如何升级 glibc 2.17]]></title>
      <url>%2F2017%2F05%2F05%2FCentOS-6-x-%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7-glibc-2-17%2F</url>
      <content type="text"><![CDATA[引子本文描述如何在 CentOS 6.x 升级蛋疼的 glibc 2.17. 学习机器的内容，需要用到 tensorFlow, 在自己 Mac 上跑太心疼了。 于是尝试在公司的测试机上跑。然而我搭建好 conda, jupyter notebook , 引入 tf 的时候报错。（关于如何 安装科学计算环境，以及远程访问 jupyter notebook, 请看下一篇文章） 如下 在一看机器上的情况 最高只有 2.15 其实已经是运维升级过了的，默认只到 12。主要还是我们的系统版本太低。 CentOS 7.X，GLIBC 已经到 2.17，GCC 也是 4.8.5但是对于公司来说，稳定是第一位的。所以。。。 如何安装两种方法，一种源码编译，一种是用 rpm 来安装，之前看到这篇文章点这里，其实说的还蛮好的，但是只是升级到 2.15， 而最新的 tf 1.1 版本，需要 2.17 的版本。 其实问题最大的就是找不到给 CentOS 6.x 用的 2.17 的 rpm 包，直到今日，我搜到了有人昨天发布一段脚本，才算找到了解决方法，直接给链接 感激万分的点这里 你不愿点看，我就写下来： 12345678910111213#! /bin/sh# update glibc to 2.17 for CentOS 6wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpmwget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpmwget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpmwget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpmsudo rpm -Uvh glibc-2.17-55.el6.x86_64.rpm \glibc-common-2.17-55.el6.x86_64.rpm \glibc-devel-2.17-55.el6.x86_64.rpm \glibc-headers-2.17-55.el6.x86_64.rpm 其实就是下载资源，然后用 rpm 安装。 可能遇到的错误当你执行 1234rpm -Uvh glibc-2.17-55.el6.x86_64.rpm \ glibc-common-2.17-55.el6.x86_64.rpm \ glibc-devel-2.17-55.el6.x86_64.rpm \ glibc-headers-2.17-55.el6.x86_64.rpm 的时候会报错 解决方案：命令结尾加上参数 1--force --nodeps 原因可以看这篇文章 点这里，造成这个问题的主要原因是套件被重複 (强制) 安装了两次以上. 可以用上面的命令进行依赖忽略，也可以卸载。 总结 搜索的关键词真的很重要，谷歌很重要，英语很重要。 运气很重要(这个问题折腾我两个礼拜) 别用百度搜技术问题。 还有，如果你手动编译安装glibc。。。。万一你安装失败就会导致系统各种命令无法执行。。千万别退出。。你一旦退出，就无法登陆了，只能用光盘恢复系统了。。 但是这篇文章里的方法，可以试一试 解决方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8 一个颠覆了面向对象认知的例子]]></title>
      <url>%2F2017%2F05%2F03%2Fjdk8-%E4%B8%80%E4%B8%AA%E9%A2%A0%E8%A6%86%E4%BA%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%A4%E7%9F%A5%E7%9A%84%E4%BE%8B%E5%AD%90%2F</url>
      <content type="text"><![CDATA[1 起源如果你看了上一篇文章关于 Spliterator 分割迭代器，最后一部分说到了图中的两个强制转换逻辑的不合理之处。 第一处，我传入的是一个 Consumer 接口，但是判断的情况却是判断 1action instanceof IntConsumer 而 IntConsumer 和 Consumer 是没有继承关系的平行函数式接口。这样的转换为何会成功？ 第二处，当第一个判断条件不满足的是时候，使用（IntConsumer）强转 lambda 表达式，这样为何能成功被需要传入 IntConsumer 函数所接受呢？ 如下图： 2 尝试解释看看喽先看第二处：lambda表达式也可以强转？我们先写一个类似的例子，有一个需要传入 Consumer 的方法，我们尝试传入一个 IntConsumer 会发生什么情况。 1234567891011121314151617public class ConsumerTest &#123; public void test(Consumer&lt;? super Integer&gt; consumer) &#123; System.out.println(consumer instanceof IntConsumer); consumer.accept(100); &#125; public static void main(String[] args) &#123; ConsumerTest consumerTest = new ConsumerTest(); Consumer&lt;Integer&gt; consumer = i -&gt; System.out.println(i); IntConsumer intConsumer = i -&gt; System.out.println(i); consumerTest.test(consumer); // 面向对象的方式 consumerTest.test(consumer::accept); // 函数式的方式 consumerTest.test(intConsumer::accept); // 函数式的方式 &#125;&#125; 这个例子的输出结果是： 我们发现这三种传入方式都是可以的，第一第二种没什么好说的，因为 Test 方法就是需要传入一个 Consumer， 无论你使用原来传递对象的方式，还是通过方法引用的方法，都是没有问题，可以被执行。 问题在于，第三种方式 1consumerTest.test(intConsumer::accept); // 函数式的方式 当你按住 command 把鼠标放在双冒号的时候 出现的如下： 当你按住 command 把鼠标放在的 accept 时候 出现的如下： 双冒号代表是的当前 lambda 表达式的类型。因为你看我初始化两个consumer的代码 12Consumer&lt;Integer&gt; consumer = i -&gt; System.out.println(i);IntConsumer intConsumer = i -&gt; System.out.println(i); 我后面的表达式是一模一样的。但是却可以赋予两个不同的类型。所以，重点来了 重点是 lambda 表达式的类型，是要靠上下文进行推断的。 这个是和传统面向的编程不一样的地方。需要注意。刚刚上面的第三种调用的方式，就是如此，编译器推断出，你这个 lambda 表达式 intConsumer::accept 肯定是 Consumer&lt;T super Integer&gt; 类型的。所以不报错而这个时候如果你前面加一个强制转换，就像文章一开始的那张图的第二个强转逻辑一样，也是可以的。不过，略显多余就是了。 在看第一处那么什么情况下，才会出现第一种情况，传入的是 Consumer ，但却同时是 instanceof IntConsumer 呢？ 对了！（对什么对，你又没想到）就是这样，你同时继承者两个接口就可以了呀！ 上代码！ 123456789101112131415161718192021222324252627282930313233343536/** * Created by charleszhu on 2017/5/2. */public class ConsumerTest &#123; // 要求传入 Consumer public void testInt(Consumer&lt;Integer&gt; consumer) &#123; // 判断是否为 IntConsumer System.out.println(consumer instanceof IntConsumer); consumer.accept(100); &#125; public static void main(String[] args) &#123; ConsumerTest consumerTest = new ConsumerTest(); consumerTest.testInt(new MyConsumer2&lt;&gt;()); &#125;&#125;/** * 同时实现两个方法 * @param &lt;Integer&gt; */class MyConsumer2&lt;Integer&gt; implements IntConsumer, Consumer&lt;Integer&gt; &#123; public void accept(int value) &#123; System.out.println(value); &#125; public void accept(Integer t) &#123; System.out.println(t); &#125;&#125; 运行一下结果： 就可以发现，这个时候就和开头的那个例子中的，第一处转换： 需要传入的是 Consumer, 但是也是 IntConsumer 的实例，就会进入第一个判断了 至此两个强转就解释完毕了！ 总结这个例子想给大家说的就是函数式接口的很传统的命令式编程还是有一定差别的。尤其是 lambda 表达式的类型是要靠上下文推断的这一点，需要好好的理解~ 只有慢慢理解这些，才能真正理解函数式编程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8 Stream 解析2 - Spliterator分割迭代器]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk8-Stream-%E8%A7%A3%E6%9E%902-Spliterator%E5%88%86%E5%89%B2%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
      <content type="text"><![CDATA[概述说完Stream 的一些源码解析。我们看下我们的 Stream 是如何产生的。我们最为常见的流的产生方式是 collection.stream(), 你点开Stream()方法, 他是通过 Collection 这个上层接口两个java8 新增特性 default method 进行实现。 这就牵扯到一个关键要点 Spliterator ：分割迭代器。 本文主要描述 Spliterator 的作用，大部分来源于你不愿意读的 JavaDoc。 Spliterator 是 jdk8 非常重要的概念。里面的细节很值得学习玩味。 Spliterator 冗长的JavaDoc 说了什么？基本介绍Spliterator 是一个对源（数组，集合，io流等等）中元素进行遍历和分区的类。 可以通过 tryAdvance() 方法逐个遍历，也可以按照 forEachRemaining() 方法进行按 bulk 逐块的遍历。（内部调用的还是tryAdvance） Spliterator 有类似 Collector 中的 characteristics , 但都是由十六进制来表示的。 SIZED :表示大小固定, Collection常用 DISTINCT : 去重, Set常用 SORTED : 有顺序的 SortedSet 会用等等 原生类型的特化版本特化分割迭代器也被提供，和Stream类似。减少装箱和拆箱的操作 比迭代器Iterator 更加高效的遍历元素的方式提供更加高效的方法，进行数据的迭代。Iterator 的使用需要调用两个组合方法 hasNext() 以及 next() ，同事在多线程访问的情况下还会出现竞争，你需要去同步。而分割迭代器 Spliterator 使用函数式编程的方式，只用一个方法就可以做到这个两个函数动作。就避免了竞争 ，就是 tryAdvance() 方法。后面会介绍 Spliterator的接口方法tryAdvance()同时做了 hasNext() 以及 next() 的工作。 1234/*** 对给定的元素进行判断，如果满足条件就会执行 Action*/boolean tryAdvance(Consumer&lt;? super T&gt; action); forEachRemaining()是一个默认方法，对余下的元素进行操作，直到元素全部被遍历完一般情况下回直接调用上面的tryAdvance() 方法，但是也可以更具需要进行重写。1234567/*** 对余下的元素进行操作，直到元素全部被遍历完* 如果源是有序的，遍历也是有序的*/default void forEachRemaining(Consumer&lt;? super T&gt; action) &#123; do &#123; &#125; while (tryAdvance(action));&#125; 这里有一点很值得注意，方法体中的 do {} 是空的，这个是因为 tryAdvance() 方法本身就完成了两个操作 hasNext() 以及 next()，所以方法体中不需要有任何操作了。这个是 函数式编程带来的好处。以及与命令式编程的区别。 trySplit()尝试切分源来的 Spliterator， 返回的是（注意！！！）返回的是 分割出来的那一部分 数据，原有的数据集将不在包含这部分数据集合。两者 没有交集。剩下的可以继续分割，也许不可以继续分割了 举个例子，我原来有 100个元素，我通过 trySplit 切分出 30 个，作为一个新的 分割迭代器 返回，原有的，就还剩下 70 个。 如果是原有数据集合是 ORDERD 的，分出来的也是有序的。 除非元素数量是无穷的，否则，最后一定会出现不能在分割的情况，这种情况下，返回的结果是 null 1Spliterator&lt;T&gt; trySplit(); estimateSize()估算集合剩余给forEachRemaining大小，不一定精确。但是如果这个 Spliterator 是 SIZED，没有被遍历或者 split， 或是 SUBSIZED的，没有被遍历，那么他这个值一定是准确的。 1long estimateSize(); 还有个与之相关的默认方法，就是利用这个特性。123default long getExactSizeIfKnown() &#123; return (characteristics() &amp; SIZED) == 0 ? -1L : estimateSize(); &#125; characteristics()表示集合的特性，一共8个。 分割之前，返回的结果都是一致的 如果返回结果不一致，则操作是不受保证的 而分割之后，不保证一致 有一个默认方法用于判断 Spliterator 是否包含这个特性123default boolean hasCharacteristics(int characteristics) &#123; return (characteristics() &amp; characteristics) == characteristics; &#125; getComparator如果源是SORTED 类型的，且有比较器 Comparator 的话，则返回这个 Comparator，如果是SORTED 类型的，但是没有比较器，则返回 null , 除此之外，都抛出异常 接口的默认方法里，就是抛出了异常 123default Comparator&lt;? super T&gt; getComparator() &#123; throw new IllegalStateException(); &#125; Spliterator的8个Characteristics 特性ORDERED源的元素有序，tryAdvance ，forEachRemaining和 trySplit 都会保证有序的进行元素的处理 需要注意 hashSet 这类 Collection 是不保证有序的 有ORDERED 特性的数据，在并发计算的时候客户端也要做顺序限制的保证 DISTINCT太简单，唯一性。 类似 Set 这样的传入集合会拥有这样的特性 SORTED有这种特性的 Spliterator ，有一个特定的顺序。或者是所有元素都是可比较的，或者是有特定的比较器。 有 SORTED 一定会有 ORDERED SIZED有这种属性的 Spliterator 在遍历和分割之前，estimateSize() 返回的大小是固定的，并且是准确的。 NONNULL不为 NULL, 大部分并发的集合，队列，Map 都可能会有这样的特性。 IMMUTABLE不可变的。元素遍历期间不可以被 添加，替换，删除（cannot be added, replaced, or removed）否则，应该抛出异常。 CONCURRENT支持并发操作的。 顶层的 Spliterator 不可以 CONCURRENT 与 SIZED。 这两者是相互冲突的。 但是分割之后的 Spliterator ， 可能是 SIZED， 顶层不能决定底层 SUBSIZED从trySplit()被分割后的所有分割迭代器都是 SIZED 以及 SUBSIZED 的。如果分割后，没有按照要求返回SIZED 以及 SUBSIZED 属性，那么操作是不被保证的，也就是结果不可预测。 这个属性和 SIZED 的区别就是， SIZED 不保证 SUBSIZED。而 SUBSIZED 会要求保证 SIZED 内部特化而做的函数式接口 (OfPrimitive)除了上面的函数，以及特性，Spliterator 迭代器中，还有几个定义在内部的接口。 OfPrimitive 重载了（overloads）了 Spliterator 的方法。用于实现特化的分割迭代器。 overloads：返回类型名称一致，参数不一致。注意与 override 的区别 一个颠覆面向对象编程常识的现象请大家看图 这两次类型转换奇怪的地方是： IntConsumer 与 Consumer 两个接口，没有继承关系，两个接口是平行的。 这样的转换，在之前是不可能成功的。 简直是颠覆认知啊！ 我悄悄说啊（并没有。。你也基本不会关心不是么。。） 但是在函数式编程中能转换成功呢？ 你可以等我下一篇文章~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8 Stream & BaseStream 源码难点浅析1]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk8-Stream-BaseStream-%E6%BA%90%E7%A0%81%E9%9A%BE%E7%82%B9%E6%B5%85%E6%9E%901%2F</url>
      <content type="text"><![CDATA[概述 简要介绍 Stream 的 javadoc，与集合的关系以及区别，一些重要的注意事项 难懂的 Stream 类的声明，介绍比较难懂的 onClose() 方法的调用 Stream的javadocStream 的作用与特化版本Stream 是对一个序列做 串行 或者 并行 聚合操作。他继承自 StreamStream 同时还有几个特化的版本 ，IntStream , LongStream, DoubleStream. 他们为了减少流操作的时候一些不必要的装箱和拆箱的操作。 需要注意的是，以上四个 Stream 是平行关系，他们都是继承自 BaseStream 举个简单的例子： 12345678910/*** 将集合 widgets 中的元素中红色的元素的重量求和* 第一步 filter() 过滤红色* 第二步 mapToInt() 拿出所有的Red的重量，生成一个 IntStream* 第三步 sum() 求和，并返回*/int sum = widgets.stream() .filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum(); Stream 的组成与特点要想实现计算，所有操作，都会被放入一个 pipeline 当中（类似liunx）中的操作。 而一个流管道（pipeline）包含： source(源)： 数组，集合，迭代器，I/O 操作等等 0个或者多个中间操作： 将一个流转成另外一个流 1个终止操作 : 产生一个结果(比如上面的例子中的求和) or 或者修改传入对象的属性。 流是Lazy的懒惰的！！ 你不加 终止操作 流的操作，就不会被执行。如上面的例子，没有最后的 Sum() 函数，前面的操作是不会被执行的。 集合和Stream 的区别集合： 注重存储，主要考虑元素的访问与管理Stream ：注重计算，主要考虑以一种描述性 的语言来对源进行一系列的操作，并将操作聚合起来。 流的注意事项1 流中的操作，都应是函数式接口（lambda表达式或者方法引用）2 流不能被重用，每个流只能应用一次。想再次操作你需要重新生成一个流 3 流虽然实现了 AutoCloseable 接口，但是几乎所有的流都是不用关闭的，因为他的源大部分情况下都是集合，而集合是不用关闭的。 除非源是一个 I/O Channel。 比如 Files.lines() 方法。如果是这样，Stream 就可以申明在 try-with-resources block 中。关于这个 j7 新接口的使用，可以看我之前的一篇关于 AutoCloseable 的介绍 jdk1.7新增自动关闭接口AutoCloseable 多说一句，Files.lines() 是 j8 中新增的方法，有点类似 python 中 readlines() 方法。很好用。 Stream &amp; BaseStream 解析看不懂的声明我们可以看一下 Stream 以及 BaseStream 的类的声明 1234//Streampublic interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; //BaseStreampublic interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; BaseStream 中，第二个泛型是 S extends BaseStream&lt;T, S&gt; ，而 Stream 中，第二个泛型是 Stream&lt;T&gt;， 正好是满足 extends BaseStream&lt;T, S&gt; 的条件的，所以可以这么写。 两个泛型有没有感觉有点晕。其实比较好理解。 T 这个泛型很好理解，就是流中元素的类型 S ？ 如果你看过javadoc的描述，流的所有中间操作，都会返回一个流，而这个S 就代表着中间操作返回的流的类型。比如我们看一下这个在 Stream 中的方法（其他方法与其一致） 难懂的 onClose() 方法上面我们知道 BaseStream 实现了 AutoCloseable 接口，也就是 Close() 方法可以得到调用。但是 BaseStream 中，给我们提供了要给OnClose() 方法。我们看下截图 这个方法，就是当 Close() 方法被调用的时候 onClose()会被调用。但是有几个注意的点 onColse() 方法也返回一个流，也就是说可以多次调用。 如果你写了多个onClose() 方法，它会按照顺序调用。 前一个 onClose() 方法除了异常不影响后续 onClose 方法的使用 如果多个 onClose() 方法都抛出异常，只展示第一个异常的堆栈，而其他异常会被压缩，只展示部分信息 上代码！！！！！！ 12345678910111213141516171819202122232425/** * Created by charleszhu on 2017/5/2. */public class StreamTestOnCloseTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; testString = Arrays.asList(&quot;min&quot;, &quot;ge&quot;, &quot;da&quot;, &quot;shuaibi&quot;); /** * 两次关闭 * 两次异常 * 预期：两次关闭输出依次打出；两次关闭异常只打印一次堆栈，另外一次只展示 */ try(Stream&lt;String&gt; stream = testString.stream()) &#123; stream.onClose(() -&gt;&#123; System.out.println(&quot;closing 1&quot;); // throw new NullPointerException(&quot;exception 1&quot;); &#125;).onClose(() -&gt; &#123; System.out.println(&quot;closing 2&quot;); throw new NullPointerException(&quot;exception 2&quot;); &#125;).forEach(System.out::println); &#125; &#125;&#125; 结果如下图： 你们明白了吧（我是天才） 好懂的其他方法BaseStream 中有的一些其他方法，除了分割迭代器(后面会单独说，因为太重要) 1Spliterator&lt;T&gt; spliterator(); 其他都比较好懂。值得一说的是以下两个方法： 12S sequential(); // 返回串行流S parallel(); // 返回并行流 你可以看到他们都返回流对象，也就是可以继续调用 sequential 或者 parallel 方法。但是！！！ 无论你中间怎么调用 ，比如 sequential.parallel.parallel.sequential…. 只以最后一个为最终流的类型！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk1.7新增自动关闭接口AutoCloseable]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk1-7%E6%96%B0%E5%A2%9E%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%8E%A5%E5%8F%A3AutoCloseable%2F</url>
      <content type="text"><![CDATA[1 AutoCloseable 接口这是JDK1.7 的新增语法。帮助你自动关闭一些资源。可能你还不知道这个接口 这个接口好就好在，只有一个方法，名叫 close(), 而这正好有是我们各个资源关闭的方法名，所以使用起来相当方便，因为名称一样，代码兼容。 JDK8 中就在很多地方应用了这个接口，比如 Stream 继承了 BaseStream，而 BaseStream 则继承了 AutoCloseable 这个接口。 这个接口的说明很清楚，当你在使用 try-with-resources block 这种语法调用来进行资源获取的时候，在 block 退出之后自动关闭 try-with-resources block 代码块，就是将资源的声明，放在 try 里面； 可以看后面的代码示例 你不用像之前写 finally{} 代码那样的进行关闭。就不会有资源未被释放的问题。 2 测试代码简单测试代码如下 1234567891011121314151617181920212223/** * Created by charleszhu on 2017/5/2. */public class AutoCloseAbleTest implements AutoCloseable&#123; public void doSth() &#123; System.out.println("doStm"); &#125; @Override public void close() throws Exception &#123; System.out.println("Close() 看到没，我被吊了"); &#125; public static void main(String[] args) throws Exception &#123; /** * try-with-resources 语法块 */ try(AutoCloseAbleTest autoCloseAbleTest = new AutoCloseAbleTest()) &#123; autoCloseAbleTest.doSth(); &#125; &#125;&#125; 运行一下，结果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[老版本MacBookPro (厚的) 格式化, U盘安装 MacOS Sierra]]></title>
      <url>%2F2017%2F05%2F01%2F%E8%80%81%E7%89%88%E6%9C%ACMacBookPro-%E5%8E%9A%E7%9A%84-%E6%A0%BC%E5%BC%8F%E5%8C%96-U%E7%9B%98%E5%AE%89%E8%A3%85-MacOS-Sierra%2F</url>
      <content type="text"><![CDATA[引子主要写的点是：U 盘安装盘的制作，以及，为什么会有 can’t be verified 已损坏，重新下载 这些问题，即使你是从 app store 中下载的完整版本。 前两天，我一个朋友拿了一台很老的 MacBook pro , 说他不小心格式化了硬盘，要我重装系统。。 电脑图如下。。 有点洁癖的我看到了想说说，要不你砸了吧（当然我没说。。）但是碍于面子（毕竟我是程序员，外界都说是搞电脑的，约等于 修电脑的，近似于你是修电脑的，也就是说电脑相关的你全都会，不会就是大傻逼）。。 我当然是很愤怒的，之所以没有发作是因为他是我老师。。 如何制作安装盘准备工作你需要一下物品： 一个只要8G的U盘 一台工作良好的 macbook pro 良好的网络 我（你没戏了） 言归正传： 步骤一 ： 在App Store 中下载最新的 macos连接如下 下载地址她会跳转到 app store. 点击下载即可。它会弹出提示让你更新啥的，不用管它，直接下载 下载好了之后，你在你的 应用程序 文件夹，你就可以看到这个了 至此，你的第一任务完成。 步骤二 ：用磁盘工具格式化你的U盘打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致。) 如果不成功，你就多试几次 步骤三 ： 制作安装盘打开你的终端，输入如下命令1sudo /Applications/Install\ macOS\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\ macOS\ Sierra.app --nointeraction 注意空格前面需要有 \ 进行转义 耐心得到 done, 你就可以拿着 U 盘去安装了 无法验证？or 已经损坏？重装的步骤简单，插入u盘，开机按住 option, 选择u 盘的安装盘。接下来选择安装就可以了。 但是，大部分情况下，都会遇到类似 This copy of the Install OS X El Capitan application can’t be verified. It may have been corrupted or tampered with during downloading 或者，直接告诉你损坏了，让你再去下载完整版本。 导致这个的原因是，当你决定将一台mac格式化后，在重装系统的时候，系统的时间已经被改变了。这个时候安装程序就会爆出各种错误。你可以通过 终端输入 date 进行查看，时间应该变成了 2001 年。 这个时候， 你只要通过 date 命令重置时间，就可以解决这个问题。他的参数如下 123456date MMDDHHmmYY replacing the letters as follows.MM - 2 digit month 01 - 12DD - 2 digit date 01 - 31HH - 2 digit hour 01 - 24mm - 2 digit minute 01 - 59YY - 2 digit year &gt; 15 你将时间设置成，你要安装的系统发布之后的一个时间后，退出终端，再次点击操作，就不会有问题。 你也可以看做这个视频 土逼视频 ，需要翻墙。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-32-groupingBy 源码分析]]></title>
      <url>%2F2017%2F04%2F30%2Fjdk8-32-groupingBy-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[jdk8 集合的工厂类 Collectors 提供了两个很好用的静态函数。 groupingBy partitioningBy groupingBy 实现类似 Mysql 中分分组功能。返回一个 Map; 而 partitioningBy可以看做是 groupingBy 的特殊形式。我们后面会接着介绍。 使用的是比如统计每个城市人的“姓”，可以这么写 1Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); 那么，他到底如何利用 Collector 的各个接口来实现的呢？下面我们将深入 JDK 的 Collectors 的源码中，分析一下他是如何工作的。 groupingBy1 第一个重载方法, 要简单就别那么多要求，给你个List不错了分组 groupingBy 有三个重载方法。一个比一复杂。 先看最简单的 12345678/** * @param &lt;T&gt; the type of the input elements * @param &lt;K&gt; the type of the keys*/public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier) &#123; return groupingBy(classifier, toList()); &#125; 这里 T 是输入集合的元素类型， K 是最后产生的 Map 的主键key 的类型。 函数需要传入一个 Function 的函数式接口，Function 的中作就是分类器，比如传入的类型是T 是一个 Person类型 ， 通过 apply() 方法，返回 Person 的属性 name；因为我们要按照 name 来分组。 所以，如果 name 的类型是 String ； 那么 K 就是 String 故而，这个 groupingBy(function) 的功能就很清晰了，就是通过 function 对传入的 T 类型进行分类。然后调用 toList() 方法，也就是说每个分类的Person 会放进一个 List&lt;Person&gt; 中 最终返回的类型就是 Map&lt;String, List&lt;Person&gt;&gt;. 而如果你不想返回的是一个List , 希望是一个 Set. 你就要使用第二个重载方法~ 他允许你定义最后的输出函数。 2 第二个重载方法：我要输出Set看一下函数的定义： 12345678910111213/** * @param &lt;T&gt; the type of the input elements * @param &lt;K&gt; the type of the keys * @param &lt;A&gt; the intermediate accumulation type of the downstream collector * @param &lt;D&gt; the result type of the downstream reduction * @param classifier a classifier function mapping input elements to keys * @param downstream a &#123;@code Collector&#125; implementing the downstream reduction*/public static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream) &#123; return groupingBy(classifier, HashMap::new, downstream); &#125; 这个函数，明显比上一个要复杂，可以看到，多了一个 Collector 的 downstream , 可以自定义输出的集合。上面那个简单版本的函数是是写死的 List 这个函数有四个泛型。 T 原始元素类型，比如我们这是 Person K 返回 Map 的 key, 即最终返回的Map 的建的类型。如果你想按照人的名字分类，那T就是 String, 如果按照年龄分类，那就是 Interger A 是 downstream 的 accumulation 的中间结果类型 D 是最终输出 Map 的 Value 的类型。比如 List 或者 Set 这个方法会调用第三个重载函数，比第二个函数，多了中间的 HashMap::new； 这个是最终返回的 Map 的类型，这里写死的是 HashMap, 如果你想用其他类型，就需要使用最终的也是最复杂的第三个重载函数。 越是你用起来简单的函数，背后的实现就越来越复杂。 3 第三个重载方法: 能看懂就随便你怎么玩12345678910111213141516171819202122232425262728293031323334353637383940414243/*** @param &lt;T&gt; the type of the input elements* @param &lt;K&gt; the type of the keys* @param &lt;A&gt; the intermediate accumulation type of the downstream collector* @param &lt;D&gt; the result type of the downstream reduction* @param &lt;M&gt; the type of the resulting &#123;@code Map&#125;* @param classifier a classifier function mapping input elements to keys* @param downstream a &#123;@code Collector&#125; implementing the downstream reduction* @param mapFactory a function which, when called, produces a new empty* &#123;@code Map&#125; of the desired type*/ public static &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream) &#123; Supplier&lt;A&gt; downstreamSupplier = downstream.supplier(); BiConsumer&lt;A, ? super T&gt; downstreamAccumulator = downstream.accumulator(); BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123; K key = Objects.requireNonNull(classifier.apply(t), "element cannot be mapped to a null key"); A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get()); downstreamAccumulator.accept(container, t); &#125;; BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner()); @SuppressWarnings("unchecked") Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory; if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123; return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID); &#125; else &#123; @SuppressWarnings("unchecked") Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher(); Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123; intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v)); @SuppressWarnings("unchecked") M castResult = (M) intermediate; return castResult; &#125;; return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID); &#125; &#125; 这个函数有5个泛型，除去上面说的 T，K，A，D多了一个 mapFactory 的 Supplier() , 用于得到最终返回的 Map 的类型，第二个重载函数写死的 HashMap，这就可以进行自定义。 这个函数有连个值得注意的点： 所有的Collectors 中函数，如果函数内部还要做集合处理的，都是使用 downstream 这种模式，利用 downstream 的各种已有的的 Supplier Accumulator等，修改来实现自己的功能。比如在 groupingBy 这个函数，一开始就获取了 downstream 的各个组件，组合成自己需要的收集器，进而用于完成分类的行为。（你还可以去看一看 collectingAndThen() 这个函数） groupingBy 函数中有有两处强制类型转换。这里其实很难理解，为何可以直接成功的转换呢？ 第一处 第二处 两处其实都是将最终结果泛型 D 转成 中间结果 A。对于第一处， mapFactory 是作为一个 Supplier 出现，而他的目的是提供中间结果类型，而他上面的 accumulator 的中间结果类型，就是K,A， 所以这样的强转是一定可以成功的 第二处也是一样的，因为全称都使用了 A，其实 A 和 D 在这里，是等价的。所以转换都可以成功。 你去可以从这么一个角度思考问题： 你最终需要生成 D 类型，为何中间要给自己生成一个不一样的 A 类型添堵呢？ 你 4 不 4 sa？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-31-工厂方法收集器Collectors的中的常用函数]]></title>
      <url>%2F2017%2F04%2F13%2Fjdk8-31-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86%E5%99%A8Collectors%E7%9A%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[1 collectorImpl Collectors 中的 的基础 collectorImpl 两个构造方法一个有 finisher(), 一个没有。这个很容易理解，一个需要转换中间结果，一个中间结果和最终结果一致，所以不需要使用 finisher() 方法 2 两种实现方式对于工厂类 两种实现方式 CollectorImpl 来实现。 reduceing 来实现， 而 reducing 方法归根还是用的是 CollectorImpl 方法来实现 3 常见函数1） toList() &amp; toCollection 两个最常用的方法 toList() &amp; toCollection toSet() 方法是也是 toCollection 的特化。 2） joining() joining 三种重载方法 3） mapping() mapping() 将输入元素转换成输出元素 1234Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity= people.stream().collect(groupingBy(Person::getCity,mapping(Person::getLastName, toSet()) // Mapping , 将Person 转换成String , 提供给下游 Collector 使用)); 4） collectingAndThen() collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher) 先过完上层收集器 downstream ，在进行一次 finisher() 转换结果 比如说，你在 toList() 之后，想将它转换成一个 immutableList() 就可以如下使用 List&lt;String&gt; people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList)); 实现其实很有意思 5） counting() , minBy() , maxBy() counting() , minBy() , maxBy() 用 reducing() 实现, reducing() 又是基于 CollectorImpl 实现 6） summingInt() , averagingInt() , averagingDouble() summingInt() 对每一个元素使用 toIntFunction 在累加，实现很有意思 Supplier() 采用生成了一个 长度为1 的 int 数组，而不是直接使用的整形数字？因为数字是一个 值， 值是无法传递的，而数组是一个 引用， 引用是可以传递的。 averagingInt() 求平均值 对于averagingDouble() 的实现可以再去看一下，他的初始数组长度为4，他们视为浮点数计算的补偿产生的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-28-30-自定义收集器&坑]]></title>
      <url>%2F2017%2F04%2F12%2Fjdk8-28-30-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%B6%E9%9B%86%E5%99%A8-%E5%9D%91%2F</url>
      <content type="text"><![CDATA[收集器中有很5个抽象方法，每个抽象方法都有自己特殊的作用，如果说我们要自己实现要给收集器的话，我们就需要分别实现下面五个方法。 1 简单自定义一个收集器这个收集器的目的是将一个 list 转换成一个 set 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MySetCollector&lt;T&gt; implements Collector&lt;T, Set&lt;T&gt;, Set&lt;T&gt;&gt; &#123; @Override public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123; System.out.println("supplier invoked!!!"); return HashSet::new; &#125; @Override public BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123; System.out.println("accumulator invoked!!!"); return Set&lt;T&gt;::add; &#125; /** * 并行性流才会调用，将两个分段的集合 * @return */ @Override public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123; System.out.println("combiner invoked!!!"); return (t1, t2) -&gt; &#123; t1.addAll(t2); return t1; &#125;; &#125; @Override public Function&lt;Set&lt;T&gt;, Set&lt;T&gt;&gt; finisher() &#123; System.out.println("finisher invoked!!!"); return Function.identity(); &#125; /** * 描述这个集合的特性 * IDENTITY_FINISH 表示结果容器和中间容器是一致的，这个时候 JDK 会在返回的时候自动帮助我们做类型转换。而不用再去调用 finisher * @return */ @Override public Set&lt;Characteristics&gt; characteristics() &#123; System.out.println("characteristics invoked!!!"); return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH,UNORDERED)); &#125; public static void main(String[] args) &#123; List&lt;String&gt; words = Arrays.asList("hello" , "world", "welcome", "hello"); Set&lt;String&gt; stringSet = words.stream().collect(new MySetCollector&lt;&gt;()); System.out.println(stringSet); &#125;&#125; 实现类里，我们分别实现了5个方法。 其中比较重要的两个方式 finisher 和 characteristics 方法 这俩方法是相互影响的。首先看 characteristics 方法，这个方法要求返回一个 Characteristics 枚举类型对的 Set。而 Characteristics 一共有三个枚举值。分别有不同的含义。 123456789101112131415161718/** * 当我们采用并行流的时候，同时设置了 CONCURRENT 作为这个流的特性 * 那么，操作的是同一个集合，而不是多个 * 同样的道理，我们采用了并行流的方式，但是没有这个特性，我们就会生成多个 * 集合 */ CONCURRENT, /** * 代表集合是否是有序的 */ UNORDERED, /** * 表示 finisher function 可以被省略，因为中间结果和最后的返回的结果的类型是一致的。 * 所以当我们设置了这个属性之后，我们就必须了解到， 最后的返回的类型，可以由中间结果类型进行强制的返回。 */ IDENTITY_FINISH 上面的例子中，我们为我们自己的 collector 设置了两个属性， IDENTITY_FINISH &amp; UNORDERED ; 意思就是这个收集器收集的元素是无序的。 而同时，返回的类型和中间结果类型是可以完全强制转换的（如果不可以，则会报错，下面会说到）；而 finisher() 函数是不会被执行的，即使你在函数内部直接抛出一个异常都没有问题，因为根本不会执行。执行结果我们可以看一下： 这里需要注意两点： 虽然 combiner() 函数被调用了，但是只是返回了一个 BinaryOperator 而已，而这个 BinaryOperator 并不会被调用。 finisher() 函数并没有被调用，原因上面已经说过 characteristics() 函数被调用了两次，分别代表不同的意思 对于第3点，我们跟进 collector() 源代码里看一下, 便会有答案。 图中书说法其实不准确，其实是 evaluate 方法中的 ReduceOps.makeRef(collector) 中，会逐个调用相关方法， 包括 characteristics() 方法。 所以 characteristics() 被调用了两次，第一次用于判断 是否是无序集合 ；第二次用于判断 是否需要执行 finisher 用于中间结果和最终结果的类型转换 2 当中间结果与返回结果不一致看下面这个改造的自定义收集器，中间结果是个 set 而返回的是个 map，也就是中间结果和最终最终结果是不一致的。这个时候，finisher 函数就会排上用场了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MySetCollector2&lt;T&gt; implements Collector&lt;T, Set&lt;T&gt;, Map&lt;T,T&gt;&gt; &#123; @Override public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123; System.out.println("supplier invoked!!!!!"); return HashSet::new; &#125; @Override public BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123; System.out.println("accumulator invoked!!!!!"); return (set, item) -&gt; &#123; System.out.println(set); System.out.println("threadName: " + Thread.currentThread().getName()); set.add(item); &#125;;// return Set&lt;T&gt;::add; &#125; @Override public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123; System.out.println("combiner invoked!!!!!"); return (set1, set2) -&gt; &#123; set1.addAll(set2); return set1; &#125;; &#125; @Override public Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123; System.out.println("finisher invoked!!!!"); return set -&gt; &#123; Map&lt;T, T&gt; map = new HashMap&lt;&gt;(); set.stream().forEach(item -&gt; map.put(item, item)); return map; &#125;; &#125; /** * 当有 Characteristics.CONCURRENT 意味着如果有并发，则是多个线程操作一个集合。 * 这个时候 accumulator 如果有 遍历操作，就有可能会抛出 ConcurrentModificationException * @return */ @Override public Set&lt;Characteristics&gt; characteristics() &#123; System.out.println("characteristics invoked!!!!"); return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT)); &#125; public static void main(String[] args) &#123; for(int i = 0; i &lt; 100; i ++) &#123; List&lt;String&gt; words = Arrays.asList("hello", "word", "helloword", "hello", "a", "b", "c", "d", "e"); Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(words); Map&lt;String, String&gt; map = set.parallelStream().collect(new MySetCollector2&lt;&gt;()); System.out.println(map); &#125; &#125;&#125; 这里由于我输出与中间结果类型并不一致，所以如果我在 characteristics() 方法中，依旧使用 IDENTITY_FINISH ，也就是进行类型强转，则必然报错，类型转换异常。大家可以自己试一下。 3 并发与并行的区别-并行时候的一些坑这里，有另外一个很要命的坑。 在说这个概念之前，先说一下收集器中 parallel 和 concurrent 的区别 parallel 是并行，会将产生多个集合，多个线程操作，最后合并，也就是会调用 combiner() 方法 concurrent 是并发， 是多个线程对同一个集合进行操作，首先 combiner() 函数不会被执行，而同时，如果你在 accumulator() 函数中进行累加操作，又进行遍历操作，就会抛出并发异常。 用例子说话，首先我们必须采用 并行流 ， 在 accumulator() 函数中遍历 set, 同时将 characteristics() 函数中加入 CONCURRENT 这个属性，你执行100次，基本都会抛出异常 原因很简答也比较复杂： 程序采用了并行流 set.parallelStream()，同时设置了 CONCURRENT 属性；也就是说，多个线程操作同一个集合。 而在 accumulator() 函数中同时遍历了集合，也修改了集合。由于是多线程操作，很大的概率就会发生你一边遍历集合，一遍修改，就会报错。顺被大家可看看 ConcurrentModificationException 的 javadoc. 而如果，你不添加 CONCURRENT 这个属性，就不会报错。因为会生成多个中间集合。这一点，我们可以改造 supplier() 方法，在其中答应一条语句，通过打印了几条语句，就可以看出产生了几个集合。 当然了，如果你在 accumulator() 中不去有那个遍历的操作，也是即使你添加了 CONCURRENT 属性，也是不会报错的。因为你没有并发的即遍历又修改一个集合 而一般产生多少集合，由产生多少个线程决定，而产生多少线程一般由机器经过 超线程 技术之后有多少个处理器而确定的。当然也是可以修改的，但是一般没有必要。 12// 查看有多少处理器Runtime.getRuntime().availableProcessors();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-2-流初步以及Function详解]]></title>
      <url>%2F2017%2F02%2F14%2Fjdk8-2-%E6%B5%81%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8AFunction%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[一 流初步java 8提供一种更加方便的操作集合方式，即流~ StreamStream的概念其实类似于 liunx 操作系统的中的 PipeLine 的概念，可以将数据传输； 流 分为两种： 中间流：数据通过后还返回一个流，不是数据的终点 节点流：数据流入后不再返回流，操作结束，没有返回 使用java8 中的 List 来写一个例子，这个例子是将集合中的所有元素，全部变为大写，而后将元素逐一输出12345678910111213141516171819202122public class Test3 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list1 = Arrays.asList("min.zhu", "yi.yu", "nai.nai");// list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; System.out.println(item)); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); // 流的操作方式 类似 linux 的管道功能 // 流 分为： 中间流 和 节点流 // map 称之为 映射 与 mapper-reducer 阶段的map 功能是一致的，给定一个值，返回会一个由于之映射的值 list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; list2.add(item)); // 函数引用的做法 // String::toUpperCase 其实 和 item -&gt; item.toUpperCase() /** * 一致，都是有输入有输出，而 toUpperCase 的输入，就是调用他的实例对象 * 因为一个类是无法调用他的实例方法的，一定是实例才可以调用实例方法 */ list1.stream().map(String::toUpperCase).forEach(System.out::println); list1.stream().map(String::toUpperCase).forEach(list2::add); &#125;&#125; java8 的调用流的方式，是使用集合的 stream() 方法， 这个方法会返回一个流，之后就可以调用 map() 方法对 list 中的元素做一定的处理。 map() 函数，还是返回了一个流，这个流也有 forEach 方法，这个时候我们还可以调用 forEach 方法对流中的数据进行逐一的处理。 需要注意的是，forEach 函数中, 需要传递的函数的参数是一个 Consumer 的函数式接口，这个接口的抽象方法 accpt() 是没有返回值的，所以，他不在可以返回一个可以继续操作的流。 而我们在看看 map 方法中，需要传递的是一个我们没有见过的 Function 的函数式接口，这个函数式接口，有两个参数，一个是输入参数，一个是返回值。他的唯一的抽象方法中，是接受一个参数，返回一个值。具体见下图，唯一的方法是 apply 方法，它是有返回值的，这一点和现实中的函数很像 我们之前说过，java8 中，新增了很多个函数式接口，分别用于不同的场景如之前说的 Consumer 接口，他是没有返回值的一个场景，专用于处理数据以及今天说的有返回值的 Function 接口 那么这个 Function 的函数式接口，就是我们今天的重点。 二 Functon 接口 以及 BiFunction简介我们可以用一个例子来完整的说明问题： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 函数式接口 Function 的经典案例 * jdk 8 新增很多 函数式接口 * 之前看的 forEach 方法中的 Consumer 接口 ，他的作用就是 对给定的参数进行一系列操作，不返回值 * 而现在的 以及 Test3 中流的 map 方法中 Function 接口 ，他唯一的操作 是apply , 他有返回值，一个value 一个 Return ，与现实当中数学的函数很类似 * * jdk 8 中，接口中 除了可以有 default 方法以外， 还可以有一个 static 方法， static 方法可以有默认的实现 * 可以参考 Function 这个函数式接口 */public class FunctionTest &#123; public static void main(String[] args) &#123; FunctionTest functionTest = new FunctionTest(); // 函数式接口，以及 lambda 表达式，让我们可以在函数操作的时候，传递函数，即传递行为 // 而之前的编程方法，行为必须已经确定，而后进行调用 // 故而 之前的编程方法称之为命令式编程，而后面的方法称之为 函数式编程 // 而 可以传递，或者 返回函数的函数，称之为高阶函数（ js 中随处可见高阶函数 System.out.println(functionTest.compute(1, item -&gt; 2 * item)); // 这种返回方式是 statement 方法 // 上面那种方式是 expression 方式 // 一个是一个标准的语句，而一个是一个表达式 /* * 表达式是不需要分好结尾的 * 而使用 标准语句，则必须要 ； 而且要 &#123;&#125; */ System.out.println(functionTest.compute(1, item -&gt; &#123;return 2 * item;&#125;)); System.out.println(functionTest.compute(2, item -&gt; item * item)); System.out.println(functionTest.convert("hello", item -&gt; item + " world !!")); &#125; public int compute(int value, Function&lt;Integer, Integer&gt; function) &#123; return function.apply(value); &#125; public String convert(String value , Function&lt;String, String&gt; function) &#123; return function.apply(value); &#125;&#125; 主要去看代码的注释，上面写完了所有重点的内容，我们再去看看 Function 这个函数式接口的实现，我们知道，java8 允许接口有 default 方法，而 Function 接口中有两个默认方法： 利用这个两个方法，可以做函数的组合，用一个函数的输出，作为一个函数的输入。 compose 方法，是先执行 before 这个function, 在执行本身这个function； andThen 方法，则是先执行 Function 本体的 apply 方法，在执行传入的 after 的方法 我们来写个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class FunctionTest2 &#123; public static void main(String[] args) &#123; FunctionTest2 functionTest2 = new FunctionTest2(); // 12 System.out.println(functionTest2.compute(2, item -&gt; item * 3, item -&gt; item * item)); // 36 System.out.println(functionTest2.compute2(2, item -&gt; item * 3, item -&gt; item * item)); // 25 System.out.println(functionTest2.compute3(2, 3, (a,b)-&gt; a+b , result -&gt; result * result)); &#125; public int compute (int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; /** * compose 就是 先执行 function2.apply * 再将 function2.apply 的返回值，作为 function1 的输入 * 此时再执行 function1 apply */ return function1.compose(function2).apply(a); &#125; public int compute2 (int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; /** * compose 就是 先执行 function1.apply * 再将 function1.apply 的返回值，作为 function2 的输入 * 此时再执行 function2 apply */ return function1.andThen(function2).apply(a); &#125; /** * 如果想做有两个参数的Function 就需要使用BiFunction * 而 BiFunction 只有一个 andThen , andThen 的输入 是 Function， * 因为是将 Apply 的结果返回，结果只有一个，所以 参数只能是 Function , 而不是 BiFunction * 所以 BiFunction 方法不可能有 compose 方法 * * 对应的 consumer 也有着 BiConsumer 同时，二者因为没有返回值，所以也只可能有 andThen 方法 * @return */ public int compute3 (int a, int b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function) &#123; return biFunction.andThen(function).apply(a,b); &#125; compose 和 andThen 的功能可以从例子中很好的看出来，例子中还有一个新的接口叫 BiFunction, 这个函数式接口是给定两个输入，返回一个输出，解决了有两个参数的函数的问题，对应的，其实 Comsumer 接口也还有一个对应的 BiConsumer 接口。 而当我们去观察这俩 Bi 的接口，都只有一个 andThen 的接口，为啥没有 compose 方法呢？给读者自己思考吧~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-1.1-方法引用：lambda表达式的语法糖]]></title>
      <url>%2F2017%2F02%2F12%2Fjdk8-1-1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
      <content type="text"><![CDATA[方法应用其实是 jdk 8 中的对于 lambda 表达式给予的一种 语法糖 而方法引用一共分为 4 种； 1 类名::静态方法名 2 对象名::方法名 3 类名::实例方法名 4 构造方法引用::new 我们有intellj 编写 lambda 表达式的时候，编译器总是标黄来告诉你，这里可以使用方法引用的方法来进行代码的简化 而方法引用，method reference 其实就是lambda表达式一种语法糖但是 不是所有的 lambda 表达式，都可以用方法引用的方式来编写复杂的 lambda 表达式还是需要老老实实写相关代码 我们通过一个例子来分别讲解这四种方法引用的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static void main(String[] args) &#123; // 第一种 Student student1 = new Student("zhumin1",10); Student student2 = new Student("zhumin2",20); Student student3 = new Student("zhumin3",40); Student student4 = new Student("zhumin4",80); List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4); // jdk 1.8 的新方法 List 中新增加了 sort 方法 // 传统的 lambda 表达式 students.sort((studentP1, studentP2) -&gt; Student.compareByScore(studentP1, studentP2)); // 第一种方法引用的方式 类名::静态方法名 // 不需要传参数，因为可以自动推断出 Student 类型 students.sort(Student::compareByScore); // 第二种 对象名称::方法名称 // 其实和第一种很类似 StudentComparator studentComparator = new StudentComparator(); students.sort((studentP1, studentP2) -&gt; studentComparator.comparator(studentP1, studentP2)); // 对象名称::方法名称 (方法引用的第二种方式) students.sort(studentComparator::comparator); // 第三种方法 类名::实例方法 /** * 比较难理解的的地方是，你会看到调用的函数，和 lambda 表达式需要的参数个数不一致， 会少一个 * 而且类名是没法调用方法名的 * 而理解方式是：调用方法的实例，就是传入lambda 表达式的第一个参数，而剩下所有参数，都作为 调用的实例方法 的参数 * 我们看下面的例子 ， Student 类调用的是其的实例方法 compare（Student） 只有一个参数 * 而 List 的默认方法需要的 Comparator 的函数式接口需要两个参数，看似对应不上，而且，类名也无法调用实例方法 * 实际是，传入的第一参数就是 comare（student）这个函数的调用者，而第二个参数以及后续所有的参数（如果有跟多也是一样），是作为实例方法的参数传入 * 所以少一个参数也没什么 * 而更为关键的是这个就是一个语法糖，为了简化代码而生。理解就好 * 如此一来； 这个第三种方式就很好理解了 * * 类名::实例方法 * 即 lambda 表达式的第一参数就是 实例方法 的调用者，后续所有的参数就是 实例方法的传入参数 */ students.sort(Student::compare); // 再看一个例子 List&lt;String&gt; cities = Arrays.asList("haha","lala","nihao","memeda"); // 对比二者 Collections.sort(cities, (city1, city2) -&gt; city1.compareToIgnoreCase(city2)); Collections.sort(cities, String::compareToIgnoreCase); // 对于第四种，构造方法引用，对于带参数和不带参数的都可以，编译器会自动的进行腿短 MethodRefrenceTest methodRefrenceTest = new MethodRefrenceTest(); // 点击 new 看看会跳到那个方法里去 methodRefrenceTest.getName(String::new); // 点击 new 看看会跳到那个方法里去 methodRefrenceTest.getName2("haa", String::new); &#125; public String getName(Supplier&lt;String&gt; supplier) &#123; return supplier.get() + "haha"; &#125; public String getName2(String name, Function&lt;String ,String&gt; stringFunction) &#123; return stringFunction.apply(name); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-1-函数式接口&lambda表达式]]></title>
      <url>%2F2017%2F02%2F11%2Fjdk8-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[1 lmabda表达式首先看两段对比代码:为jbutton 添加一个时间监听器12345678910// 老写法: 匿名内部类jButton.addActionListener(new AbstractAction() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println("Hello Button"); &#125;&#125;); // lambda 表达式写法jButton.addActionListener(e -&gt; System.out.println("Hello Button")); 对比两个写法，lambda表达式的写法会简单很多，如果你有多行处理逻辑：12345// 加个大括号jButton.addActionListener(e -&gt;&#123; System.out.println("Hello Button!!!!"); System.out.println("Hello Button2!!!!");&#125;); 这里的e，没有声明类型，并不是表示java 不是一个静态语言了，而是，编译器的类型推断告诉可以推断出来这个 e 的类型肯定是一个 AbstractAction, 所以无需去写，当然如写上也没有问题，需要加上括号 1234jButton.addActionListener((AbstractAction e) -&gt;&#123; System.out.println("Hello Button!!!!"); System.out.println("Hello Button2!!!!");&#125;) 所以 lambda 表达式的基本结构如下（根据单个参数和单个操作可以有一定的省略）1234(event e1, event e2 ...) -&gt; &#123; action1; action2;&#125; 一开始可能不是特别好理解，我们可以结合 java8 新增的另一个特性 函数式接口 来一起理解为何我们可以如此编写代码 2 函数式接口什么叫函数式接口呢？ 函数式接口是 jdk1.8 中新增的一个接口类型，为此还新增了一个注解 @FunctionalInterface 用于标注函数接口；我们通过阅读 @FunctionalInterface 的 jdk 文档来进行概念认知。总结起来： 当一个接口 有且只有一个抽象方法，并且这个抽象方法不是继承自 Object 的方法，就会被当做一个 函数式接口 当一个接口被 @FunctionalInterface 注解时，可以当做一个函数式接口 当一个接口被 @FunctionalInterface 注解，但不满足第一个条件的时候，编译器会报错。 当一个接口 没有被 @FunctionalInterface 注解标注，但是满足函数式接口的条件，也会被当做函数式接口 这里的第一条后半部分很重要，如果一个接口，有两个抽象方法，但是其中一个是继承自 Object 类（因为其实万类师祖）, 他仍然是一个函数式接口。 例如以下实例就是一个完整的函数式接口，即使他有2个抽象方法，但是toString是继承自 Object 的方法，所以不会算作函数式接口的抽象方法，所以其中的 test() 方法, 是函数式接口认定的唯一的抽象方法。同理，如果下面的例子只有 toString() 方法，而没有 test() 方法，同时又有 @FunctionalInterface 注解的话，那么编译器会报错。1234567891011121314@FunctionalInterfaceinterface MyInterface &#123; /** * 函数式接口，只能有唯一的抽象方法 */ void test(); /** * 因为改抽象方法，继承自 Object，所以不算函数式接口的抽象方法 * 故而，接口可以算作一个函数式接口 */ String toString();&#125; 我们可以看一下 @FunctionalInterface 的jdk文档，里面有一句: 意思就是说，函数式接口的实现，可以通过 lambda 表达式 方法引用 以及 构造方法引用 的方式来实现。其实我们上面的 lambda 表达式的例子，就是实现的函数式接口。我们来新写一个例子。 12345678910111213141516171819public class Test2 &#123; public void testInterface(MyInterface myInterface) &#123; System.out.println("start ------------------"); myInterface.test(); System.out.println("end --------------------"); &#125; public static void main(String[] args) &#123; Test2 test2 = new Test2(); /* * 因为函数式接口的里唯一的抽象方法test里面，没有参数 * 但是（）不能省略 * 参考Test1 程序里面的Jframe 里的ActionListener */ test2.testInterface(() -&gt; &#123; System.out.println("函数式接口接口实现"); &#125;); &#125;&#125; 我们可以看到，testInterface 方法需要传递一个 testInterface的接口，而我们使用的方式就是 lambda 表达式来实现了一个函数式接口。 可以运用下面的形式来理解。 (函数式接口唯一的抽象方法的参数列表) -&gt; {唯一抽象函数的实现} 这个时候，我们看一下最开始的那个给 button 加 action 的例子。其实实现就是 ActionListener 这个函数式接口的唯一的抽象方法：虽然该类没有 @FunctionalInterface 注解，但是满足条件，只有一个抽象方法，所以他也是一个函数式接口，所以我们可以去使用 lambda 表达式去实现他。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[new start]]></title>
      <url>%2F2017%2F01%2F11%2Fnew-start%2F</url>
      <content type="text"><![CDATA[重新开始维护这个网站。让自己配得上这个不错的域名 movingon.cn! 我14年买了这个域名，本来想自己要好好做，实在不行，这域名也是一个不错的督促。 然而，自己维护了一段时间之后，就忘记了要去维护。 但是这一次，我用这里记录自己的技术成长以及个人感悟，作为自己的成长的记录。]]></content>
    </entry>

    
  
  
</search>
