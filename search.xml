<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[《如何阅读一本书》读书笔记：四个层次的阅读]]></title>
      <url>%2F2018%2F03%2F05%2F%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1%E7%9A%84%E9%98%85%E8%AF%BB%2F</url>
      <content type="text"><![CDATA[这是一本实用性书籍。我阅读绝大部份；我没有仔细阅读的部分包括14-19章节；这些章节讲述的是如何阅读一本具体的书籍。我快速掠过；如果我以后要看到这类相似书籍再说。 这是一本教读者如何读书的书；通过四个层次的阅读；可以更好的理解一本书的内容。花费了大量的篇幅讲述了阅读一本书的第三个层次 分析阅读 15个原则；帮助抓住框架；理解内容；找到答案。并且给出了阅读不同类型书籍的方法。在你拿到一本书；不知道如何开始的时候，这是一本很好的读书指南；起码；让你不跑偏。 阅读的四个层次阅读一本书；一本好书的目的；是增加自己的理解能力。而只有一种阅读方式是真正的；就是 你什么都没有；只凭借内心的力量；慢慢提升自己；从模糊的概念；到更加清楚的理解为止。 但是；只有我们知道如何去读的时候才能真正的读懂一本书。书中将阅读分为四个层次： 1 基础阅读：能读懂一句话的文字表面意思 2 检视阅读：系统化略读；短时间抓住一本书的重点 3 分析阅读：追求理解一本书（针对好书） 4 主题阅读：比较阅读同一主题下的多本书；主动分析列举观点相同之处。 这四个层次不是循序渐进的；高层次的会包含低层次的特性。最高的层次的阅读；也就包含了所有层次的阅读特性。 基础阅读：能认得人就可以了。“我这话句说的没毛病。” 你能读懂这句话；却没在意我 “话” 与 “句” 写反了。就不用管这一个阶段了。 检视阅读： 交流前的打量这个层次需要你能够快速抓住一本书的重点；以判断这本书到底值不值得读。因为只有一小部分值得用分析阅读。 检视阅读可以分为两个部分： 第一层次： 有系统的略读或者粗读：快速的弄明白这本书的主题与架构。 重点是 主动专心；但是不花费太多的时间； 可以根据以下步骤： 书名和序言：将书本归类；这到底是一本什么类型的书 研究目录：了解一本书的地图 如果有附录中有重点索引；快速了解书中议题，找到重点主题 了解作者简介 挑几个和主题相关章节进行阅读；注意开头结尾和摘要。 随机挑选阅读；但不要太多；留意与主题相关的内容 第二层次 粗浅的阅读：重点是不停的读下去想了解一本书；如果一开始就陷入细节；会很难有有勇气读下去。所以检视阅读的重点是：不停的读下去；碰到不懂的地方也不要停下来思考与查询。从头读到尾。即使只了解全书的50%；也比半途而非什么都不了解强。 我们通过上面两个步骤就可以快速了解一本书大概的内容；但是想要读的更好；我们就要有自我要求。 提问题：四个基本问题：看完书需要回答的问题 所谓主动阅读；就是能够提出问题。 1 整体来说这本书在谈些什么 2 作者有什么论述；论点；想法等细节；都是如何表达的 3 这本书说的有道理么？全部或者部分。 4 这本书和你有什么关系？ 你是否真的需要去了解这些信息；是否还给你了其他的启发。 读懂一本书；核心就在于提出问题；然后回答或者找出作者的答案。 做笔记：能表达出来的想法；才是有意义的想法读书的时候；你要去记录你自己的想法。用语言表述出来。这可以帮助你记住作者的思想。如果你说你都知道；但是你不知道如何去表达；其实你也许根本不知道自己在想些什么。 分析阅读：与作者交流；去真正理解一本好书。作者总结了一般的规则。分为3个阶段；15个原则。很详实。 阅读一本书；就是和作者的思想的交流。所以可以从交流的角度来理解这些阶段和规则；交流在这里是广义的交流；老师上课是一种交流；同长者聊天也是一种交流。但总体可以分为以下三个部分；我听；我想；我说。 我听：了解作者想说什么？谈话性质： 区分这本书是一本理论的书还是实用性的书。或者小说与文学。因为这会决定我们用一些不同的方式（态度）去阅读（谈话）。比如这一本书；就是一本实用性著作；他有目的性；教你如何阅读一本书。你阅读完会根据是同意作者来决定是否按照作者的建议行动。 谈话主题与套路： 通过阅读能够可以用很小一段文字描述文中主线。并且列出核心的框架。 同时我们可以根据一本书的结构给出自己理解的大纲。这会比较有助于我们理解这本书。我们谈话的时候；总是会用一些开场，或者事实等去丰富我们描述的观点。所有的这些都是在让整个谈话不是特别干。但是透过这些“润色”；我们可以是整个内容脉络更加清晰的展现。 谈话目标 找到对方的目的；想要问的问题或者解决的问题；（我们要找到答案；或者自己回答） 我想：理解作者想表达的主旨；他提出的问题是否解决这一个阶段；通过抓作者的关键字；关键语句；以及一些观点的论点来找到作者想标的的主旨。这是作者的态度；也是他想传达的信息。根据他的描述；我们要找到他这么认为的前因后果。 重点就是可以站在作者的角度去理解这本书；这个时候不去评判；理解和同意 不是一个意思。 然后；我们可以判断；他在谈话目标中提出的问题；哪些已经解决了。哪些是还没解决的。 我说：读懂之前不评论；记住学习才是真理。在于作者的交流中；他是一个弱势的地位。因为他没法对你说“倾听我说完” 所以；我们要遵守思维的礼节；我们最关心的；也是善意对话最关键的；就是我们能学到些什么。除非我们真的了解了一本书；在这之前最好不要说同意与否。 当你不同意作者观点的时候；你的论述最好有理论依据。你能够证明理论是错误的这可以让你避免进入情绪的控制，而说出一些诸如“我不知道你在说什么，但你就是错了”的话来。 因为你一定要切记 赢不是目标；学习才是真理。 主题阅读：博采众议；独立思考。找出统一主题的多本书；配合阅读；列出想要了解的问题；找到多本书对相同主题的描述；进行分析讨论。这里需要注意的是；主题阅读的目标是主题；而不是全书。你需要找到不同书对同一主题的内容。 这一部分我有所体会；之前听得到的时候；各位老师分享读书经验中都有分享过；买统一类目下的两本书；对照阅读。通过客观的分析；你对相关概念会有更加深入的理解。 需要说明的是；四个层次是读一本的理想状态；现实中需要根据不同情况进行调整。不要忘了目标；是理解一本书；而不是用正确的方式读一本书。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[kotlin学习2 kotlin的编译与反编译以及与java的关系]]></title>
      <url>%2F2017%2F10%2F14%2Fkotlin%E5%AD%A6%E4%B9%A02-kotlin%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E4%B8%8Ejava%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
      <content type="text"><![CDATA[这篇文章主要描述 kotlin 的简单编译与反编译的流程。以及与 java 的关系。之前说到 kotlin 是一个静态的代码语言。他也是需要编译的。需要编译就有编译器；而他和java又是可以相互调用的。所以隐隐约约感觉应该编译出来的东西和应该也和java 相关；下面就来看一下。 下载安装编译器方式在官网上都有；我这里选择的是下载压缩包；你通过sdkman；homebrew等安装当然都是 ok 的。官网链接 点我大帅比。 下载完之后，解压，配置好路径；如下：退出；source 一下你的bashrc或者zshrc 文件；而后验证一下 如此一来，你的编译器就安装好了。下面就是测试。 编译与运行kotlin文件首先；vim 编写一个简单的 hello world 文件 HelloKotlin.kt； 123fun main(args:Array&lt;String&gt;) &#123; println("Hello World")&#125; 第二：编译与运行；与 java 类似；kotlinc HelloKotlin.kt 编译； 运行 kotlin HelloKotlinKt 执行；如下图。 这里需要注意的是；编译的时候产生的文件如下：一个 class 文件；以及一个配置文件的文件夹。这个 class 文件就是我们执行的文件；而编译器在文件末尾加上了 Kt 两个字母用于标记这个Kotlin 的编译文件。 反编译 class 文件既然是 class 文件；可以和java相互执行；javap 反编译一下看看 class 文件的结构。因为kotlin 文件中；我们是没有指定类的；那在class 文件中，一定是会生成类的；否则就和 java 的基本逻辑产生了冲突。我们看一下： 可以反编译的更加彻底一点看下方法内部实现；命令是 javap -c可以看到；调用的都是 java 内部的方法。 打包成jar既然是在 jvm 上运行；一定是可以打成 jar 来执行的；kotlinc 提供了支持。1kotlinc HelloKotlin.kt -include-runtime -d HelloKotlin.jar -include-runtime 是将 kotlin 运行时所需要的包都包含进去的参数。 而后就可以用 java -jar 来执行。得到一样的结果 总结：以上说了如何编译和反编译kotlin 以及如何打成 jar 包运行。当然了一般情况下我们用不到这么麻烦，intellij 提供了很好的支持，但这有助于帮助我们理解 kotlin 与 java 的关系。也有注意我们更好的学习 kotlin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[kotlin学习1 为何学习kotlin]]></title>
      <url>%2F2017%2F10%2F14%2Fkotlin%E5%AD%A6%E4%B9%A01-%E4%B8%BA%E4%BD%95%E5%AD%A6%E4%B9%A0kotlin%2F</url>
      <content type="text"><![CDATA[1 为何使用kotlin 这是一门强势技术 语言那么多；不可能什么语言都学习。学习的一定是要有支撑有前景的语言。比如苹果的swift；即使是有呢么多问题；但是由于有苹果的背书 他可以和java进行相互的调用 他解决了java无法通过迭代解决的问题 已经成为安卓的官方支持语言，发展前景很好 spring5 也提供了对kotlin的原生支持 官方文档齐全好用 http://kotlinlang.org/docs/reference/basic-syntax.html可执行 1.2 kotlin 的特点 简洁；一行代码解决所有 getter 和 setter; it 语法糖等等 安全；使用 optional 避免NPE 相互操作；兼容所有jvm 和 Android的第三方库 良好的工具支持 2 简单代码示例通过 intellij；新建一个 kotlin 的项目；新建一个 kotlin 文件； 官网上有清晰的教程： http://kotlinlang.org/docs/tutorials/getting-started.html 1234567891011121314151617181920212223package com.zhumin.kotlin.demoimport java.util.function.Consumerfun main(args: Array&lt;String&gt;) &#123; print(&quot;hello world&quot;) val list : List&lt;String&gt; = listOf(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;) // 遍历 for(str in list) &#123; println(str) &#125; println(&quot;--------------------&quot;) list.forEach (Consumer &#123;println(it)&#125;) println(&quot;--------------------&quot;) list.forEach(System.out::println)&#125; 可以看到引入的是java中的包；对consumer的用法和java8也几乎是一模一样。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Netty 对 WebSocket的简单实现与剖析]]></title>
      <url>%2F2017%2F06%2F07%2FNetty-%E5%AF%B9-WebSocket%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%89%96%E6%9E%90%2F</url>
      <content type="text"><![CDATA[本文主要描述 netty 对 WebSocket 的支持。并编写一个简单 demo; 对 WebSocket 的内容做了简单剖析。 通过文章会了解为何 WebSocket 是 HTTP 协议升级而来； netty 是如何实现对他的支持等。 WebSocket 的由来HTTP 协议的问题HTTP 协议无状态，为了保持状态，引出了 session &amp; cookies等技术。 HTTP 是基于 请求 和 响应 的，请求一定是客户端发出的。（1.1 还有 keepAlive, 持续连接，在一定时间可以进行连接的复用。） 导致的问题， 服务器无法推送数据。所以早期有客户端轮训技术。会导致资源和网络带宽的浪费。因为 Header 数据每次都要构建。 WebSocket 可以做到什么？WebSocket 来自 Html5; 所以是 HTTP 协议的一个升级版本 协议可以建立浏览器和服务器之间的长连接。 可以实现服务端的push 只需要在一开始建立连接的时候构建 Header；其他时间都不需要再有 Header 信息 因为是基于 HTTP 的，所以建立连接的时候，发的请求是一个标准的 http 请求。只不过是在 Header 中添加了信息。 虽然是基于 Http 的，但是不仅仅在 浏览器上使用也可以通过第三方的工具包在 app 端使用 netty 对 webSocket 的简单实现netty 功能众多，可以实现对 HTTP 的支持，可以实现高性能异步 RPC 的功能。同样，他也支持对 WebSocket 的支持。 虽然用过 netty 的人都说 netty 复杂，但是他无论简单和复杂的应用，写起来都是样的复杂，这样一来平均一下，只要你了解了规则，还是比较简单的2333 netty 实现 websocket 服务端三个步骤 Server Initializer Handler Server因为你无论写什么 Server 都基本是这个套路：贴代码 12345678910111213141516171819202122232425/** * 这个示例主要用来阐述 * netty 对于 WebSocket 连接的支持 * 以及如何写一个简单的WebSocket demo */public class WebSocketServer &#123; public static void main(String[] args) throws Exception &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new WebSocketChannelInitializer()); ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(8899)).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 这里简单解释下为什么有连个 group; 其实一个也没有问题。如果你才会用两个 group；那么 bossGroup 负责接收请求；而 workerGroup 负责处理请求 Initializernetty 的各种复杂功能都是由各个 handler 实现的，实现 WebSocket 也是如此。没啥好说的，贴代码，看注释。 12345678910111213141516171819202122public class WebSocketChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); // 因为是基于HTTP 协议之上的，所以需要使用到 HTTP 的编解码技术 pipeline.addLast(new HttpServerCodec()); // 按照块来写数据 handler pipeline.addLast(new ChunkedWriteHandler()); // http request 和 response 的一个聚合类 // netty 会对http 请求做分段的处理；所以在第一个 http 的示例中，有些会调用多次 pipeline.addLast(new HttpObjectAggregator(8192)); // web socket netty 的特殊支持 // 其中 "ws" 是指的是 websocket 协议路径 // 通常形式 ws://localhost:8899/ws // 8899/ws 后面的 ws 就是我传入的 /ws 路径。 pipeline.addLast(new WebSocketServerProtocolHandler("/ws")); // 插入自定义的 TextWebSocketFrameHandler pipeline.addLast(new TextWebSocketFrameHandler()); &#125;&#125; TextWebSocketFrameHandlerWebSocket 协议的传输是是以 Frame 作为单位的。这里我们处理的是 Text 这种类型的 Frame。传统，贴代码： 12345678910111213141516171819202122232425public class TextWebSocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception &#123; System.out.println("接受到消息：" + msg.text()); // 这里我们接受客户端传来的消息，返回我们当前时间 ctx.writeAndFlush(new TextWebSocketFrame("服务器时间：" + LocalTime.now())); &#125; @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; System.out.println("连接建立 : " + ctx.channel().id().asLongText()); &#125; @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123; System.out.println("连接断开 : " + ctx.channel().id().asLongText()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println("出异常"); ctx.close(); cause.printStackTrace(); &#125;&#125; Frame 一共有六种，我们可以从类的继承上看六种分别有不同的用途，从字面上都比较容易理解至于为什么是六种？ 那是因为 WebSocket 协议就是这么规定的。 简单的网页客户端为了方便，我们就只用简单的 JS 来进行 WebSocket 的调用 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script type="text/javascript"&gt; var socket; // 判断浏览器是不是支持 if(window.WebSocket) &#123; socket = new WebSocket("ws://localhost:8899/ws") socket.onmessage = function (event) &#123; var ta = document.getElementById("responseText"); ta.value = ta.value + "\n" + event.data &#125; socket.onopen = function (event) &#123; var ta = document.getElementById("responseText"); ta.value = "连接开启" &#125; socket.onclose = function (event) &#123; var ta = document.getElementById("responseText"); ta.value = "连接关闭" &#125; &#125; else &#123; alert("浏览器不支持 WebSocket") &#125; // 发送消息 function send(message) &#123; if(!window.WebSocket) &#123; return; &#125; if(socket.readyState == WebSocket.OPEN) &#123; socket.send(message) &#125; else &#123; alert("连接尚未开启") &#125; &#125;&lt;/script&gt;&lt;form onsubmit="return false;"&gt; &lt;textarea name="message" style="width: 400px; height: 200px"&gt;&lt;/textarea&gt; &lt;input type="button" value="发送数据" onclick="send(this.form.message.value)"/&gt; &lt;h3&gt;服务端输出：&lt;/h3&gt; &lt;textarea id="responseText" style="width: 400px; height: 200px"&gt;&lt;/textarea&gt; &lt;input type="button" value="清空数据" onclick="javascript: document.getElementById('responseText').value=''"/&gt;&lt;/form&gt; 测试 启动服务器： 启动客户端 简单的做发你可以在 IntelliJ 中直接运行 html 他会帮你起一个服务。或者你可以用 Python 1python -m SimpleHTTPServer 8080 我采用第一种： 客户端显示连接已经建立 此时，你可以在服务器端看到我们要打出的信息 然后你可以通过客户端给服务器发送消息：比如我发送 敏哥好帅还用你所？ 服务端会收到： 客户端也会收到服务端的时间： 至此，我们可以的这个例子就成功运行了，你停止服务器会看到客户端输出 连接关闭； 你关闭客户端，会看见服务端输出 连接断开。 更近一步，基于 frame ? 基于 http ?基于 frame 的信息传递刚刚说到，WebSocket 在建立长连接后，不需要在传递头信息。我们可以代开 Chrome 的控制台看一下： 我们能看到的是 ws 的连接的信息里有个 Frames 的标签，你传输的信息都在这里。 WebSocket 连接是基于 HTTP 升级的？我们可以刷新一下你的客户端的网页，观察下 network 的输出： 注意看出了 js 之外的连个请求：第一个就是基本的 http 请求，状态的 304 重点在看一下下面的 ws , 他是一个 WebSocket 请求： request 中还有一个1Upgrade:websocket 的内容，就是它将协议由 http 协议升级成为了 websocket 协议。所以就是这么回事 所以，websocket 需要浏览器的支持。 环境 jdk8 netty 4.1.10.Final gradle]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[老妈的生活哲学]]></title>
      <url>%2F2017%2F05%2F07%2F%E6%9C%B1%E8%80%81%E5%B8%88%E4%B8%8E%E8%80%81%E5%A6%88%E7%9A%84%E7%94%9F%E6%B4%BB%E7%BB%86%E8%8A%82%2F</url>
      <content type="text"><![CDATA[最近家里人感冒的多，姐姐的双胞胎，小的那个被我们带到舅舅家。 中午，我去我妈那里; 我：老妈，今晚舅妈有事儿，我带小宝贝，你给我送点饭。 老妈：你中午剩的饭你热热就好啦。 我 ： 。。。那我叫外卖。。 老妈 ： 那我也去吃 😌 – The End –]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux 上搭建 Anaconda, 远程访问 juypter]]></title>
      <url>%2F2017%2F05%2F05%2FLinux-%E4%B8%8A%E6%90%AD%E5%BB%BA-Anaconda-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE-juypter%2F</url>
      <content type="text"><![CDATA[1 什么是 AnacondaAnaconda 能让你轻松安装在数据科学工作中经常使用的包。你还将使用它创建虚拟环境，以便更轻松地处理多个项目。Anaconda 简化了我的工作流程，并且解决了我在处理包和多个 Python 版本时遇到的大量问题。 Anaconda 实际上是一个软件发行版，它附带了 conda、Python 和 150 多个科学包及其依赖项。应用程序 conda 是包和环境管理器。Anaconda 的下载文件比较大（约 500 MB），因为它附带了 Python 中最常用的数据科学包。如果只需要某些包，或者需要节省带宽或存储空间，也可以使用 Miniconda 这个较小的发行版（仅包含 conda 和 Python）。你仍可以使用 conda 来安装任何可用的包，它只是没有附带这些包而已。 除了管理包之外，conda 还是虚拟环境管理器。它类似于另外两个很流行的环境管理器，即 virtualenv 和 pyenv 环境能让你分隔你要用于不同项目的包。你常常要使用依赖于某个库的不同版本的代码。例如，你的代码可能使用了 Numpy 中的新功能，或者使用了已删除的旧功能。实际上，不可能同时安装两个 Numpy 版本。你要做的应该是，为每个 Numpy 版本创建一个环境，然后在适用于项目的环境中工作。 在应对 Python 2 和 Python 3 时，此问题也会常常发生。你可能会使用在 Python 3 中不能运行的旧代码，以及在 Python 2 中不能运行的新代码。同时安装两个版本可能会造成许多混乱和错误。而创建独立的环境会好很多。 也可以将环境中的包的列表导出为文件，然后将该文件与代码包括在一起。这能让其他人轻松加载代码的所有依赖项。pip 提供了类似的功能，即 1pip freeze &gt; requirements.txt。 2 为什么使用 conda 而不是 virtualenv? 3 安装过程1 下载 ，上传到机器你也可以在机器 wget 1https://repo.continuum.io/archive/Anaconda2-4.3.1-Linux-x86_64.sh 2 安装1sh Anaconda2-4.3.1-Linux-x86_64.sh 选择安装目录。为了节约 根目录空间，安装在 12# 目录事先必须不存在/data/min.zhu/anaconda2 下面 source 一下 .bashrc 1source ~/.bashrc 3 设置国内Anaconda源1234# 添加Anaconda的TUNA镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/# TUNA的help中镜像地址加有引号，需要去掉# 设置搜索时显示通道地址conda config --set show_channel_urls yes 4 安装需要的环境比如安装 3.5 的python 1conda create -n lr3 python=3.5 激活 1source activate lr3 之后进入虚拟环境 可以在通过 conda 进行包的管理 1conda install xxx 5 修改 pip 源为阿里源因为有些包点评直接就没有 比如 tflearn 和 tensorflow 123vim ~/.pip/pip.conftrusted-host=mirrors.aliyun.comindex-url=http://mirrors.aliyun.com/pypi/simple/ 6 远程juypter 访问首先，不建议使用root , 当你使用 root 的时候，需要使用如下方法。 1jupyter notebook --allow-root 第二，远程服务器访问需要做一些配置 可以参考如下文章 1http://blog.leanote.com/post/jevonswang/远程访问jupyter-notebook 进行配置 4 管理环境如果你安装了多个环境，但是不记得名字，或者想修改的话，通过 conda-env 这个命令就可以看到你所有的环境了。 可以看到附带所有操作 比如 conda-env list 就是查看所有命令的格式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS 6.x 如何升级 glibc 2.17]]></title>
      <url>%2F2017%2F05%2F05%2FCentOS-6-x-%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7-glibc-2-17%2F</url>
      <content type="text"><![CDATA[引子本文描述如何在 CentOS 6.x 升级蛋疼的 glibc 2.17. 学习机器的内容，需要用到 tensorFlow, 在自己 Mac 上跑太心疼了。 于是尝试在公司的测试机上跑。然而我搭建好 conda, jupyter notebook , 引入 tf 的时候报错。（关于如何 安装科学计算环境，以及远程访问 jupyter notebook, 请看下一篇文章） 如下 在一看机器上的情况 最高只有 2.15 其实已经是运维升级过了的，默认只到 12。主要还是我们的系统版本太低。 CentOS 7.X，GLIBC 已经到 2.17，GCC 也是 4.8.5但是对于公司来说，稳定是第一位的。所以。。。 如何安装两种方法，一种源码编译，一种是用 rpm 来安装，之前看到这篇文章点这里，其实说的还蛮好的，但是只是升级到 2.15， 而最新的 tf 1.1 版本，需要 2.17 的版本。 其实问题最大的就是找不到给 CentOS 6.x 用的 2.17 的 rpm 包，直到今日，我搜到了有人昨天发布一段脚本，才算找到了解决方法，直接给链接 感激万分的点这里 你不愿点看，我就写下来： 12345678910111213#! /bin/sh# update glibc to 2.17 for CentOS 6wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpmwget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpmwget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpmwget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpmsudo rpm -Uvh glibc-2.17-55.el6.x86_64.rpm \glibc-common-2.17-55.el6.x86_64.rpm \glibc-devel-2.17-55.el6.x86_64.rpm \glibc-headers-2.17-55.el6.x86_64.rpm 其实就是下载资源，然后用 rpm 安装。 可能遇到的错误当你执行 1234rpm -Uvh glibc-2.17-55.el6.x86_64.rpm \ glibc-common-2.17-55.el6.x86_64.rpm \ glibc-devel-2.17-55.el6.x86_64.rpm \ glibc-headers-2.17-55.el6.x86_64.rpm 的时候会报错 解决方案：命令结尾加上参数 1--force --nodeps 原因可以看这篇文章 点这里，造成这个问题的主要原因是套件被重複 (强制) 安装了两次以上. 可以用上面的命令进行依赖忽略，也可以卸载。 总结 搜索的关键词真的很重要，谷歌很重要，英语很重要。 运气很重要(这个问题折腾我两个礼拜) 别用百度搜技术问题。 还有，如果你手动编译安装glibc。。。。万一你安装失败就会导致系统各种命令无法执行。。千万别退出。。你一旦退出，就无法登陆了，只能用光盘恢复系统了。。 但是这篇文章里的方法，可以试一试 解决方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8 一个颠覆了面向对象认知的例子]]></title>
      <url>%2F2017%2F05%2F03%2Fjdk8-%E4%B8%80%E4%B8%AA%E9%A2%A0%E8%A6%86%E4%BA%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%A4%E7%9F%A5%E7%9A%84%E4%BE%8B%E5%AD%90%2F</url>
      <content type="text"><![CDATA[1 起源如果你看了上一篇文章关于 Spliterator 分割迭代器，最后一部分说到了图中的两个强制转换逻辑的不合理之处。 第一处，我传入的是一个 Consumer 接口，但是判断的情况却是判断 1action instanceof IntConsumer 而 IntConsumer 和 Consumer 是没有继承关系的平行函数式接口。这样的转换为何会成功？ 第二处，当第一个判断条件不满足的是时候，使用（IntConsumer）强转 lambda 表达式，这样为何能成功被需要传入 IntConsumer 函数所接受呢？ 如下图： 2 尝试解释看看喽先看第二处：lambda表达式也可以强转？我们先写一个类似的例子，有一个需要传入 Consumer 的方法，我们尝试传入一个 IntConsumer 会发生什么情况。 1234567891011121314151617public class ConsumerTest &#123; public void test(Consumer&lt;? super Integer&gt; consumer) &#123; System.out.println(consumer instanceof IntConsumer); consumer.accept(100); &#125; public static void main(String[] args) &#123; ConsumerTest consumerTest = new ConsumerTest(); Consumer&lt;Integer&gt; consumer = i -&gt; System.out.println(i); IntConsumer intConsumer = i -&gt; System.out.println(i); consumerTest.test(consumer); // 面向对象的方式 consumerTest.test(consumer::accept); // 函数式的方式 consumerTest.test(intConsumer::accept); // 函数式的方式 &#125;&#125; 这个例子的输出结果是： 我们发现这三种传入方式都是可以的，第一第二种没什么好说的，因为 Test 方法就是需要传入一个 Consumer， 无论你使用原来传递对象的方式，还是通过方法引用的方法，都是没有问题，可以被执行。 问题在于，第三种方式 1consumerTest.test(intConsumer::accept); // 函数式的方式 当你按住 command 把鼠标放在双冒号的时候 出现的如下： 当你按住 command 把鼠标放在的 accept 时候 出现的如下： 双冒号代表是的当前 lambda 表达式的类型。因为你看我初始化两个consumer的代码 12Consumer&lt;Integer&gt; consumer = i -&gt; System.out.println(i);IntConsumer intConsumer = i -&gt; System.out.println(i); 我后面的表达式是一模一样的。但是却可以赋予两个不同的类型。所以，重点来了 重点是 lambda 表达式的类型，是要靠上下文进行推断的。 这个是和传统面向的编程不一样的地方。需要注意。刚刚上面的第三种调用的方式，就是如此，编译器推断出，你这个 lambda 表达式 intConsumer::accept 肯定是 Consumer&lt;T super Integer&gt; 类型的。所以不报错而这个时候如果你前面加一个强制转换，就像文章一开始的那张图的第二个强转逻辑一样，也是可以的。不过，略显多余就是了。 在看第一处那么什么情况下，才会出现第一种情况，传入的是 Consumer ，但却同时是 instanceof IntConsumer 呢？ 对了！（对什么对，你又没想到）就是这样，你同时继承者两个接口就可以了呀！ 上代码！ 123456789101112131415161718192021222324252627282930313233343536/** * Created by charleszhu on 2017/5/2. */public class ConsumerTest &#123; // 要求传入 Consumer public void testInt(Consumer&lt;Integer&gt; consumer) &#123; // 判断是否为 IntConsumer System.out.println(consumer instanceof IntConsumer); consumer.accept(100); &#125; public static void main(String[] args) &#123; ConsumerTest consumerTest = new ConsumerTest(); consumerTest.testInt(new MyConsumer2&lt;&gt;()); &#125;&#125;/** * 同时实现两个方法 * @param &lt;Integer&gt; */class MyConsumer2&lt;Integer&gt; implements IntConsumer, Consumer&lt;Integer&gt; &#123; public void accept(int value) &#123; System.out.println(value); &#125; public void accept(Integer t) &#123; System.out.println(t); &#125;&#125; 运行一下结果： 就可以发现，这个时候就和开头的那个例子中的，第一处转换： 需要传入的是 Consumer, 但是也是 IntConsumer 的实例，就会进入第一个判断了 至此两个强转就解释完毕了！ 总结这个例子想给大家说的就是函数式接口的很传统的命令式编程还是有一定差别的。尤其是 lambda 表达式的类型是要靠上下文推断的这一点，需要好好的理解~ 只有慢慢理解这些，才能真正理解函数式编程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8 Stream 解析2 - Spliterator分割迭代器]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk8-Stream-%E8%A7%A3%E6%9E%902-Spliterator%E5%88%86%E5%89%B2%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
      <content type="text"><![CDATA[概述说完Stream 的一些源码解析。我们看下我们的 Stream 是如何产生的。我们最为常见的流的产生方式是 collection.stream(), 你点开Stream()方法, 他是通过 Collection 这个上层接口两个java8 新增特性 default method 进行实现。 这就牵扯到一个关键要点 Spliterator ：分割迭代器。 本文主要描述 Spliterator 的作用，大部分来源于你不愿意读的 JavaDoc。 Spliterator 是 jdk8 非常重要的概念。里面的细节很值得学习玩味。 Spliterator 冗长的JavaDoc 说了什么？基本介绍Spliterator 是一个对源（数组，集合，io流等等）中元素进行遍历和分区的类。 可以通过 tryAdvance() 方法逐个遍历，也可以按照 forEachRemaining() 方法进行按 bulk 逐块的遍历。（内部调用的还是tryAdvance） Spliterator 有类似 Collector 中的 characteristics , 但都是由十六进制来表示的。 SIZED :表示大小固定, Collection常用 DISTINCT : 去重, Set常用 SORTED : 有顺序的 SortedSet 会用等等 原生类型的特化版本特化分割迭代器也被提供，和Stream类似。减少装箱和拆箱的操作 比迭代器Iterator 更加高效的遍历元素的方式提供更加高效的方法，进行数据的迭代。Iterator 的使用需要调用两个组合方法 hasNext() 以及 next() ，同事在多线程访问的情况下还会出现竞争，你需要去同步。而分割迭代器 Spliterator 使用函数式编程的方式，只用一个方法就可以做到这个两个函数动作。就避免了竞争 ，就是 tryAdvance() 方法。后面会介绍 Spliterator的接口方法tryAdvance()同时做了 hasNext() 以及 next() 的工作。 1234/*** 对给定的元素进行判断，如果满足条件就会执行 Action*/boolean tryAdvance(Consumer&lt;? super T&gt; action); forEachRemaining()是一个默认方法，对余下的元素进行操作，直到元素全部被遍历完一般情况下回直接调用上面的tryAdvance() 方法，但是也可以更具需要进行重写。1234567/*** 对余下的元素进行操作，直到元素全部被遍历完* 如果源是有序的，遍历也是有序的*/default void forEachRemaining(Consumer&lt;? super T&gt; action) &#123; do &#123; &#125; while (tryAdvance(action));&#125; 这里有一点很值得注意，方法体中的 do {} 是空的，这个是因为 tryAdvance() 方法本身就完成了两个操作 hasNext() 以及 next()，所以方法体中不需要有任何操作了。这个是 函数式编程带来的好处。以及与命令式编程的区别。 trySplit()尝试切分源来的 Spliterator， 返回的是（注意！！！）返回的是 分割出来的那一部分 数据，原有的数据集将不在包含这部分数据集合。两者 没有交集。剩下的可以继续分割，也许不可以继续分割了 举个例子，我原来有 100个元素，我通过 trySplit 切分出 30 个，作为一个新的 分割迭代器 返回，原有的，就还剩下 70 个。 如果是原有数据集合是 ORDERD 的，分出来的也是有序的。 除非元素数量是无穷的，否则，最后一定会出现不能在分割的情况，这种情况下，返回的结果是 null 1Spliterator&lt;T&gt; trySplit(); estimateSize()估算集合剩余给forEachRemaining大小，不一定精确。但是如果这个 Spliterator 是 SIZED，没有被遍历或者 split， 或是 SUBSIZED的，没有被遍历，那么他这个值一定是准确的。 1long estimateSize(); 还有个与之相关的默认方法，就是利用这个特性。123default long getExactSizeIfKnown() &#123; return (characteristics() &amp; SIZED) == 0 ? -1L : estimateSize(); &#125; characteristics()表示集合的特性，一共8个。 分割之前，返回的结果都是一致的 如果返回结果不一致，则操作是不受保证的 而分割之后，不保证一致 有一个默认方法用于判断 Spliterator 是否包含这个特性123default boolean hasCharacteristics(int characteristics) &#123; return (characteristics() &amp; characteristics) == characteristics; &#125; getComparator如果源是SORTED 类型的，且有比较器 Comparator 的话，则返回这个 Comparator，如果是SORTED 类型的，但是没有比较器，则返回 null , 除此之外，都抛出异常 接口的默认方法里，就是抛出了异常 123default Comparator&lt;? super T&gt; getComparator() &#123; throw new IllegalStateException(); &#125; Spliterator的8个Characteristics 特性ORDERED源的元素有序，tryAdvance ，forEachRemaining和 trySplit 都会保证有序的进行元素的处理 需要注意 hashSet 这类 Collection 是不保证有序的 有ORDERED 特性的数据，在并发计算的时候客户端也要做顺序限制的保证 DISTINCT太简单，唯一性。 类似 Set 这样的传入集合会拥有这样的特性 SORTED有这种特性的 Spliterator ，有一个特定的顺序。或者是所有元素都是可比较的，或者是有特定的比较器。 有 SORTED 一定会有 ORDERED SIZED有这种属性的 Spliterator 在遍历和分割之前，estimateSize() 返回的大小是固定的，并且是准确的。 NONNULL不为 NULL, 大部分并发的集合，队列，Map 都可能会有这样的特性。 IMMUTABLE不可变的。元素遍历期间不可以被 添加，替换，删除（cannot be added, replaced, or removed）否则，应该抛出异常。 CONCURRENT支持并发操作的。 顶层的 Spliterator 不可以 CONCURRENT 与 SIZED。 这两者是相互冲突的。 但是分割之后的 Spliterator ， 可能是 SIZED， 顶层不能决定底层 SUBSIZED从trySplit()被分割后的所有分割迭代器都是 SIZED 以及 SUBSIZED 的。如果分割后，没有按照要求返回SIZED 以及 SUBSIZED 属性，那么操作是不被保证的，也就是结果不可预测。 这个属性和 SIZED 的区别就是， SIZED 不保证 SUBSIZED。而 SUBSIZED 会要求保证 SIZED 内部特化而做的函数式接口 (OfPrimitive)除了上面的函数，以及特性，Spliterator 迭代器中，还有几个定义在内部的接口。 OfPrimitive 重载了（overloads）了 Spliterator 的方法。用于实现特化的分割迭代器。 overloads：返回类型名称一致，参数不一致。注意与 override 的区别 一个颠覆面向对象编程常识的现象请大家看图 这两次类型转换奇怪的地方是： IntConsumer 与 Consumer 两个接口，没有继承关系，两个接口是平行的。 这样的转换，在之前是不可能成功的。 简直是颠覆认知啊！ 我悄悄说啊（并没有。。你也基本不会关心不是么。。） 但是在函数式编程中能转换成功呢？ 你可以等我下一篇文章~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8 Stream & BaseStream 源码难点浅析1]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk8-Stream-BaseStream-%E6%BA%90%E7%A0%81%E9%9A%BE%E7%82%B9%E6%B5%85%E6%9E%901%2F</url>
      <content type="text"><![CDATA[概述 简要介绍 Stream 的 javadoc，与集合的关系以及区别，一些重要的注意事项 难懂的 Stream 类的声明，介绍比较难懂的 onClose() 方法的调用 Stream的javadocStream 的作用与特化版本Stream 是对一个序列做 串行 或者 并行 聚合操作。他继承自 StreamStream 同时还有几个特化的版本 ，IntStream , LongStream, DoubleStream. 他们为了减少流操作的时候一些不必要的装箱和拆箱的操作。 需要注意的是，以上四个 Stream 是平行关系，他们都是继承自 BaseStream 举个简单的例子： 12345678910/*** 将集合 widgets 中的元素中红色的元素的重量求和* 第一步 filter() 过滤红色* 第二步 mapToInt() 拿出所有的Red的重量，生成一个 IntStream* 第三步 sum() 求和，并返回*/int sum = widgets.stream() .filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum(); Stream 的组成与特点要想实现计算，所有操作，都会被放入一个 pipeline 当中（类似liunx）中的操作。 而一个流管道（pipeline）包含： source(源)： 数组，集合，迭代器，I/O 操作等等 0个或者多个中间操作： 将一个流转成另外一个流 1个终止操作 : 产生一个结果(比如上面的例子中的求和) or 或者修改传入对象的属性。 流是Lazy的懒惰的！！ 你不加 终止操作 流的操作，就不会被执行。如上面的例子，没有最后的 Sum() 函数，前面的操作是不会被执行的。 集合和Stream 的区别集合： 注重存储，主要考虑元素的访问与管理Stream ：注重计算，主要考虑以一种描述性 的语言来对源进行一系列的操作，并将操作聚合起来。 流的注意事项1 流中的操作，都应是函数式接口（lambda表达式或者方法引用）2 流不能被重用，每个流只能应用一次。想再次操作你需要重新生成一个流 3 流虽然实现了 AutoCloseable 接口，但是几乎所有的流都是不用关闭的，因为他的源大部分情况下都是集合，而集合是不用关闭的。 除非源是一个 I/O Channel。 比如 Files.lines() 方法。如果是这样，Stream 就可以申明在 try-with-resources block 中。关于这个 j7 新接口的使用，可以看我之前的一篇关于 AutoCloseable 的介绍 jdk1.7新增自动关闭接口AutoCloseable 多说一句，Files.lines() 是 j8 中新增的方法，有点类似 python 中 readlines() 方法。很好用。 Stream &amp; BaseStream 解析看不懂的声明我们可以看一下 Stream 以及 BaseStream 的类的声明 1234//Streampublic interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; //BaseStreampublic interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; BaseStream 中，第二个泛型是 S extends BaseStream&lt;T, S&gt; ，而 Stream 中，第二个泛型是 Stream&lt;T&gt;， 正好是满足 extends BaseStream&lt;T, S&gt; 的条件的，所以可以这么写。 两个泛型有没有感觉有点晕。其实比较好理解。 T 这个泛型很好理解，就是流中元素的类型 S ？ 如果你看过javadoc的描述，流的所有中间操作，都会返回一个流，而这个S 就代表着中间操作返回的流的类型。比如我们看一下这个在 Stream 中的方法（其他方法与其一致） 难懂的 onClose() 方法上面我们知道 BaseStream 实现了 AutoCloseable 接口，也就是 Close() 方法可以得到调用。但是 BaseStream 中，给我们提供了要给OnClose() 方法。我们看下截图 这个方法，就是当 Close() 方法被调用的时候 onClose()会被调用。但是有几个注意的点 onColse() 方法也返回一个流，也就是说可以多次调用。 如果你写了多个onClose() 方法，它会按照顺序调用。 前一个 onClose() 方法除了异常不影响后续 onClose 方法的使用 如果多个 onClose() 方法都抛出异常，只展示第一个异常的堆栈，而其他异常会被压缩，只展示部分信息 上代码！！！！！！ 12345678910111213141516171819202122232425/** * Created by charleszhu on 2017/5/2. */public class StreamTestOnCloseTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; testString = Arrays.asList(&quot;min&quot;, &quot;ge&quot;, &quot;da&quot;, &quot;shuaibi&quot;); /** * 两次关闭 * 两次异常 * 预期：两次关闭输出依次打出；两次关闭异常只打印一次堆栈，另外一次只展示 */ try(Stream&lt;String&gt; stream = testString.stream()) &#123; stream.onClose(() -&gt;&#123; System.out.println(&quot;closing 1&quot;); // throw new NullPointerException(&quot;exception 1&quot;); &#125;).onClose(() -&gt; &#123; System.out.println(&quot;closing 2&quot;); throw new NullPointerException(&quot;exception 2&quot;); &#125;).forEach(System.out::println); &#125; &#125;&#125; 结果如下图： 你们明白了吧（我是天才） 好懂的其他方法BaseStream 中有的一些其他方法，除了分割迭代器(后面会单独说，因为太重要) 1Spliterator&lt;T&gt; spliterator(); 其他都比较好懂。值得一说的是以下两个方法： 12S sequential(); // 返回串行流S parallel(); // 返回并行流 你可以看到他们都返回流对象，也就是可以继续调用 sequential 或者 parallel 方法。但是！！！ 无论你中间怎么调用 ，比如 sequential.parallel.parallel.sequential…. 只以最后一个为最终流的类型！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk1.7新增自动关闭接口AutoCloseable]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk1-7%E6%96%B0%E5%A2%9E%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%8E%A5%E5%8F%A3AutoCloseable%2F</url>
      <content type="text"><![CDATA[1 AutoCloseable 接口这是JDK1.7 的新增语法。帮助你自动关闭一些资源。可能你还不知道这个接口 这个接口好就好在，只有一个方法，名叫 close(), 而这正好有是我们各个资源关闭的方法名，所以使用起来相当方便，因为名称一样，代码兼容。 JDK8 中就在很多地方应用了这个接口，比如 Stream 继承了 BaseStream，而 BaseStream 则继承了 AutoCloseable 这个接口。 这个接口的说明很清楚，当你在使用 try-with-resources block 这种语法调用来进行资源获取的时候，在 block 退出之后自动关闭 try-with-resources block 代码块，就是将资源的声明，放在 try 里面； 可以看后面的代码示例 你不用像之前写 finally{} 代码那样的进行关闭。就不会有资源未被释放的问题。 2 测试代码简单测试代码如下 1234567891011121314151617181920212223/** * Created by charleszhu on 2017/5/2. */public class AutoCloseAbleTest implements AutoCloseable&#123; public void doSth() &#123; System.out.println("doStm"); &#125; @Override public void close() throws Exception &#123; System.out.println("Close() 看到没，我被吊了"); &#125; public static void main(String[] args) throws Exception &#123; /** * try-with-resources 语法块 */ try(AutoCloseAbleTest autoCloseAbleTest = new AutoCloseAbleTest()) &#123; autoCloseAbleTest.doSth(); &#125; &#125;&#125; 运行一下，结果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[老版本MacBookPro (厚的) 格式化, U盘安装 MacOS Sierra]]></title>
      <url>%2F2017%2F05%2F01%2F%E8%80%81%E7%89%88%E6%9C%ACMacBookPro-%E5%8E%9A%E7%9A%84-%E6%A0%BC%E5%BC%8F%E5%8C%96-U%E7%9B%98%E5%AE%89%E8%A3%85-MacOS-Sierra%2F</url>
      <content type="text"><![CDATA[引子主要写的点是：U 盘安装盘的制作，以及，为什么会有 can’t be verified 已损坏，重新下载 这些问题，即使你是从 app store 中下载的完整版本。 前两天，我一个朋友拿了一台很老的 MacBook pro , 说他不小心格式化了硬盘，要我重装系统。。 电脑图如下。。 有点洁癖的我看到了想说说，要不你砸了吧（当然我没说。。）但是碍于面子（毕竟我是程序员，外界都说是搞电脑的，约等于 修电脑的，近似于你是修电脑的，也就是说电脑相关的你全都会，不会就是大傻逼）。。 我当然是很愤怒的，之所以没有发作是因为他是我老师。。 如何制作安装盘准备工作你需要一下物品： 一个只要8G的U盘 一台工作良好的 macbook pro 良好的网络 我（你没戏了） 言归正传： 步骤一 ： 在App Store 中下载最新的 macos连接如下 下载地址她会跳转到 app store. 点击下载即可。它会弹出提示让你更新啥的，不用管它，直接下载 下载好了之后，你在你的 应用程序 文件夹，你就可以看到这个了 至此，你的第一任务完成。 步骤二 ：用磁盘工具格式化你的U盘打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致。) 如果不成功，你就多试几次 步骤三 ： 制作安装盘打开你的终端，输入如下命令1sudo /Applications/Install\ macOS\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\ macOS\ Sierra.app --nointeraction 注意空格前面需要有 \ 进行转义 耐心得到 done, 你就可以拿着 U 盘去安装了 无法验证？or 已经损坏？重装的步骤简单，插入u盘，开机按住 option, 选择u 盘的安装盘。接下来选择安装就可以了。 但是，大部分情况下，都会遇到类似 This copy of the Install OS X El Capitan application can’t be verified. It may have been corrupted or tampered with during downloading 或者，直接告诉你损坏了，让你再去下载完整版本。 导致这个的原因是，当你决定将一台mac格式化后，在重装系统的时候，系统的时间已经被改变了。这个时候安装程序就会爆出各种错误。你可以通过 终端输入 date 进行查看，时间应该变成了 2001 年。 这个时候， 你只要通过 date 命令重置时间，就可以解决这个问题。他的参数如下 123456date MMDDHHmmYY replacing the letters as follows.MM - 2 digit month 01 - 12DD - 2 digit date 01 - 31HH - 2 digit hour 01 - 24mm - 2 digit minute 01 - 59YY - 2 digit year &gt; 15 你将时间设置成，你要安装的系统发布之后的一个时间后，退出终端，再次点击操作，就不会有问题。 你也可以看做这个视频 土逼视频 ，需要翻墙。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-32-groupingBy 源码分析]]></title>
      <url>%2F2017%2F04%2F30%2Fjdk8-32-groupingBy-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[jdk8 集合的工厂类 Collectors 提供了两个很好用的静态函数。 groupingBy partitioningBy groupingBy 实现类似 Mysql 中分分组功能。返回一个 Map; 而 partitioningBy可以看做是 groupingBy 的特殊形式。我们后面会接着介绍。 使用的是比如统计每个城市人的“姓”，可以这么写 1Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); 那么，他到底如何利用 Collector 的各个接口来实现的呢？下面我们将深入 JDK 的 Collectors 的源码中，分析一下他是如何工作的。 groupingBy1 第一个重载方法, 要简单就别那么多要求，给你个List不错了分组 groupingBy 有三个重载方法。一个比一复杂。 先看最简单的 12345678/** * @param &lt;T&gt; the type of the input elements * @param &lt;K&gt; the type of the keys*/public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier) &#123; return groupingBy(classifier, toList()); &#125; 这里 T 是输入集合的元素类型， K 是最后产生的 Map 的主键key 的类型。 函数需要传入一个 Function 的函数式接口，Function 的中作就是分类器，比如传入的类型是T 是一个 Person类型 ， 通过 apply() 方法，返回 Person 的属性 name；因为我们要按照 name 来分组。 所以，如果 name 的类型是 String ； 那么 K 就是 String 故而，这个 groupingBy(function) 的功能就很清晰了，就是通过 function 对传入的 T 类型进行分类。然后调用 toList() 方法，也就是说每个分类的Person 会放进一个 List&lt;Person&gt; 中 最终返回的类型就是 Map&lt;String, List&lt;Person&gt;&gt;. 而如果你不想返回的是一个List , 希望是一个 Set. 你就要使用第二个重载方法~ 他允许你定义最后的输出函数。 2 第二个重载方法：我要输出Set看一下函数的定义： 12345678910111213/** * @param &lt;T&gt; the type of the input elements * @param &lt;K&gt; the type of the keys * @param &lt;A&gt; the intermediate accumulation type of the downstream collector * @param &lt;D&gt; the result type of the downstream reduction * @param classifier a classifier function mapping input elements to keys * @param downstream a &#123;@code Collector&#125; implementing the downstream reduction*/public static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream) &#123; return groupingBy(classifier, HashMap::new, downstream); &#125; 这个函数，明显比上一个要复杂，可以看到，多了一个 Collector 的 downstream , 可以自定义输出的集合。上面那个简单版本的函数是是写死的 List 这个函数有四个泛型。 T 原始元素类型，比如我们这是 Person K 返回 Map 的 key, 即最终返回的Map 的建的类型。如果你想按照人的名字分类，那T就是 String, 如果按照年龄分类，那就是 Interger A 是 downstream 的 accumulation 的中间结果类型 D 是最终输出 Map 的 Value 的类型。比如 List 或者 Set 这个方法会调用第三个重载函数，比第二个函数，多了中间的 HashMap::new； 这个是最终返回的 Map 的类型，这里写死的是 HashMap, 如果你想用其他类型，就需要使用最终的也是最复杂的第三个重载函数。 越是你用起来简单的函数，背后的实现就越来越复杂。 3 第三个重载方法: 能看懂就随便你怎么玩12345678910111213141516171819202122232425262728293031323334353637383940414243/*** @param &lt;T&gt; the type of the input elements* @param &lt;K&gt; the type of the keys* @param &lt;A&gt; the intermediate accumulation type of the downstream collector* @param &lt;D&gt; the result type of the downstream reduction* @param &lt;M&gt; the type of the resulting &#123;@code Map&#125;* @param classifier a classifier function mapping input elements to keys* @param downstream a &#123;@code Collector&#125; implementing the downstream reduction* @param mapFactory a function which, when called, produces a new empty* &#123;@code Map&#125; of the desired type*/ public static &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream) &#123; Supplier&lt;A&gt; downstreamSupplier = downstream.supplier(); BiConsumer&lt;A, ? super T&gt; downstreamAccumulator = downstream.accumulator(); BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123; K key = Objects.requireNonNull(classifier.apply(t), "element cannot be mapped to a null key"); A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get()); downstreamAccumulator.accept(container, t); &#125;; BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner()); @SuppressWarnings("unchecked") Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory; if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123; return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID); &#125; else &#123; @SuppressWarnings("unchecked") Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher(); Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123; intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v)); @SuppressWarnings("unchecked") M castResult = (M) intermediate; return castResult; &#125;; return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID); &#125; &#125; 这个函数有5个泛型，除去上面说的 T，K，A，D多了一个 mapFactory 的 Supplier() , 用于得到最终返回的 Map 的类型，第二个重载函数写死的 HashMap，这就可以进行自定义。 这个函数有连个值得注意的点： 所有的Collectors 中函数，如果函数内部还要做集合处理的，都是使用 downstream 这种模式，利用 downstream 的各种已有的的 Supplier Accumulator等，修改来实现自己的功能。比如在 groupingBy 这个函数，一开始就获取了 downstream 的各个组件，组合成自己需要的收集器，进而用于完成分类的行为。（你还可以去看一看 collectingAndThen() 这个函数） groupingBy 函数中有有两处强制类型转换。这里其实很难理解，为何可以直接成功的转换呢？ 第一处 第二处 两处其实都是将最终结果泛型 D 转成 中间结果 A。对于第一处， mapFactory 是作为一个 Supplier 出现，而他的目的是提供中间结果类型，而他上面的 accumulator 的中间结果类型，就是K,A， 所以这样的强转是一定可以成功的 第二处也是一样的，因为全称都使用了 A，其实 A 和 D 在这里，是等价的。所以转换都可以成功。 你去可以从这么一个角度思考问题： 你最终需要生成 D 类型，为何中间要给自己生成一个不一样的 A 类型添堵呢？ 你 4 不 4 sa？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-31-工厂方法收集器Collectors的中的常用函数]]></title>
      <url>%2F2017%2F04%2F13%2Fjdk8-31-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86%E5%99%A8Collectors%E7%9A%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[1 collectorImpl Collectors 中的 的基础 collectorImpl 两个构造方法一个有 finisher(), 一个没有。这个很容易理解，一个需要转换中间结果，一个中间结果和最终结果一致，所以不需要使用 finisher() 方法 2 两种实现方式对于工厂类 两种实现方式 CollectorImpl 来实现。 reduceing 来实现， 而 reducing 方法归根还是用的是 CollectorImpl 方法来实现 3 常见函数1） toList() &amp; toCollection 两个最常用的方法 toList() &amp; toCollection toSet() 方法是也是 toCollection 的特化。 2） joining() joining 三种重载方法 3） mapping() mapping() 将输入元素转换成输出元素 1234Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity= people.stream().collect(groupingBy(Person::getCity,mapping(Person::getLastName, toSet()) // Mapping , 将Person 转换成String , 提供给下游 Collector 使用)); 4） collectingAndThen() collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher) 先过完上层收集器 downstream ，在进行一次 finisher() 转换结果 比如说，你在 toList() 之后，想将它转换成一个 immutableList() 就可以如下使用 List&lt;String&gt; people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList)); 实现其实很有意思 5） counting() , minBy() , maxBy() counting() , minBy() , maxBy() 用 reducing() 实现, reducing() 又是基于 CollectorImpl 实现 6） summingInt() , averagingInt() , averagingDouble() summingInt() 对每一个元素使用 toIntFunction 在累加，实现很有意思 Supplier() 采用生成了一个 长度为1 的 int 数组，而不是直接使用的整形数字？因为数字是一个 值， 值是无法传递的，而数组是一个 引用， 引用是可以传递的。 averagingInt() 求平均值 对于averagingDouble() 的实现可以再去看一下，他的初始数组长度为4，他们视为浮点数计算的补偿产生的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-28-30-自定义收集器&坑]]></title>
      <url>%2F2017%2F04%2F12%2Fjdk8-28-30-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%B6%E9%9B%86%E5%99%A8-%E5%9D%91%2F</url>
      <content type="text"><![CDATA[收集器中有很5个抽象方法，每个抽象方法都有自己特殊的作用，如果说我们要自己实现要给收集器的话，我们就需要分别实现下面五个方法。 1 简单自定义一个收集器这个收集器的目的是将一个 list 转换成一个 set 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MySetCollector&lt;T&gt; implements Collector&lt;T, Set&lt;T&gt;, Set&lt;T&gt;&gt; &#123; @Override public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123; System.out.println("supplier invoked!!!"); return HashSet::new; &#125; @Override public BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123; System.out.println("accumulator invoked!!!"); return Set&lt;T&gt;::add; &#125; /** * 并行性流才会调用，将两个分段的集合 * @return */ @Override public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123; System.out.println("combiner invoked!!!"); return (t1, t2) -&gt; &#123; t1.addAll(t2); return t1; &#125;; &#125; @Override public Function&lt;Set&lt;T&gt;, Set&lt;T&gt;&gt; finisher() &#123; System.out.println("finisher invoked!!!"); return Function.identity(); &#125; /** * 描述这个集合的特性 * IDENTITY_FINISH 表示结果容器和中间容器是一致的，这个时候 JDK 会在返回的时候自动帮助我们做类型转换。而不用再去调用 finisher * @return */ @Override public Set&lt;Characteristics&gt; characteristics() &#123; System.out.println("characteristics invoked!!!"); return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH,UNORDERED)); &#125; public static void main(String[] args) &#123; List&lt;String&gt; words = Arrays.asList("hello" , "world", "welcome", "hello"); Set&lt;String&gt; stringSet = words.stream().collect(new MySetCollector&lt;&gt;()); System.out.println(stringSet); &#125;&#125; 实现类里，我们分别实现了5个方法。 其中比较重要的两个方式 finisher 和 characteristics 方法 这俩方法是相互影响的。首先看 characteristics 方法，这个方法要求返回一个 Characteristics 枚举类型对的 Set。而 Characteristics 一共有三个枚举值。分别有不同的含义。 123456789101112131415161718/** * 当我们采用并行流的时候，同时设置了 CONCURRENT 作为这个流的特性 * 那么，操作的是同一个集合，而不是多个 * 同样的道理，我们采用了并行流的方式，但是没有这个特性，我们就会生成多个 * 集合 */ CONCURRENT, /** * 代表集合是否是有序的 */ UNORDERED, /** * 表示 finisher function 可以被省略，因为中间结果和最后的返回的结果的类型是一致的。 * 所以当我们设置了这个属性之后，我们就必须了解到， 最后的返回的类型，可以由中间结果类型进行强制的返回。 */ IDENTITY_FINISH 上面的例子中，我们为我们自己的 collector 设置了两个属性， IDENTITY_FINISH &amp; UNORDERED ; 意思就是这个收集器收集的元素是无序的。 而同时，返回的类型和中间结果类型是可以完全强制转换的（如果不可以，则会报错，下面会说到）；而 finisher() 函数是不会被执行的，即使你在函数内部直接抛出一个异常都没有问题，因为根本不会执行。执行结果我们可以看一下： 这里需要注意两点： 虽然 combiner() 函数被调用了，但是只是返回了一个 BinaryOperator 而已，而这个 BinaryOperator 并不会被调用。 finisher() 函数并没有被调用，原因上面已经说过 characteristics() 函数被调用了两次，分别代表不同的意思 对于第3点，我们跟进 collector() 源代码里看一下, 便会有答案。 图中书说法其实不准确，其实是 evaluate 方法中的 ReduceOps.makeRef(collector) 中，会逐个调用相关方法， 包括 characteristics() 方法。 所以 characteristics() 被调用了两次，第一次用于判断 是否是无序集合 ；第二次用于判断 是否需要执行 finisher 用于中间结果和最终结果的类型转换 2 当中间结果与返回结果不一致看下面这个改造的自定义收集器，中间结果是个 set 而返回的是个 map，也就是中间结果和最终最终结果是不一致的。这个时候，finisher 函数就会排上用场了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MySetCollector2&lt;T&gt; implements Collector&lt;T, Set&lt;T&gt;, Map&lt;T,T&gt;&gt; &#123; @Override public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123; System.out.println("supplier invoked!!!!!"); return HashSet::new; &#125; @Override public BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123; System.out.println("accumulator invoked!!!!!"); return (set, item) -&gt; &#123; System.out.println(set); System.out.println("threadName: " + Thread.currentThread().getName()); set.add(item); &#125;;// return Set&lt;T&gt;::add; &#125; @Override public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123; System.out.println("combiner invoked!!!!!"); return (set1, set2) -&gt; &#123; set1.addAll(set2); return set1; &#125;; &#125; @Override public Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123; System.out.println("finisher invoked!!!!"); return set -&gt; &#123; Map&lt;T, T&gt; map = new HashMap&lt;&gt;(); set.stream().forEach(item -&gt; map.put(item, item)); return map; &#125;; &#125; /** * 当有 Characteristics.CONCURRENT 意味着如果有并发，则是多个线程操作一个集合。 * 这个时候 accumulator 如果有 遍历操作，就有可能会抛出 ConcurrentModificationException * @return */ @Override public Set&lt;Characteristics&gt; characteristics() &#123; System.out.println("characteristics invoked!!!!"); return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT)); &#125; public static void main(String[] args) &#123; for(int i = 0; i &lt; 100; i ++) &#123; List&lt;String&gt; words = Arrays.asList("hello", "word", "helloword", "hello", "a", "b", "c", "d", "e"); Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(words); Map&lt;String, String&gt; map = set.parallelStream().collect(new MySetCollector2&lt;&gt;()); System.out.println(map); &#125; &#125;&#125; 这里由于我输出与中间结果类型并不一致，所以如果我在 characteristics() 方法中，依旧使用 IDENTITY_FINISH ，也就是进行类型强转，则必然报错，类型转换异常。大家可以自己试一下。 3 并发与并行的区别-并行时候的一些坑这里，有另外一个很要命的坑。 在说这个概念之前，先说一下收集器中 parallel 和 concurrent 的区别 parallel 是并行，会将产生多个集合，多个线程操作，最后合并，也就是会调用 combiner() 方法 concurrent 是并发， 是多个线程对同一个集合进行操作，首先 combiner() 函数不会被执行，而同时，如果你在 accumulator() 函数中进行累加操作，又进行遍历操作，就会抛出并发异常。 用例子说话，首先我们必须采用 并行流 ， 在 accumulator() 函数中遍历 set, 同时将 characteristics() 函数中加入 CONCURRENT 这个属性，你执行100次，基本都会抛出异常 原因很简答也比较复杂： 程序采用了并行流 set.parallelStream()，同时设置了 CONCURRENT 属性；也就是说，多个线程操作同一个集合。 而在 accumulator() 函数中同时遍历了集合，也修改了集合。由于是多线程操作，很大的概率就会发生你一边遍历集合，一遍修改，就会报错。顺被大家可看看 ConcurrentModificationException 的 javadoc. 而如果，你不添加 CONCURRENT 这个属性，就不会报错。因为会生成多个中间集合。这一点，我们可以改造 supplier() 方法，在其中答应一条语句，通过打印了几条语句，就可以看出产生了几个集合。 当然了，如果你在 accumulator() 中不去有那个遍历的操作，也是即使你添加了 CONCURRENT 属性，也是不会报错的。因为你没有并发的即遍历又修改一个集合 而一般产生多少集合，由产生多少个线程决定，而产生多少线程一般由机器经过 超线程 技术之后有多少个处理器而确定的。当然也是可以修改的，但是一般没有必要。 12// 查看有多少处理器Runtime.getRuntime().availableProcessors();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-2-流初步以及Function详解]]></title>
      <url>%2F2017%2F02%2F14%2Fjdk8-2-%E6%B5%81%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8AFunction%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[一 流初步java 8提供一种更加方便的操作集合方式，即流~ StreamStream的概念其实类似于 liunx 操作系统的中的 PipeLine 的概念，可以将数据传输； 流 分为两种： 中间流：数据通过后还返回一个流，不是数据的终点 节点流：数据流入后不再返回流，操作结束，没有返回 使用java8 中的 List 来写一个例子，这个例子是将集合中的所有元素，全部变为大写，而后将元素逐一输出12345678910111213141516171819202122public class Test3 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list1 = Arrays.asList("min.zhu", "yi.yu", "nai.nai");// list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; System.out.println(item)); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); // 流的操作方式 类似 linux 的管道功能 // 流 分为： 中间流 和 节点流 // map 称之为 映射 与 mapper-reducer 阶段的map 功能是一致的，给定一个值，返回会一个由于之映射的值 list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; list2.add(item)); // 函数引用的做法 // String::toUpperCase 其实 和 item -&gt; item.toUpperCase() /** * 一致，都是有输入有输出，而 toUpperCase 的输入，就是调用他的实例对象 * 因为一个类是无法调用他的实例方法的，一定是实例才可以调用实例方法 */ list1.stream().map(String::toUpperCase).forEach(System.out::println); list1.stream().map(String::toUpperCase).forEach(list2::add); &#125;&#125; java8 的调用流的方式，是使用集合的 stream() 方法， 这个方法会返回一个流，之后就可以调用 map() 方法对 list 中的元素做一定的处理。 map() 函数，还是返回了一个流，这个流也有 forEach 方法，这个时候我们还可以调用 forEach 方法对流中的数据进行逐一的处理。 需要注意的是，forEach 函数中, 需要传递的函数的参数是一个 Consumer 的函数式接口，这个接口的抽象方法 accpt() 是没有返回值的，所以，他不在可以返回一个可以继续操作的流。 而我们在看看 map 方法中，需要传递的是一个我们没有见过的 Function 的函数式接口，这个函数式接口，有两个参数，一个是输入参数，一个是返回值。他的唯一的抽象方法中，是接受一个参数，返回一个值。具体见下图，唯一的方法是 apply 方法，它是有返回值的，这一点和现实中的函数很像 我们之前说过，java8 中，新增了很多个函数式接口，分别用于不同的场景如之前说的 Consumer 接口，他是没有返回值的一个场景，专用于处理数据以及今天说的有返回值的 Function 接口 那么这个 Function 的函数式接口，就是我们今天的重点。 二 Functon 接口 以及 BiFunction简介我们可以用一个例子来完整的说明问题： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 函数式接口 Function 的经典案例 * jdk 8 新增很多 函数式接口 * 之前看的 forEach 方法中的 Consumer 接口 ，他的作用就是 对给定的参数进行一系列操作，不返回值 * 而现在的 以及 Test3 中流的 map 方法中 Function 接口 ，他唯一的操作 是apply , 他有返回值，一个value 一个 Return ，与现实当中数学的函数很类似 * * jdk 8 中，接口中 除了可以有 default 方法以外， 还可以有一个 static 方法， static 方法可以有默认的实现 * 可以参考 Function 这个函数式接口 */public class FunctionTest &#123; public static void main(String[] args) &#123; FunctionTest functionTest = new FunctionTest(); // 函数式接口，以及 lambda 表达式，让我们可以在函数操作的时候，传递函数，即传递行为 // 而之前的编程方法，行为必须已经确定，而后进行调用 // 故而 之前的编程方法称之为命令式编程，而后面的方法称之为 函数式编程 // 而 可以传递，或者 返回函数的函数，称之为高阶函数（ js 中随处可见高阶函数 System.out.println(functionTest.compute(1, item -&gt; 2 * item)); // 这种返回方式是 statement 方法 // 上面那种方式是 expression 方式 // 一个是一个标准的语句，而一个是一个表达式 /* * 表达式是不需要分好结尾的 * 而使用 标准语句，则必须要 ； 而且要 &#123;&#125; */ System.out.println(functionTest.compute(1, item -&gt; &#123;return 2 * item;&#125;)); System.out.println(functionTest.compute(2, item -&gt; item * item)); System.out.println(functionTest.convert("hello", item -&gt; item + " world !!")); &#125; public int compute(int value, Function&lt;Integer, Integer&gt; function) &#123; return function.apply(value); &#125; public String convert(String value , Function&lt;String, String&gt; function) &#123; return function.apply(value); &#125;&#125; 主要去看代码的注释，上面写完了所有重点的内容，我们再去看看 Function 这个函数式接口的实现，我们知道，java8 允许接口有 default 方法，而 Function 接口中有两个默认方法： 利用这个两个方法，可以做函数的组合，用一个函数的输出，作为一个函数的输入。 compose 方法，是先执行 before 这个function, 在执行本身这个function； andThen 方法，则是先执行 Function 本体的 apply 方法，在执行传入的 after 的方法 我们来写个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class FunctionTest2 &#123; public static void main(String[] args) &#123; FunctionTest2 functionTest2 = new FunctionTest2(); // 12 System.out.println(functionTest2.compute(2, item -&gt; item * 3, item -&gt; item * item)); // 36 System.out.println(functionTest2.compute2(2, item -&gt; item * 3, item -&gt; item * item)); // 25 System.out.println(functionTest2.compute3(2, 3, (a,b)-&gt; a+b , result -&gt; result * result)); &#125; public int compute (int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; /** * compose 就是 先执行 function2.apply * 再将 function2.apply 的返回值，作为 function1 的输入 * 此时再执行 function1 apply */ return function1.compose(function2).apply(a); &#125; public int compute2 (int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; /** * compose 就是 先执行 function1.apply * 再将 function1.apply 的返回值，作为 function2 的输入 * 此时再执行 function2 apply */ return function1.andThen(function2).apply(a); &#125; /** * 如果想做有两个参数的Function 就需要使用BiFunction * 而 BiFunction 只有一个 andThen , andThen 的输入 是 Function， * 因为是将 Apply 的结果返回，结果只有一个，所以 参数只能是 Function , 而不是 BiFunction * 所以 BiFunction 方法不可能有 compose 方法 * * 对应的 consumer 也有着 BiConsumer 同时，二者因为没有返回值，所以也只可能有 andThen 方法 * @return */ public int compute3 (int a, int b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function) &#123; return biFunction.andThen(function).apply(a,b); &#125; compose 和 andThen 的功能可以从例子中很好的看出来，例子中还有一个新的接口叫 BiFunction, 这个函数式接口是给定两个输入，返回一个输出，解决了有两个参数的函数的问题，对应的，其实 Comsumer 接口也还有一个对应的 BiConsumer 接口。 而当我们去观察这俩 Bi 的接口，都只有一个 andThen 的接口，为啥没有 compose 方法呢？给读者自己思考吧~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-1.1-方法引用：lambda表达式的语法糖]]></title>
      <url>%2F2017%2F02%2F12%2Fjdk8-1-1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
      <content type="text"><![CDATA[方法应用其实是 jdk 8 中的对于 lambda 表达式给予的一种 语法糖 而方法引用一共分为 4 种； 1 类名::静态方法名 2 对象名::方法名 3 类名::实例方法名 4 构造方法引用::new 我们有intellj 编写 lambda 表达式的时候，编译器总是标黄来告诉你，这里可以使用方法引用的方法来进行代码的简化 而方法引用，method reference 其实就是lambda表达式一种语法糖但是 不是所有的 lambda 表达式，都可以用方法引用的方式来编写复杂的 lambda 表达式还是需要老老实实写相关代码 我们通过一个例子来分别讲解这四种方法引用的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static void main(String[] args) &#123; // 第一种 Student student1 = new Student("zhumin1",10); Student student2 = new Student("zhumin2",20); Student student3 = new Student("zhumin3",40); Student student4 = new Student("zhumin4",80); List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4); // jdk 1.8 的新方法 List 中新增加了 sort 方法 // 传统的 lambda 表达式 students.sort((studentP1, studentP2) -&gt; Student.compareByScore(studentP1, studentP2)); // 第一种方法引用的方式 类名::静态方法名 // 不需要传参数，因为可以自动推断出 Student 类型 students.sort(Student::compareByScore); // 第二种 对象名称::方法名称 // 其实和第一种很类似 StudentComparator studentComparator = new StudentComparator(); students.sort((studentP1, studentP2) -&gt; studentComparator.comparator(studentP1, studentP2)); // 对象名称::方法名称 (方法引用的第二种方式) students.sort(studentComparator::comparator); // 第三种方法 类名::实例方法 /** * 比较难理解的的地方是，你会看到调用的函数，和 lambda 表达式需要的参数个数不一致， 会少一个 * 而且类名是没法调用方法名的 * 而理解方式是：调用方法的实例，就是传入lambda 表达式的第一个参数，而剩下所有参数，都作为 调用的实例方法 的参数 * 我们看下面的例子 ， Student 类调用的是其的实例方法 compare（Student） 只有一个参数 * 而 List 的默认方法需要的 Comparator 的函数式接口需要两个参数，看似对应不上，而且，类名也无法调用实例方法 * 实际是，传入的第一参数就是 comare（student）这个函数的调用者，而第二个参数以及后续所有的参数（如果有跟多也是一样），是作为实例方法的参数传入 * 所以少一个参数也没什么 * 而更为关键的是这个就是一个语法糖，为了简化代码而生。理解就好 * 如此一来； 这个第三种方式就很好理解了 * * 类名::实例方法 * 即 lambda 表达式的第一参数就是 实例方法 的调用者，后续所有的参数就是 实例方法的传入参数 */ students.sort(Student::compare); // 再看一个例子 List&lt;String&gt; cities = Arrays.asList("haha","lala","nihao","memeda"); // 对比二者 Collections.sort(cities, (city1, city2) -&gt; city1.compareToIgnoreCase(city2)); Collections.sort(cities, String::compareToIgnoreCase); // 对于第四种，构造方法引用，对于带参数和不带参数的都可以，编译器会自动的进行腿短 MethodRefrenceTest methodRefrenceTest = new MethodRefrenceTest(); // 点击 new 看看会跳到那个方法里去 methodRefrenceTest.getName(String::new); // 点击 new 看看会跳到那个方法里去 methodRefrenceTest.getName2("haa", String::new); &#125; public String getName(Supplier&lt;String&gt; supplier) &#123; return supplier.get() + "haha"; &#125; public String getName2(String name, Function&lt;String ,String&gt; stringFunction) &#123; return stringFunction.apply(name); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-1-函数式接口&lambda表达式]]></title>
      <url>%2F2017%2F02%2F11%2Fjdk8-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[1 lmabda表达式首先看两段对比代码:为jbutton 添加一个时间监听器12345678910// 老写法: 匿名内部类jButton.addActionListener(new AbstractAction() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println("Hello Button"); &#125;&#125;); // lambda 表达式写法jButton.addActionListener(e -&gt; System.out.println("Hello Button")); 对比两个写法，lambda表达式的写法会简单很多，如果你有多行处理逻辑：12345// 加个大括号jButton.addActionListener(e -&gt;&#123; System.out.println("Hello Button!!!!"); System.out.println("Hello Button2!!!!");&#125;); 这里的e，没有声明类型，并不是表示java 不是一个静态语言了，而是，编译器的类型推断告诉可以推断出来这个 e 的类型肯定是一个 AbstractAction, 所以无需去写，当然如写上也没有问题，需要加上括号 1234jButton.addActionListener((AbstractAction e) -&gt;&#123; System.out.println("Hello Button!!!!"); System.out.println("Hello Button2!!!!");&#125;) 所以 lambda 表达式的基本结构如下（根据单个参数和单个操作可以有一定的省略）1234(event e1, event e2 ...) -&gt; &#123; action1; action2;&#125; 一开始可能不是特别好理解，我们可以结合 java8 新增的另一个特性 函数式接口 来一起理解为何我们可以如此编写代码 2 函数式接口什么叫函数式接口呢？ 函数式接口是 jdk1.8 中新增的一个接口类型，为此还新增了一个注解 @FunctionalInterface 用于标注函数接口；我们通过阅读 @FunctionalInterface 的 jdk 文档来进行概念认知。总结起来： 当一个接口 有且只有一个抽象方法，并且这个抽象方法不是继承自 Object 的方法，就会被当做一个 函数式接口 当一个接口被 @FunctionalInterface 注解时，可以当做一个函数式接口 当一个接口被 @FunctionalInterface 注解，但不满足第一个条件的时候，编译器会报错。 当一个接口 没有被 @FunctionalInterface 注解标注，但是满足函数式接口的条件，也会被当做函数式接口 这里的第一条后半部分很重要，如果一个接口，有两个抽象方法，但是其中一个是继承自 Object 类（因为其实万类师祖）, 他仍然是一个函数式接口。 例如以下实例就是一个完整的函数式接口，即使他有2个抽象方法，但是toString是继承自 Object 的方法，所以不会算作函数式接口的抽象方法，所以其中的 test() 方法, 是函数式接口认定的唯一的抽象方法。同理，如果下面的例子只有 toString() 方法，而没有 test() 方法，同时又有 @FunctionalInterface 注解的话，那么编译器会报错。1234567891011121314@FunctionalInterfaceinterface MyInterface &#123; /** * 函数式接口，只能有唯一的抽象方法 */ void test(); /** * 因为改抽象方法，继承自 Object，所以不算函数式接口的抽象方法 * 故而，接口可以算作一个函数式接口 */ String toString();&#125; 我们可以看一下 @FunctionalInterface 的jdk文档，里面有一句: 意思就是说，函数式接口的实现，可以通过 lambda 表达式 方法引用 以及 构造方法引用 的方式来实现。其实我们上面的 lambda 表达式的例子，就是实现的函数式接口。我们来新写一个例子。 12345678910111213141516171819public class Test2 &#123; public void testInterface(MyInterface myInterface) &#123; System.out.println("start ------------------"); myInterface.test(); System.out.println("end --------------------"); &#125; public static void main(String[] args) &#123; Test2 test2 = new Test2(); /* * 因为函数式接口的里唯一的抽象方法test里面，没有参数 * 但是（）不能省略 * 参考Test1 程序里面的Jframe 里的ActionListener */ test2.testInterface(() -&gt; &#123; System.out.println("函数式接口接口实现"); &#125;); &#125;&#125; 我们可以看到，testInterface 方法需要传递一个 testInterface的接口，而我们使用的方式就是 lambda 表达式来实现了一个函数式接口。 可以运用下面的形式来理解。 (函数式接口唯一的抽象方法的参数列表) -&gt; {唯一抽象函数的实现} 这个时候，我们看一下最开始的那个给 button 加 action 的例子。其实实现就是 ActionListener 这个函数式接口的唯一的抽象方法：虽然该类没有 @FunctionalInterface 注解，但是满足条件，只有一个抽象方法，所以他也是一个函数式接口，所以我们可以去使用 lambda 表达式去实现他。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[new start]]></title>
      <url>%2F2017%2F01%2F11%2Fnew-start%2F</url>
      <content type="text"><![CDATA[重新开始维护这个网站。让自己配得上这个不错的域名 movingon.cn! 我14年买了这个域名，本来想自己要好好做，实在不行，这域名也是一个不错的督促。 然而，自己维护了一段时间之后，就忘记了要去维护。 但是这一次，我用这里记录自己的技术成长以及个人感悟，作为自己的成长的记录。]]></content>
    </entry>

    
  
  
</search>
