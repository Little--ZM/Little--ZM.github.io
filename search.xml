<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[jdk8 Stream 解析2 - Spliterator分割迭代器]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk8-Stream-%E8%A7%A3%E6%9E%902-Spliterator%E5%88%86%E5%89%B2%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
      <content type="text"><![CDATA[概述说完Stream 的一些源码解析。我们看下我们的 Stream 是如何产生的。我们最为常见的流的产生方式是 collection.stream(), 你点开Stream()方法, 他是通过 Collection 这个上层接口两个java8 新增特性 default method 进行实现。 这就牵扯到一个关键要点 Spliterator ：分割迭代器。 本文主要描述 Spliterator 的作用，大部分来源于你不愿意读的 JavaDoc。 Spliterator 是 jdk8 非常重要的概念。里面的细节很值得学习玩味。 Spliterator 冗长的JavaDoc 说了什么？基本介绍Spliterator 是一个对源（数组，集合，io流等等）中元素进行遍历和分区的类。 可以通过 tryAdvance() 方法逐个遍历，也可以按照 forEachRemaining() 方法进行按 bulk 逐块的遍历。（内部调用的还是tryAdvance） Spliterator 有类似 Collector 中的 characteristics , 但都是由十六进制来表示的。 SIZED :表示大小固定, Collection常用 DISTINCT : 去重, Set常用 SORTED : 有顺序的 SortedSet 会用等等 原生类型的特化版本特化分割迭代器也被提供，和Stream类似。减少装箱和拆箱的操作 比迭代器Iterator 更加高效的遍历元素的方式提供更加高效的方法，进行数据的迭代。Iterator 的使用需要调用两个组合方法 hasNext() 以及 next() ，同事在多线程访问的情况下还会出现竞争，你需要去同步。而分割迭代器 Spliterator 使用函数式编程的方式，只用一个方法就可以做到这个两个函数动作。就避免了竞争 ，就是 tryAdvance() 方法。后面会介绍 Spliterator的接口方法tryAdvance()同时做了 hasNext() 以及 next() 的工作。 1234/*** 对给定的元素进行判断，如果满足条件就会执行 Action*/boolean tryAdvance(Consumer&lt;? super T&gt; action); forEachRemaining()是一个默认方法，对余下的元素进行操作，直到元素全部被遍历完一般情况下回直接调用上面的tryAdvance() 方法，但是也可以更具需要进行重写。1234567/*** 对余下的元素进行操作，直到元素全部被遍历完* 如果源是有序的，遍历也是有序的*/default void forEachRemaining(Consumer&lt;? super T&gt; action) &#123; do &#123; &#125; while (tryAdvance(action));&#125; 这里有一点很值得注意，方法体中的 do {} 是空的，这个是因为 tryAdvance() 方法本身就完成了两个操作 hasNext() 以及 next()，所以方法体中不需要有任何操作了。这个是 函数式编程带来的好处。以及与命令式编程的区别。 trySplit()尝试切分源来的 Spliterator， 返回的是（注意！！！）返回的是 分割出来的那一部分 数据，原有的数据集将不在包含这部分数据集合。两者 没有交集。剩下的可以继续分割，也许不可以继续分割了 举个例子，我原来有 100个元素，我通过 trySplit 切分出 30 个，作为一个新的 分割迭代器 返回，原有的，就还剩下 70 个。 如果是原有数据集合是 ORDERD 的，分出来的也是有序的。 除非元素数量是无穷的，否则，最后一定会出现不能在分割的情况，这种情况下，返回的结果是 null 1Spliterator&lt;T&gt; trySplit(); estimateSize()估算集合剩余给forEachRemaining大小，不一定精确。但是如果这个 Spliterator 是 SIZED，没有被遍历或者 split， 或是 SUBSIZED的，没有被遍历，那么他这个值一定是准确的。 1long estimateSize(); 还有个与之相关的默认方法，就是利用这个特性。123default long getExactSizeIfKnown() &#123; return (characteristics() &amp; SIZED) == 0 ? -1L : estimateSize(); &#125; characteristics()表示集合的特性，一共8个。 分割之前，返回的结果都是一致的 如果返回结果不一致，则操作是不受保证的 而分割之后，不保证一致 有一个默认方法用于判断 Spliterator 是否包含这个特性123default boolean hasCharacteristics(int characteristics) &#123; return (characteristics() &amp; characteristics) == characteristics; &#125; getComparator如果源是SORTED 类型的，且有比较器 Comparator 的话，则返回这个 Comparator，如果是SORTED 类型的，但是没有比较器，则返回 null , 除此之外，都抛出异常 接口的默认方法里，就是抛出了异常 123default Comparator&lt;? super T&gt; getComparator() &#123; throw new IllegalStateException(); &#125; Spliterator的8个Characteristics 特性ORDERED源的元素有序，tryAdvance ，forEachRemaining和 trySplit 都会保证有序的进行元素的处理 需要注意 hashSet 这类 Collection 是不保证有序的 有ORDERED 特性的数据，在并发计算的时候客户端也要做顺序限制的保证 DISTINCT太简单，唯一性。 类似 Set 这样的传入集合会拥有这样的特性 SORTED有这种特性的 Spliterator ，有一个特定的顺序。或者是所有元素都是可比较的，或者是有特定的比较器。 有 SORTED 一定会有 ORDERED SIZED有这种属性的 Spliterator 在遍历和分割之前，estimateSize() 返回的大小是固定的，并且是准确的。 NONNULL不为 NULL, 大部分并发的集合，队列，Map 都可能会有这样的特性。 IMMUTABLE不可变的。元素遍历期间不可以被 添加，替换，删除（cannot be added, replaced, or removed）否则，应该抛出异常。 CONCURRENT支持并发操作的。 顶层的 Spliterator 不可以 CONCURRENT 与 SIZED。 这两者是相互冲突的。 但是分割之后的 Spliterator ， 可能是 SIZED， 顶层不能决定底层 SUBSIZED从trySplit()被分割后的所有分割迭代器都是 SIZED 以及 SUBSIZED 的。如果分割后，没有按照要求返回SIZED 以及 SUBSIZED 属性，那么操作是不被保证的，也就是结果不可预测。 这个属性和 SIZED 的区别就是， SIZED 不保证 SUBSIZED。而 SUBSIZED 会要求保证 SIZED 内部特化而做的函数式接口 (OfPrimitive)除了上面的函数，以及特性，Spliterator 迭代器中，还有几个定义在内部的接口。 OfPrimitive 重载了（overloads）了 Spliterator 的方法。用于实现特化的分割迭代器。 overloads：返回类型名称一致，参数不一致。注意与 override 的区别 一个颠覆面向对象编程常识的现象请大家看图 这两次类型转换奇怪的地方是： IntConsumer 与 Consumer 两个接口，没有继承关系，两个接口是平行的。那为什么还能转换成功呢？ 你可以等我下一篇文章~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8 Stream & BaseStream 源码难点浅析1]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk8-Stream-BaseStream-%E6%BA%90%E7%A0%81%E9%9A%BE%E7%82%B9%E6%B5%85%E6%9E%901%2F</url>
      <content type="text"><![CDATA[概述 简要介绍 Stream 的 javadoc，与集合的关系以及区别，一些重要的注意事项 难懂的 Stream 类的声明，介绍比较难懂的 onClose() 方法的调用 Stream的javadocStream 的作用与特化版本Stream 是对一个序列做 串行 或者 并行 聚合操作。他继承自 StreamStream 同时还有几个特化的版本 ，IntStream , LongStream, DoubleStream. 他们为了减少流操作的时候一些不必要的装箱和拆箱的操作。 需要注意的是，以上四个 Stream 是平行关系，他们都是继承自 BaseStream 举个简单的例子： 12345678910/*** 将集合 widgets 中的元素中红色的元素的重量求和* 第一步 filter() 过滤红色* 第二步 mapToInt() 拿出所有的Red的重量，生成一个 IntStream* 第三步 sum() 求和，并返回*/int sum = widgets.stream() .filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum(); Stream 的组成与特点要想实现计算，所有操作，都会被放入一个 pipeline 当中（类似liunx）中的操作。 而一个流管道（pipeline）包含： source(源)： 数组，集合，迭代器，I/O 操作等等 0个或者多个中间操作： 将一个流转成另外一个流 1个终止操作 : 产生一个结果(比如上面的例子中的求和) or 或者修改传入对象的属性。 流是Lazy的懒惰的！！ 你不加 终止操作 流的操作，就不会被执行。如上面的例子，没有最后的 Sum() 函数，前面的操作是不会被执行的。 集合和Stream 的区别集合： 注重存储，主要考虑元素的访问与管理Stream ：注重计算，主要考虑以一种描述性 的语言来对源进行一系列的操作，并将操作聚合起来。 流的注意事项1 流中的操作，都应是函数式接口（lambda表达式或者方法引用）2 流不能被重用，每个流只能应用一次。想再次操作你需要重新生成一个流 3 流虽然实现了 AutoCloseable 接口，但是几乎所有的流都是不用关闭的，因为他的源大部分情况下都是集合，而集合是不用关闭的。 除非源是一个 I/O Channel。 比如 Files.lines() 方法。如果是这样，Stream 就可以申明在 try-with-resources block 中。关于这个 j7 新接口的使用，可以看我之前的一篇关于 AutoCloseable 的介绍 jdk1.7新增自动关闭接口AutoCloseable 多说一句，Files.lines() 是 j8 中新增的方法，有点类似 python 中 readlines() 方法。很好用。 Stream &amp; BaseStream 解析看不懂的声明我们可以看一下 Stream 以及 BaseStream 的类的声明 1234//Streampublic interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; //BaseStreampublic interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; BaseStream 中，第二个泛型是 S extends BaseStream&lt;T, S&gt; ，而 Stream 中，第二个泛型是 Stream&lt;T&gt;， 正好是满足 extends BaseStream&lt;T, S&gt; 的条件的，所以可以这么写。 两个泛型有没有感觉有点晕。其实比较好理解。 T 这个泛型很好理解，就是流中元素的类型 S ？ 如果你看过javadoc的描述，流的所有中间操作，都会返回一个流，而这个S 就代表着中间操作返回的流的类型。比如我们看一下这个在 Stream 中的方法（其他方法与其一致） 难懂的 onClose() 方法上面我们知道 BaseStream 实现了 AutoCloseable 接口，也就是 Close() 方法可以得到调用。但是 BaseStream 中，给我们提供了要给OnClose() 方法。我们看下截图 这个方法，就是当 Close() 方法被调用的时候 onClose()会被调用。但是有几个注意的点 onColse() 方法也返回一个流，也就是说可以多次调用。 如果你写了多个onClose() 方法，它会按照顺序调用。 前一个 onClose() 方法除了异常不影响后续 onClose 方法的使用 如果多个 onClose() 方法都抛出异常，只展示第一个异常的堆栈，而其他异常会被压缩，只展示部分信息 上代码！！！！！！ 12345678910111213141516171819202122232425/** * Created by charleszhu on 2017/5/2. */public class StreamTestOnCloseTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; testString = Arrays.asList(&quot;min&quot;, &quot;ge&quot;, &quot;da&quot;, &quot;shuaibi&quot;); /** * 两次关闭 * 两次异常 * 预期：两次关闭输出依次打出；两次关闭异常只打印一次堆栈，另外一次只展示 */ try(Stream&lt;String&gt; stream = testString.stream()) &#123; stream.onClose(() -&gt;&#123; System.out.println(&quot;closing 1&quot;); // throw new NullPointerException(&quot;exception 1&quot;); &#125;).onClose(() -&gt; &#123; System.out.println(&quot;closing 2&quot;); throw new NullPointerException(&quot;exception 2&quot;); &#125;).forEach(System.out::println); &#125; &#125;&#125; 结果如下图： 你们明白了吧（我是天才） 好懂的其他方法BaseStream 中有的一些其他方法，除了分割迭代器(后面会单独说，因为太重要) 1Spliterator&lt;T&gt; spliterator(); 其他都比较好懂。值得一说的是以下两个方法： 12S sequential(); // 返回串行流S parallel(); // 返回并行流 你可以看到他们都返回流对象，也就是可以继续调用 sequential 或者 parallel 方法。但是！！！ 无论你中间怎么调用 ，比如 sequential.parallel.parallel.sequential…. 只以最后一个为最终流的类型！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk1.7新增自动关闭接口AutoCloseable]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk1-7%E6%96%B0%E5%A2%9E%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%8E%A5%E5%8F%A3AutoCloseable%2F</url>
      <content type="text"><![CDATA[1 AutoCloseable 接口这是JDK1.7 的新增语法。帮助你自动关闭一些资源。可能你还不知道这个接口 这个接口好就好在，只有一个方法，名叫 close(), 而这正好有是我们各个资源关闭的方法名，所以使用起来相当方便，因为名称一样，代码兼容。 JDK8 中就在很多地方应用了这个接口，比如 Stream 继承了 BaseStream，而 BaseStream 则继承了 AutoCloseable 这个接口。 这个接口的说明很清楚，当你在使用 try-with-resources block 这种语法调用来进行资源获取的时候，在 block 退出之后自动关闭 try-with-resources block 代码块，就是将资源的声明，放在 try 里面； 可以看后面的代码示例 你不用像之前写 finally{} 代码那样的进行关闭。就不会有资源未被释放的问题。 2 测试代码简单测试代码如下 1234567891011121314151617181920212223/** * Created by charleszhu on 2017/5/2. */public class AutoCloseAbleTest implements AutoCloseable&#123; public void doSth() &#123; System.out.println(&quot;doStm&quot;); &#125; @Override public void close() throws Exception &#123; System.out.println(&quot;Close() 看到没，我被吊了&quot;); &#125; public static void main(String[] args) throws Exception &#123; /** * try-with-resources 语法块 */ try(AutoCloseAbleTest autoCloseAbleTest = new AutoCloseAbleTest()) &#123; autoCloseAbleTest.doSth(); &#125; &#125;&#125; 运行一下，结果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[老版本MacBookPro (厚的) 格式化, U盘安装 MacOS Sierra]]></title>
      <url>%2F2017%2F05%2F01%2F%E8%80%81%E7%89%88%E6%9C%ACMacBookPro-%E5%8E%9A%E7%9A%84-%E6%A0%BC%E5%BC%8F%E5%8C%96-U%E7%9B%98%E5%AE%89%E8%A3%85-MacOS-Sierra%2F</url>
      <content type="text"><![CDATA[引子主要写的点是：U 盘安装盘的制作，以及，为什么会有 can’t be verified 已损坏，重新下载 这些问题，即使你是从 app store 中下载的完整版本。 前两天，我一个朋友拿了一台很老的 MacBook pro , 说他不小心格式化了硬盘，要我重装系统。。 电脑图如下。。 有点洁癖的我看到了想说说，要不你砸了吧（当然我没说。。）但是碍于面子（毕竟我是程序员，外界都说是搞电脑的，约等于 修电脑的，近似于你是修电脑的，也就是说电脑相关的你全都会，不会就是大傻逼）。。 我当然是很愤怒的，之所以没有发作是因为他是我老师。。 如何制作安装盘准备工作你需要一下物品： 一个只要8G的U盘 一台工作良好的 macbook pro 良好的网络 我（你没戏了） 言归正传： 步骤一 ： 在App Store 中下载最新的 macos连接如下 下载地址她会跳转到 app store. 点击下载即可。它会弹出提示让你更新啥的，不用管它，直接下载 下载好了之后，你在你的 应用程序 文件夹，你就可以看到这个了 至此，你的第一任务完成。 步骤二 ：用磁盘工具格式化你的U盘打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致。) 如果不成功，你就多试几次 步骤三 ： 制作安装盘打开你的终端，输入如下命令1sudo /Applications/Install\ macOS\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\ macOS\ Sierra.app --nointeraction 注意空格前面需要有 \ 进行转义 耐心得到 done, 你就可以拿着 U 盘去安装了 无法验证？or 已经损坏？重装的步骤简单，插入u盘，开机按住 option, 选择u 盘的安装盘。接下来选择安装就可以了。 但是，大部分情况下，都会遇到类似 This copy of the Install OS X El Capitan application can’t be verified. It may have been corrupted or tampered with during downloading 或者，直接告诉你损坏了，让你再去下载完整版本。 导致这个的原因是，当你决定将一台mac格式化后，在重装系统的时候，系统的时间已经被改变了。这个时候安装程序就会爆出各种错误。你可以通过 终端输入 date 进行查看，时间应该变成了 2001 年。 这个时候， 你只要通过 date 命令重置时间，就可以解决这个问题。他的参数如下 123456date MMDDHHmmYY replacing the letters as follows.MM - 2 digit month 01 - 12DD - 2 digit date 01 - 31HH - 2 digit hour 01 - 24mm - 2 digit minute 01 - 59YY - 2 digit year &gt; 15 你将时间设置成，你要安装的系统发布之后的一个时间后，退出终端，再次点击操作，就不会有问题。 你也可以看做这个视频 土逼视频 ，需要翻墙。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-32-groupingBy 源码分析]]></title>
      <url>%2F2017%2F04%2F30%2Fjdk8-32-groupingBy-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[jdk8 集合的工厂类 Collectors 提供了两个很好用的静态函数。 groupingBy partitioningBy groupingBy 实现类似 Mysql 中分分组功能。返回一个 Map; 而 partitioningBy可以看做是 groupingBy 的特殊形式。我们后面会接着介绍。 使用的是比如统计每个城市人的“姓”，可以这么写 1Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); 那么，他到底如何利用 Collector 的各个接口来实现的呢？下面我们将深入 JDK 的 Collectors 的源码中，分析一下他是如何工作的。 groupingBy1 第一个重载方法, 要简单就别那么多要求，给你个List不错了分组 groupingBy 有三个重载方法。一个比一复杂。 先看最简单的 12345678/** * @param &lt;T&gt; the type of the input elements * @param &lt;K&gt; the type of the keys*/public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier) &#123; return groupingBy(classifier, toList()); &#125; 这里 T 是输入集合的元素类型， K 是最后产生的 Map 的主键key 的类型。 函数需要传入一个 Function 的函数式接口，Function 的中作就是分类器，比如传入的类型是T 是一个 Person类型 ， 通过 apply() 方法，返回 Person 的属性 name；因为我们要按照 name 来分组。 所以，如果 name 的类型是 String ； 那么 K 就是 String 故而，这个 groupingBy(function) 的功能就很清晰了，就是通过 function 对传入的 T 类型进行分类。然后调用 toList() 方法，也就是说每个分类的Person 会放进一个 List&lt;Person&gt; 中 最终返回的类型就是 Map&lt;String, List&lt;Person&gt;&gt;. 而如果你不想返回的是一个List , 希望是一个 Set. 你就要使用第二个重载方法~ 他允许你定义最后的输出函数。 2 第二个重载方法：我要输出Set看一下函数的定义： 12345678910111213/** * @param &lt;T&gt; the type of the input elements * @param &lt;K&gt; the type of the keys * @param &lt;A&gt; the intermediate accumulation type of the downstream collector * @param &lt;D&gt; the result type of the downstream reduction * @param classifier a classifier function mapping input elements to keys * @param downstream a &#123;@code Collector&#125; implementing the downstream reduction*/public static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream) &#123; return groupingBy(classifier, HashMap::new, downstream); &#125; 这个函数，明显比上一个要复杂，可以看到，多了一个 Collector 的 downstream , 可以自定义输出的集合。上面那个简单版本的函数是是写死的 List 这个函数有四个泛型。 T 原始元素类型，比如我们这是 Person K 返回 Map 的 key, 即最终返回的Map 的建的类型。如果你想按照人的名字分类，那T就是 String, 如果按照年龄分类，那就是 Interger A 是 downstream 的 accumulation 的中间结果类型 D 是最终输出 Map 的 Value 的类型。比如 List 或者 Set 这个方法会调用第三个重载函数，比第二个函数，多了中间的 HashMap::new； 这个是最终返回的 Map 的类型，这里写死的是 HashMap, 如果你想用其他类型，就需要使用最终的也是最复杂的第三个重载函数。 越是你用起来简单的函数，背后的实现就越来越复杂。 3 第三个重载方法: 能看懂就随便你怎么玩12345678910111213141516171819202122232425262728293031323334353637383940414243/*** @param &lt;T&gt; the type of the input elements* @param &lt;K&gt; the type of the keys* @param &lt;A&gt; the intermediate accumulation type of the downstream collector* @param &lt;D&gt; the result type of the downstream reduction* @param &lt;M&gt; the type of the resulting &#123;@code Map&#125;* @param classifier a classifier function mapping input elements to keys* @param downstream a &#123;@code Collector&#125; implementing the downstream reduction* @param mapFactory a function which, when called, produces a new empty* &#123;@code Map&#125; of the desired type*/ public static &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream) &#123; Supplier&lt;A&gt; downstreamSupplier = downstream.supplier(); BiConsumer&lt;A, ? super T&gt; downstreamAccumulator = downstream.accumulator(); BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123; K key = Objects.requireNonNull(classifier.apply(t), "element cannot be mapped to a null key"); A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get()); downstreamAccumulator.accept(container, t); &#125;; BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner()); @SuppressWarnings("unchecked") Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory; if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123; return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID); &#125; else &#123; @SuppressWarnings("unchecked") Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher(); Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123; intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v)); @SuppressWarnings("unchecked") M castResult = (M) intermediate; return castResult; &#125;; return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID); &#125; &#125; 这个函数有5个泛型，除去上面说的 T，K，A，D多了一个 mapFactory 的 Supplier() , 用于得到最终返回的 Map 的类型，第二个重载函数写死的 HashMap，这就可以进行自定义。 这个函数有连个值得注意的点： 所有的Collectors 中函数，如果函数内部还要做集合处理的，都是使用 downstream 这种模式，利用 downstream 的各种已有的的 Supplier Accumulator等，修改来实现自己的功能。比如在 groupingBy 这个函数，一开始就获取了 downstream 的各个组件，组合成自己需要的收集器，进而用于完成分类的行为。（你还可以去看一看 collectingAndThen() 这个函数） groupingBy 函数中有有两处强制类型转换。这里其实很难理解，为何可以直接成功的转换呢？ 第一处 第二处 两处其实都是将最终结果泛型 D 转成 中间结果 A。对于第一处， mapFactory 是作为一个 Supplier 出现，而他的目的是提供中间结果类型，而他上面的 accumulator 的中间结果类型，就是K,A， 所以这样的强转是一定可以成功的 第二处也是一样的，因为全称都使用了 A，其实 A 和 D 在这里，是等价的。所以转换都可以成功。 你去可以从这么一个角度思考问题： 你最终需要生成 D 类型，为何中间要给自己生成一个不一样的 A 类型添堵呢？ 你 4 不 4 sa？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-31-工厂方法收集器Collectors的中的常用函数]]></title>
      <url>%2F2017%2F04%2F13%2Fjdk8-31-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86%E5%99%A8Collectors%E7%9A%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[1 collectorImpl Collectors 中的 的基础 collectorImpl 两个构造方法一个有 finisher(), 一个没有。这个很容易理解，一个需要转换中间结果，一个中间结果和最终结果一致，所以不需要使用 finisher() 方法 2 两种实现方式对于工厂类 两种实现方式 CollectorImpl 来实现。 reduceing 来实现， 而 reducing 方法归根还是用的是 CollectorImpl 方法来实现 3 常见函数1） toList() &amp; toCollection 两个最常用的方法 toList() &amp; toCollection toSet() 方法是也是 toCollection 的特化。 2） joining() joining 三种重载方法 3） mapping() mapping() 将输入元素转换成输出元素 1234Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity= people.stream().collect(groupingBy(Person::getCity,mapping(Person::getLastName, toSet()) // Mapping , 将Person 转换成String , 提供给下游 Collector 使用)); 4） collectingAndThen() collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher) 先过完上层收集器 downstream ，在进行一次 finisher() 转换结果 比如说，你在 toList() 之后，想将它转换成一个 immutableList() 就可以如下使用 List&lt;String&gt; people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList)); 实现其实很有意思 5） counting() , minBy() , maxBy() counting() , minBy() , maxBy() 用 reducing() 实现, reducing() 又是基于 CollectorImpl 实现 6） summingInt() , averagingInt() , averagingDouble() summingInt() 对每一个元素使用 toIntFunction 在累加，实现很有意思 Supplier() 采用生成了一个 长度为1 的 int 数组，而不是直接使用的整形数字？因为数字是一个 值， 值是无法传递的，而数组是一个 引用， 引用是可以传递的。 averagingInt() 求平均值 对于averagingDouble() 的实现可以再去看一下，他的初始数组长度为4，他们视为浮点数计算的补偿产生的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-28-30-自定义收集器&坑]]></title>
      <url>%2F2017%2F04%2F12%2Fjdk8-28-30-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%B6%E9%9B%86%E5%99%A8-%E5%9D%91%2F</url>
      <content type="text"><![CDATA[收集器中有很5个抽象方法，每个抽象方法都有自己特殊的作用，如果说我们要自己实现要给收集器的话，我们就需要分别实现下面五个方法。 1 简单自定义一个收集器这个收集器的目的是将一个 list 转换成一个 set 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MySetCollector&lt;T&gt; implements Collector&lt;T, Set&lt;T&gt;, Set&lt;T&gt;&gt; &#123; @Override public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123; System.out.println("supplier invoked!!!"); return HashSet::new; &#125; @Override public BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123; System.out.println("accumulator invoked!!!"); return Set&lt;T&gt;::add; &#125; /** * 并行性流才会调用，将两个分段的集合 * @return */ @Override public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123; System.out.println("combiner invoked!!!"); return (t1, t2) -&gt; &#123; t1.addAll(t2); return t1; &#125;; &#125; @Override public Function&lt;Set&lt;T&gt;, Set&lt;T&gt;&gt; finisher() &#123; System.out.println("finisher invoked!!!"); return Function.identity(); &#125; /** * 描述这个集合的特性 * IDENTITY_FINISH 表示结果容器和中间容器是一致的，这个时候 JDK 会在返回的时候自动帮助我们做类型转换。而不用再去调用 finisher * @return */ @Override public Set&lt;Characteristics&gt; characteristics() &#123; System.out.println("characteristics invoked!!!"); return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH,UNORDERED)); &#125; public static void main(String[] args) &#123; List&lt;String&gt; words = Arrays.asList("hello" , "world", "welcome", "hello"); Set&lt;String&gt; stringSet = words.stream().collect(new MySetCollector&lt;&gt;()); System.out.println(stringSet); &#125;&#125; 实现类里，我们分别实现了5个方法。 其中比较重要的两个方式 finisher 和 characteristics 方法 这俩方法是相互影响的。首先看 characteristics 方法，这个方法要求返回一个 Characteristics 枚举类型对的 Set。而 Characteristics 一共有三个枚举值。分别有不同的含义。 123456789101112131415161718/** * 当我们采用并行流的时候，同时设置了 CONCURRENT 作为这个流的特性 * 那么，操作的是同一个集合，而不是多个 * 同样的道理，我们采用了并行流的方式，但是没有这个特性，我们就会生成多个 * 集合 */ CONCURRENT, /** * 代表集合是否是有序的 */ UNORDERED, /** * 表示 finisher function 可以被省略，因为中间结果和最后的返回的结果的类型是一致的。 * 所以当我们设置了这个属性之后，我们就必须了解到， 最后的返回的类型，可以由中间结果类型进行强制的返回。 */ IDENTITY_FINISH 上面的例子中，我们为我们自己的 collector 设置了两个属性， IDENTITY_FINISH &amp; UNORDERED ; 意思就是这个收集器收集的元素是无序的。 而同时，返回的类型和中间结果类型是可以完全强制转换的（如果不可以，则会报错，下面会说到）；而 finisher() 函数是不会被执行的，即使你在函数内部直接抛出一个异常都没有问题，因为根本不会执行。执行结果我们可以看一下： 这里需要注意两点： 虽然 combiner() 函数被调用了，但是只是返回了一个 BinaryOperator 而已，而这个 BinaryOperator 并不会被调用。 finisher() 函数并没有被调用，原因上面已经说过 characteristics() 函数被调用了两次，分别代表不同的意思 对于第3点，我们跟进 collector() 源代码里看一下, 便会有答案。 图中书说法其实不准确，其实是 evaluate 方法中的 ReduceOps.makeRef(collector) 中，会逐个调用相关方法， 包括 characteristics() 方法。 所以 characteristics() 被调用了两次，第一次用于判断 是否是无序集合 ；第二次用于判断 是否需要执行 finisher 用于中间结果和最终结果的类型转换 2 当中间结果与返回结果不一致看下面这个改造的自定义收集器，中间结果是个 set 而返回的是个 map，也就是中间结果和最终最终结果是不一致的。这个时候，finisher 函数就会排上用场了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MySetCollector2&lt;T&gt; implements Collector&lt;T, Set&lt;T&gt;, Map&lt;T,T&gt;&gt; &#123; @Override public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123; System.out.println("supplier invoked!!!!!"); return HashSet::new; &#125; @Override public BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123; System.out.println("accumulator invoked!!!!!"); return (set, item) -&gt; &#123; System.out.println(set); System.out.println("threadName: " + Thread.currentThread().getName()); set.add(item); &#125;;// return Set&lt;T&gt;::add; &#125; @Override public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123; System.out.println("combiner invoked!!!!!"); return (set1, set2) -&gt; &#123; set1.addAll(set2); return set1; &#125;; &#125; @Override public Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123; System.out.println("finisher invoked!!!!"); return set -&gt; &#123; Map&lt;T, T&gt; map = new HashMap&lt;&gt;(); set.stream().forEach(item -&gt; map.put(item, item)); return map; &#125;; &#125; /** * 当有 Characteristics.CONCURRENT 意味着如果有并发，则是多个线程操作一个集合。 * 这个时候 accumulator 如果有 遍历操作，就有可能会抛出 ConcurrentModificationException * @return */ @Override public Set&lt;Characteristics&gt; characteristics() &#123; System.out.println("characteristics invoked!!!!"); return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT)); &#125; public static void main(String[] args) &#123; for(int i = 0; i &lt; 100; i ++) &#123; List&lt;String&gt; words = Arrays.asList("hello", "word", "helloword", "hello", "a", "b", "c", "d", "e"); Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(words); Map&lt;String, String&gt; map = set.parallelStream().collect(new MySetCollector2&lt;&gt;()); System.out.println(map); &#125; &#125;&#125; 这里由于我输出与中间结果类型并不一致，所以如果我在 characteristics() 方法中，依旧使用 IDENTITY_FINISH ，也就是进行类型强转，则必然报错，类型转换异常。大家可以自己试一下。 3 并发与并行的区别-并行时候的一些坑这里，有另外一个很要命的坑。 在说这个概念之前，先说一下收集器中 parallel 和 concurrent 的区别 parallel 是并行，会将产生多个集合，多个线程操作，最后合并，也就是会调用 combiner() 方法 concurrent 是并发， 是多个线程对同一个集合进行操作，首先 combiner() 函数不会被执行，而同时，如果你在 accumulator() 函数中进行累加操作，又进行遍历操作，就会抛出并发异常。 用例子说话，首先我们必须采用 并行流 ， 在 accumulator() 函数中遍历 set, 同时将 characteristics() 函数中加入 CONCURRENT 这个属性，你执行100次，基本都会抛出异常 原因很简答也比较复杂： 程序采用了并行流 set.parallelStream()，同时设置了 CONCURRENT 属性；也就是说，多个线程操作同一个集合。 而在 accumulator() 函数中同时遍历了集合，也修改了集合。由于是多线程操作，很大的概率就会发生你一边遍历集合，一遍修改，就会报错。顺被大家可看看 ConcurrentModificationException 的 javadoc. 而如果，你不添加 CONCURRENT 这个属性，就不会报错。因为会生成多个中间集合。这一点，我们可以改造 supplier() 方法，在其中答应一条语句，通过打印了几条语句，就可以看出产生了几个集合。 当然了，如果你在 accumulator() 中不去有那个遍历的操作，也是即使你添加了 CONCURRENT 属性，也是不会报错的。因为你没有并发的即遍历又修改一个集合 而一般产生多少集合，由产生多少个线程决定，而产生多少线程一般由机器经过 超线程 技术之后有多少个处理器而确定的。当然也是可以修改的，但是一般没有必要。 12// 查看有多少处理器Runtime.getRuntime().availableProcessors();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-2-流初步以及Function详解]]></title>
      <url>%2F2017%2F02%2F14%2Fjdk8-2-%E6%B5%81%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8AFunction%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[一 流初步java 8提供一种更加方便的操作集合方式，即流~ StreamStream的概念其实类似于 liunx 操作系统的中的 PipeLine 的概念，可以将数据传输； 流 分为两种： 中间流：数据通过后还返回一个流，不是数据的终点 节点流：数据流入后不再返回流，操作结束，没有返回 使用java8 中的 List 来写一个例子，这个例子是将集合中的所有元素，全部变为大写，而后将元素逐一输出12345678910111213141516171819202122public class Test3 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list1 = Arrays.asList("min.zhu", "yi.yu", "nai.nai");// list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; System.out.println(item)); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); // 流的操作方式 类似 linux 的管道功能 // 流 分为： 中间流 和 节点流 // map 称之为 映射 与 mapper-reducer 阶段的map 功能是一致的，给定一个值，返回会一个由于之映射的值 list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; list2.add(item)); // 函数引用的做法 // String::toUpperCase 其实 和 item -&gt; item.toUpperCase() /** * 一致，都是有输入有输出，而 toUpperCase 的输入，就是调用他的实例对象 * 因为一个类是无法调用他的实例方法的，一定是实例才可以调用实例方法 */ list1.stream().map(String::toUpperCase).forEach(System.out::println); list1.stream().map(String::toUpperCase).forEach(list2::add); &#125;&#125; java8 的调用流的方式，是使用集合的 stream() 方法， 这个方法会返回一个流，之后就可以调用 map() 方法对 list 中的元素做一定的处理。 map() 函数，还是返回了一个流，这个流也有 forEach 方法，这个时候我们还可以调用 forEach 方法对流中的数据进行逐一的处理。 需要注意的是，forEach 函数中, 需要传递的函数的参数是一个 Consumer 的函数式接口，这个接口的抽象方法 accpt() 是没有返回值的，所以，他不在可以返回一个可以继续操作的流。 而我们在看看 map 方法中，需要传递的是一个我们没有见过的 Function 的函数式接口，这个函数式接口，有两个参数，一个是输入参数，一个是返回值。他的唯一的抽象方法中，是接受一个参数，返回一个值。具体见下图，唯一的方法是 apply 方法，它是有返回值的，这一点和现实中的函数很像 我们之前说过，java8 中，新增了很多个函数式接口，分别用于不同的场景如之前说的 Consumer 接口，他是没有返回值的一个场景，专用于处理数据以及今天说的有返回值的 Function 接口 那么这个 Function 的函数式接口，就是我们今天的重点。 二 Functon 接口 以及 BiFunction简介我们可以用一个例子来完整的说明问题： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 函数式接口 Function 的经典案例 * jdk 8 新增很多 函数式接口 * 之前看的 forEach 方法中的 Consumer 接口 ，他的作用就是 对给定的参数进行一系列操作，不返回值 * 而现在的 以及 Test3 中流的 map 方法中 Function 接口 ，他唯一的操作 是apply , 他有返回值，一个value 一个 Return ，与现实当中数学的函数很类似 * * jdk 8 中，接口中 除了可以有 default 方法以外， 还可以有一个 static 方法， static 方法可以有默认的实现 * 可以参考 Function 这个函数式接口 */public class FunctionTest &#123; public static void main(String[] args) &#123; FunctionTest functionTest = new FunctionTest(); // 函数式接口，以及 lambda 表达式，让我们可以在函数操作的时候，传递函数，即传递行为 // 而之前的编程方法，行为必须已经确定，而后进行调用 // 故而 之前的编程方法称之为命令式编程，而后面的方法称之为 函数式编程 // 而 可以传递，或者 返回函数的函数，称之为高阶函数（ js 中随处可见高阶函数 System.out.println(functionTest.compute(1, item -&gt; 2 * item)); // 这种返回方式是 statement 方法 // 上面那种方式是 expression 方式 // 一个是一个标准的语句，而一个是一个表达式 /* * 表达式是不需要分好结尾的 * 而使用 标准语句，则必须要 ； 而且要 &#123;&#125; */ System.out.println(functionTest.compute(1, item -&gt; &#123;return 2 * item;&#125;)); System.out.println(functionTest.compute(2, item -&gt; item * item)); System.out.println(functionTest.convert("hello", item -&gt; item + " world !!")); &#125; public int compute(int value, Function&lt;Integer, Integer&gt; function) &#123; return function.apply(value); &#125; public String convert(String value , Function&lt;String, String&gt; function) &#123; return function.apply(value); &#125;&#125; 主要去看代码的注释，上面写完了所有重点的内容，我们再去看看 Function 这个函数式接口的实现，我们知道，java8 允许接口有 default 方法，而 Function 接口中有两个默认方法： 利用这个两个方法，可以做函数的组合，用一个函数的输出，作为一个函数的输入。 compose 方法，是先执行 before 这个function, 在执行本身这个function； andThen 方法，则是先执行 Function 本体的 apply 方法，在执行传入的 after 的方法 我们来写个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class FunctionTest2 &#123; public static void main(String[] args) &#123; FunctionTest2 functionTest2 = new FunctionTest2(); // 12 System.out.println(functionTest2.compute(2, item -&gt; item * 3, item -&gt; item * item)); // 36 System.out.println(functionTest2.compute2(2, item -&gt; item * 3, item -&gt; item * item)); // 25 System.out.println(functionTest2.compute3(2, 3, (a,b)-&gt; a+b , result -&gt; result * result)); &#125; public int compute (int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; /** * compose 就是 先执行 function2.apply * 再将 function2.apply 的返回值，作为 function1 的输入 * 此时再执行 function1 apply */ return function1.compose(function2).apply(a); &#125; public int compute2 (int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; /** * compose 就是 先执行 function1.apply * 再将 function1.apply 的返回值，作为 function2 的输入 * 此时再执行 function2 apply */ return function1.andThen(function2).apply(a); &#125; /** * 如果想做有两个参数的Function 就需要使用BiFunction * 而 BiFunction 只有一个 andThen , andThen 的输入 是 Function， * 因为是将 Apply 的结果返回，结果只有一个，所以 参数只能是 Function , 而不是 BiFunction * 所以 BiFunction 方法不可能有 compose 方法 * * 对应的 consumer 也有着 BiConsumer 同时，二者因为没有返回值，所以也只可能有 andThen 方法 * @return */ public int compute3 (int a, int b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function) &#123; return biFunction.andThen(function).apply(a,b); &#125; compose 和 andThen 的功能可以从例子中很好的看出来，例子中还有一个新的接口叫 BiFunction, 这个函数式接口是给定两个输入，返回一个输出，解决了有两个参数的函数的问题，对应的，其实 Comsumer 接口也还有一个对应的 BiConsumer 接口。 而当我们去观察这俩 Bi 的接口，都只有一个 andThen 的接口，为啥没有 compose 方法呢？给读者自己思考吧~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-1.1-方法引用：lambda表达式的语法糖]]></title>
      <url>%2F2017%2F02%2F12%2Fjdk8-1-1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
      <content type="text"><![CDATA[方法应用其实是 jdk 8 中的对于 lambda 表达式给予的一种 语法糖 而方法引用一共分为 4 种； 1 类名::静态方法名 2 对象名::方法名 3 类名::实例方法名 4 构造方法引用::new 我们有intellj 编写 lambda 表达式的时候，编译器总是标黄来告诉你，这里可以使用方法引用的方法来进行代码的简化 而方法引用，method reference 其实就是lambda表达式一种语法糖但是 不是所有的 lambda 表达式，都可以用方法引用的方式来编写复杂的 lambda 表达式还是需要老老实实写相关代码 我们通过一个例子来分别讲解这四种方法引用的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static void main(String[] args) &#123; // 第一种 Student student1 = new Student("zhumin1",10); Student student2 = new Student("zhumin2",20); Student student3 = new Student("zhumin3",40); Student student4 = new Student("zhumin4",80); List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4); // jdk 1.8 的新方法 List 中新增加了 sort 方法 // 传统的 lambda 表达式 students.sort((studentP1, studentP2) -&gt; Student.compareByScore(studentP1, studentP2)); // 第一种方法引用的方式 类名::静态方法名 // 不需要传参数，因为可以自动推断出 Student 类型 students.sort(Student::compareByScore); // 第二种 对象名称::方法名称 // 其实和第一种很类似 StudentComparator studentComparator = new StudentComparator(); students.sort((studentP1, studentP2) -&gt; studentComparator.comparator(studentP1, studentP2)); // 对象名称::方法名称 (方法引用的第二种方式) students.sort(studentComparator::comparator); // 第三种方法 类名::实例方法 /** * 比较难理解的的地方是，你会看到调用的函数，和 lambda 表达式需要的参数个数不一致， 会少一个 * 而且类名是没法调用方法名的 * 而理解方式是：调用方法的实例，就是传入lambda 表达式的第一个参数，而剩下所有参数，都作为 调用的实例方法 的参数 * 我们看下面的例子 ， Student 类调用的是其的实例方法 compare（Student） 只有一个参数 * 而 List 的默认方法需要的 Comparator 的函数式接口需要两个参数，看似对应不上，而且，类名也无法调用实例方法 * 实际是，传入的第一参数就是 comare（student）这个函数的调用者，而第二个参数以及后续所有的参数（如果有跟多也是一样），是作为实例方法的参数传入 * 所以少一个参数也没什么 * 而更为关键的是这个就是一个语法糖，为了简化代码而生。理解就好 * 如此一来； 这个第三种方式就很好理解了 * * 类名::实例方法 * 即 lambda 表达式的第一参数就是 实例方法 的调用者，后续所有的参数就是 实例方法的传入参数 */ students.sort(Student::compare); // 再看一个例子 List&lt;String&gt; cities = Arrays.asList("haha","lala","nihao","memeda"); // 对比二者 Collections.sort(cities, (city1, city2) -&gt; city1.compareToIgnoreCase(city2)); Collections.sort(cities, String::compareToIgnoreCase); // 对于第四种，构造方法引用，对于带参数和不带参数的都可以，编译器会自动的进行腿短 MethodRefrenceTest methodRefrenceTest = new MethodRefrenceTest(); // 点击 new 看看会跳到那个方法里去 methodRefrenceTest.getName(String::new); // 点击 new 看看会跳到那个方法里去 methodRefrenceTest.getName2("haa", String::new); &#125; public String getName(Supplier&lt;String&gt; supplier) &#123; return supplier.get() + "haha"; &#125; public String getName2(String name, Function&lt;String ,String&gt; stringFunction) &#123; return stringFunction.apply(name); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-1-函数式接口&lambda表达式]]></title>
      <url>%2F2017%2F02%2F11%2Fjdk8-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[1 lmabda表达式首先看两段对比代码:为jbutton 添加一个时间监听器12345678910// 老写法: 匿名内部类jButton.addActionListener(new AbstractAction() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println("Hello Button"); &#125;&#125;); // lambda 表达式写法jButton.addActionListener(e -&gt; System.out.println("Hello Button")); 对比两个写法，lambda表达式的写法会简单很多，如果你有多行处理逻辑：12345// 加个大括号jButton.addActionListener(e -&gt;&#123; System.out.println("Hello Button!!!!"); System.out.println("Hello Button2!!!!");&#125;); 这里的e，没有声明类型，并不是表示java 不是一个静态语言了，而是，编译器的类型推断告诉可以推断出来这个 e 的类型肯定是一个 AbstractAction, 所以无需去写，当然如写上也没有问题，需要加上括号 1234jButton.addActionListener((AbstractAction e) -&gt;&#123; System.out.println("Hello Button!!!!"); System.out.println("Hello Button2!!!!");&#125;) 所以 lambda 表达式的基本结构如下（根据单个参数和单个操作可以有一定的省略）1234(event e1, event e2 ...) -&gt; &#123; action1; action2;&#125; 一开始可能不是特别好理解，我们可以结合 java8 新增的另一个特性 函数式接口 来一起理解为何我们可以如此编写代码 2 函数式接口什么叫函数式接口呢？ 函数式接口是 jdk1.8 中新增的一个接口类型，为此还新增了一个注解 @FunctionalInterface 用于标注函数接口；我们通过阅读 @FunctionalInterface 的 jdk 文档来进行概念认知。总结起来： 当一个接口 有且只有一个抽象方法，并且这个抽象方法不是继承自 Object 的方法，就会被当做一个 函数式接口 当一个接口被 @FunctionalInterface 注解时，可以当做一个函数式接口 当一个接口被 @FunctionalInterface 注解，但不满足第一个条件的时候，编译器会报错。 当一个接口 没有被 @FunctionalInterface 注解标注，但是满足函数式接口的条件，也会被当做函数式接口 这里的第一条后半部分很重要，如果一个接口，有两个抽象方法，但是其中一个是继承自 Object 类（因为其实万类师祖）, 他仍然是一个函数式接口。 例如以下实例就是一个完整的函数式接口，即使他有2个抽象方法，但是toString是继承自 Object 的方法，所以不会算作函数式接口的抽象方法，所以其中的 test() 方法, 是函数式接口认定的唯一的抽象方法。同理，如果下面的例子只有 toString() 方法，而没有 test() 方法，同时又有 @FunctionalInterface 注解的话，那么编译器会报错。1234567891011121314@FunctionalInterfaceinterface MyInterface &#123; /** * 函数式接口，只能有唯一的抽象方法 */ void test(); /** * 因为改抽象方法，继承自 Object，所以不算函数式接口的抽象方法 * 故而，接口可以算作一个函数式接口 */ String toString();&#125; 我们可以看一下 @FunctionalInterface 的jdk文档，里面有一句: 意思就是说，函数式接口的实现，可以通过 lambda 表达式 方法引用 以及 构造方法引用 的方式来实现。其实我们上面的 lambda 表达式的例子，就是实现的函数式接口。我们来新写一个例子。 12345678910111213141516171819public class Test2 &#123; public void testInterface(MyInterface myInterface) &#123; System.out.println("start ------------------"); myInterface.test(); System.out.println("end --------------------"); &#125; public static void main(String[] args) &#123; Test2 test2 = new Test2(); /* * 因为函数式接口的里唯一的抽象方法test里面，没有参数 * 但是（）不能省略 * 参考Test1 程序里面的Jframe 里的ActionListener */ test2.testInterface(() -&gt; &#123; System.out.println("函数式接口接口实现"); &#125;); &#125;&#125; 我们可以看到，testInterface 方法需要传递一个 testInterface的接口，而我们使用的方式就是 lambda 表达式来实现了一个函数式接口。 可以运用下面的形式来理解。 (函数式接口唯一的抽象方法的参数列表) -&gt; {唯一抽象函数的实现} 这个时候，我们看一下最开始的那个给 button 加 action 的例子。其实实现就是 ActionListener 这个函数式接口的唯一的抽象方法：虽然该类没有 @FunctionalInterface 注解，但是满足条件，只有一个抽象方法，所以他也是一个函数式接口，所以我们可以去使用 lambda 表达式去实现他。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[new start]]></title>
      <url>%2F2017%2F01%2F11%2Fnew-start%2F</url>
      <content type="text"><![CDATA[重新开始维护这个网站。让自己配得上这个不错的域名 movingon.cn! 我14年买了这个域名，本来想自己要好好做，实在不行，这域名也是一个不错的督促。 然而，自己维护了一段时间之后，就忘记了要去维护。 但是这一次，我用这里记录自己的技术成长以及个人感悟，作为自己的成长的记录。]]></content>
    </entry>

    
  
  
</search>
