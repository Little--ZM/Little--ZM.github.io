<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[《用户体验要素》读书笔记：要理解为何这样做产品]]></title>
      <url>%2F2018%2F03%2F15%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E8%A6%81%E7%9F%A5%E9%81%93%E8%BF%99%E6%A0%B7%E5%81%9A%E4%BA%A7%E5%93%81%2F</url>
      <content type="text"><![CDATA[《用户体验要素》是一本实用类书，试图回答如何以用户体验为中心进行产品设计。作者通过构建自下而上的五层模型：战略层，范围层，结构层，框架层，表现层；来将以用户体验用户需求为中心的设计方式层次清晰的表达出来。并指出；一开始对战略层的深思熟虑，会帮助我们在整个产品设计中节约大量的时间。 作者这本书写于pc时代，大多案例都是网站的建设。但是整个思考产品的思路，直到今天；都没有过时。 一、 以用户体验为中心设计产品用户体验是指产品如何与外界发生接触，也就是用户如何接触和使用你的产品。这并不仅仅是你的产品外观如何设计，功能如何齐全；这些细节入微的细节，都显示出你做产品最本源的想法。 你为什么要做这个产品？你是否真的想过用户的所想和所需。 一个好的产品形态并不应该是功能特性而决定，而是”用户自身心理感受与行为”所决定的。而当前；我们更多的是按照自己的喜好在做产品。 那如何以用户体验为中心设计产品呢？作者给出自己的模型答案。用户体验要素的五层设计模型 二、 五层模型五层模型，通过分解以用户体验为中心的设计过程，更好的解决产品设计的问题。从上而下分别是： 表现层：如何将框架图以合适的视觉样式展现给用户 框架层：如何将结构层的功能以符合用户使用习惯的方式在页面上呈现 结构层：范围层确定的产品功能如何转化为有层次逻辑的产品 范围层：战略层定义的产品目标和用户需求提供用那些功能承载 战略层：产品目标和用户目标；我们想做什么；想给用户提供什么；我们为什么要做 下面逐一介绍下几个层次；以及在在我个人产品经验中现实中的分工大概如何。 2.1 战略层：目标 这一部分需要项目的产品经理或者领导经过一番调研工作后确定。 做一件产品，要回答两个问题。 我们做这件产品的目标是什么？ 对应的用户需求是什么？用户能得到什么？ 我们在项目开始的初始；团队的成员就要对此有 明确 的认识。 对战略明确的认识会在后面的过程中提供一把标尺；引导我们按照正确方向走。因为我们越是明确知道用户想从我们这里获取什么，我们就能够更好的服务他们。 产品目标可以是商业目标，赚钱；可以是达到品牌宣传的目的。为了确保我们达到了目标，我们还要指定衡量的指标。 为了了解用户需求，我们就要对用户进行分析的调研。先通过市场营销的手段细分用户，找到产品真正的目标客群（这很重要；也需要很客观；避免陷入幸存者偏差）；对在对用户进行场景化分析，以确定产品真正可能使用到的场景。 最后，这些需要落成文档；简介明了并切入要点。并让团队成员清晰的了解。 需要注意的是，战略并不是不可以修改。通过后续工作的开展；可以不断的演进。 2.2 范围层：为了达成目标要提供什么 依旧是产品经理要去想的事儿 我们确认了目标，就要想想要提供哪些给用户，能满足他们的这些需求，能达到我们的产品目标。 这一层你要做三件事： 1 定义需求： 明白该做什么，不该做什么。 2 定优先级： 明白什么是必须做的，什么可以缓一下。根据战略；技术实现难度时间成本来判断 然后同样的；我们需要把这些需求点记下来；但不是精细到细节；而是将可能存在冲突的点记下来。作者提供了几个原则，值得参考： 乐观：永远描述如何防止错误的事儿，引导用户做出正确的行为，而不是描述“不应该这么做” 具体：一个功能点的具体要求要明确，因为不明确就会造成实现上的误解 客观：描述尽量使用意义明确的场景 2.3 结构层：提供的功能如何完整的结构化流程化 产品经理的活；有经验的交互有时候也会提供意见 这就好比你把一个个确定好的功能点；整理成一个层次清晰的脑图。对每一个功能点需要一个完整流程图。 对结构是否有质量的的标准是：用户是否功能的每一个步骤都是合理的。 这里我们会产出一个可以给交互设计师的文稿。 2.4 框架层： 结构层的具体化 主要由交互设计师操刀；产品把控方向 这个阶段需要将结构层的变得清晰更加实在。在我们平时的产品设计中就是让交互出原型图。（有时候；我们只有一个点子就让交互去做原型图；简直就是流氓啊） 这个阶段，需要注意让设计尽量符合用户的习惯。 要注意突出重点；让人一眼看到重点的部分。 不要为了所有人的所有偏好做设计。（这与程序员要考虑所有异常不同） 在合适的地方权衡利弊用合适的组件。 这里在平时的产品设计中会产生交互图；并交由视觉设计师；做表现层的设计。 2.5 表现层：框架层的感知化 视觉设计师主导；产品经理根据战略方向把控（你懂一些设计必要的） 将交互稿交给设计师，根据用户感知和战略方向，做出产品的最终呈现形态。视觉设计师不能仅仅考虑美学问题；也要考虑视觉设计有没有破坏产品结构，有没有帮助更好的完成战略目标。 好的视觉设计忠于眼球；用户的眼球移动路径流畅。 通过差异和一致突出页面重点内容；但又不太杂乱。 注意内部一致性（同一个页面的设计语言是否统一）和外部一致性（同一个公司的设计语言是否统一） 配色和字体排版可以有差异化；不用为了统一而牺牲设计；但差异化要用户肉眼可以分别 最终这一阶段；我们会产出视觉稿；结合之前的PRD；产出可给开发提需求的需求文档。 三、一些听起来是废话的总结这五个层面的设计是一个流程；也是一个思路。通过自下而上的设计流程，让产品设计遵循以用户为中心，先确定目标和用户需求，想清楚要为什么用户提供什么价值，再不断往上推进。保证我们不会走偏方向。在底层花的时间越多越充分，后期的流程应该越顺利，因为那些目标需求与价值都明确的记在心中。 但是科普过五层模型的人，却似乎大部分都不是这么做的。也许是他们并没有看完吧。 对于五层模型有两个注意点： 这个五个层面的设计；下层的改动一定会导致上层的设计的变动；而较高一个层的设计改动也要考虑到是否会影响到下一个层次。这种双向联动的效应是一个常识。我们要很注意。因为我们时常做到最后就忘记了我们最开始的目标是什么，或者说；因为上层的改动，已经无法实现我们最初的设想而不自知。 第二；五个层次的工作相连的部分略有重合是一种比较好的节奏；如果一味的要求我们把上一个层次的事儿的做完了；在做下一个层次的事儿；可能会导致一种你和用户都满意个割裂感。也就是说，考虑范围层面的时候，依旧可以对战略进行一定的调整。 最后；我提醒自己一直要记住：知道你在解决什么问题；并知道你为什么要这么做。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《如何阅读一本书》读书笔记：四个层次的阅读]]></title>
      <url>%2F2018%2F03%2F05%2F%E3%80%8A%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%9B%9B%E4%B8%AA%E5%B1%82%E6%AC%A1%E7%9A%84%E9%98%85%E8%AF%BB%2F</url>
      <content type="text"><![CDATA[这是一本实用性书籍。我阅读绝大部份；我没有仔细阅读的部分包括14-19章节；这些章节讲述的是如何阅读一本具体的书籍。我快速掠过；如果我以后要看到这类相似书籍再说。 这是一本教读者如何读书的书；通过四个层次的阅读；可以更好的理解一本书的内容。花费了大量的篇幅讲述了阅读一本书的第三个层次 分析阅读 15个原则；帮助抓住框架；理解内容；找到答案。并且给出了阅读不同类型书籍的方法。在你拿到一本书；不知道如何开始的时候，这是一本很好的读书指南；起码；让你不跑偏。 阅读的四个层次阅读一本书；一本好书的目的；是增加自己的理解能力。而只有一种阅读方式是真正的；就是 你什么都没有；只凭借内心的力量；慢慢提升自己；从模糊的概念；到更加清楚的理解为止。 但是；只有我们知道如何去读的时候才能真正的读懂一本书。书中将阅读分为四个层次： 1 基础阅读：能读懂一句话的文字表面意思 2 检视阅读：系统化略读；短时间抓住一本书的重点 3 分析阅读：追求理解一本书（针对好书） 4 主题阅读：比较阅读同一主题下的多本书；主动分析列举观点相同之处。 这四个层次不是循序渐进的；高层次的会包含低层次的特性。最高的层次的阅读；也就包含了所有层次的阅读特性。 基础阅读：能认得人就可以了。“我这话句说的没毛病。” 你能读懂这句话；却没在意我 “话” 与 “句” 写反了。就不用管这一个阶段了。 检视阅读： 交流前的打量这个层次需要你能够快速抓住一本书的重点；以判断这本书到底值不值得读。因为只有一小部分值得用分析阅读。 检视阅读可以分为两个部分： 第一层次： 有系统的略读或者粗读：快速的弄明白这本书的主题与架构。 重点是 主动专心；但是不花费太多的时间； 可以根据以下步骤： 书名和序言：将书本归类；这到底是一本什么类型的书 研究目录：了解一本书的地图 如果有附录中有重点索引；快速了解书中议题，找到重点主题 了解作者简介 挑几个和主题相关章节进行阅读；注意开头结尾和摘要。 随机挑选阅读；但不要太多；留意与主题相关的内容 第二层次 粗浅的阅读：重点是不停的读下去想了解一本书；如果一开始就陷入细节；会很难有有勇气读下去。所以检视阅读的重点是：不停的读下去；碰到不懂的地方也不要停下来思考与查询。从头读到尾。即使只了解全书的50%；也比半途而非什么都不了解强。 我们通过上面两个步骤就可以快速了解一本书大概的内容；但是想要读的更好；我们就要有自我要求。 提问题：四个基本问题：看完书需要回答的问题 所谓主动阅读；就是能够提出问题。 1 整体来说这本书在谈些什么 2 作者有什么论述；论点；想法等细节；都是如何表达的 3 这本书说的有道理么？全部或者部分。 4 这本书和你有什么关系？ 你是否真的需要去了解这些信息；是否还给你了其他的启发。 读懂一本书；核心就在于提出问题；然后回答或者找出作者的答案。 做笔记：能表达出来的想法；才是有意义的想法读书的时候；你要去记录你自己的想法。用语言表述出来。这可以帮助你记住作者的思想。如果你说你都知道；但是你不知道如何去表达；其实你也许根本不知道自己在想些什么。 分析阅读：与作者交流；去真正理解一本好书。作者总结了一般的规则。分为3个阶段；15个原则。很详实。 阅读一本书；就是和作者的思想的交流。所以可以从交流的角度来理解这些阶段和规则；交流在这里是广义的交流；老师上课是一种交流；同长者聊天也是一种交流。但总体可以分为以下三个部分；我听；我想；我说。 我听：了解作者想说什么？谈话性质： 区分这本书是一本理论的书还是实用性的书。或者小说与文学。因为这会决定我们用一些不同的方式（态度）去阅读（谈话）。比如这一本书；就是一本实用性著作；他有目的性；教你如何阅读一本书。你阅读完会根据是同意作者来决定是否按照作者的建议行动。 谈话主题与套路： 通过阅读能够可以用很小一段文字描述文中主线。并且列出核心的框架。 同时我们可以根据一本书的结构给出自己理解的大纲。这会比较有助于我们理解这本书。我们谈话的时候；总是会用一些开场，或者事实等去丰富我们描述的观点。所有的这些都是在让整个谈话不是特别干。但是透过这些“润色”；我们可以是整个内容脉络更加清晰的展现。 谈话目标 找到对方的目的；想要问的问题或者解决的问题；（我们要找到答案；或者自己回答） 我想：理解作者想表达的主旨；他提出的问题是否解决这一个阶段；通过抓作者的关键字；关键语句；以及一些观点的论点来找到作者想标的的主旨。这是作者的态度；也是他想传达的信息。根据他的描述；我们要找到他这么认为的前因后果。 重点就是可以站在作者的角度去理解这本书；这个时候不去评判；理解和同意 不是一个意思。 然后；我们可以判断；他在谈话目标中提出的问题；哪些已经解决了。哪些是还没解决的。 我说：读懂之前不评论；记住学习才是真理。在于作者的交流中；他是一个弱势的地位。因为他没法对你说“倾听我说完” 所以；我们要遵守思维的礼节；我们最关心的；也是善意对话最关键的；就是我们能学到些什么。除非我们真的了解了一本书；在这之前最好不要说同意与否。 当你不同意作者观点的时候；你的论述最好有理论依据。你能够证明理论是错误的这可以让你避免进入情绪的控制，而说出一些诸如“我不知道你在说什么，但你就是错了”的话来。 因为你一定要切记 赢不是目标；学习才是真理。 主题阅读：博采众议；独立思考。找出统一主题的多本书；配合阅读；列出想要了解的问题；找到多本书对相同主题的描述；进行分析讨论。这里需要注意的是；主题阅读的目标是主题；而不是全书。你需要找到不同书对同一主题的内容。 这一部分我有所体会；之前听得到的时候；各位老师分享读书经验中都有分享过；买统一类目下的两本书；对照阅读。通过客观的分析；你对相关概念会有更加深入的理解。 需要说明的是；四个层次是读一本的理想状态；现实中需要根据不同情况进行调整。不要忘了目标；是理解一本书；而不是用正确的方式读一本书。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《原则》读书笔记：知道保持开放与如何成长]]></title>
      <url>%2F2018%2F02%2F15%2F%E3%80%8A%E5%8E%9F%E5%88%99%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E7%9F%A5%E9%81%93%E4%BF%9D%E6%8C%81%E5%BC%80%E6%94%BE%E4%B8%8E%E5%A6%82%E4%BD%95%E6%88%90%E9%95%BF%2F</url>
      <content type="text"><![CDATA[这本原则最近非常火；据说创投圈的人都在读。我在得到app上听过万维钢老师的解读；也写过一些笔记。但是总觉得东西理我自己很远。于是我买回来自己再阅读一次。 在看书这件事儿上；我能看实体书还是愿意看实体书；一个是因为有读书的感觉；一个是不容易分心（因为我注意力冗余分散）；第三读书笔记记录方便。写下来比打出来记忆更加深刻。最后一个是回顾的时候很方便；你要找自己划线做特殊标记的地方太容易了~ 所以我之前的策略是电子买一本；实体书买一本；但是。。现在电子书的价格节节攀升。。还是只看实体书好了 总结（末尾还有几乎一遍一样的；但有惊喜）：整本书上半部分的重点很清晰： 1 正视现实；有方法的（5步流程）追求你想要的东西。2 通过头脑开放；认识自己的障碍；理解人的大不相同；感谢深思熟虑的意见分歧；从失败中吸取教训。问自己：“你怎么知道自己是对的呢”3 不断成长和进化；作出更好的决策；成为更好的自己。 说起来简单；然而知易行难。但即使如此；知道总是改变的第一步。 这本书最大的作用；是让我开始反思自己去年一整年的想法；做事的方法。几乎都是情绪控制着我。有一种“恍然大明白”的感觉；我真的做错了很多事，做错了很多决策。 感谢原则。保持头脑开放；继续前行。 引言&amp;个人历程重点： “独立思考；即使会犯错；保持谦虚和开放的态度” “你怎么知道自己是对的呢” “体验痛苦；从中探索自然想让你学会的东西” 看样子是鸡汤；但是当我看到后面的内容就觉得满身冷汗；说的就是如此自以为是的我的现状。 雷达里奥（下面都成为Ray）在导言中说；《原则》分为上下两部；这是第一部；主要讲述的 生活 和 工作 的原则。下一部将会是 经济 与 投资 原则。期待中。 全书一共分为三个部分 ： 第一部分是个人经历的介绍；第二部分是生活原则的描述；第三部分是工作原则的描述。我看完了前两部分；发现全书才看了一半300多页；下面还有300多页全都是 第一部分是说的个人经历：主要描述了成长；遭遇重大失败；从重大失败中吸取教训；重整桥水；并在这个过程中；逐渐形成并完善了自己的做事的原则。并整理成册。 在其中；对他打击最大的一起失误；因为过度自以为是，导致桥水破产；自己甚至筹集不到去见潜在客户的钱。痛苦无比；但也正是这次痛苦的经历，让他学会了可信度的加权决策；凡事都要多问问自己“你怎么知道自己是对的呢？” 在个人经历的最后一章节，雷达里奥说他把痛苦当做大自然的提醒；告诉他有一些重要的东西要学习。他不会为痛苦沮丧；他开始学会体验痛苦；探索自然（我觉得就是潜意识）想通过痛苦给我们什么收益。甚至开始成为他的一项游戏。 后面重点的第二部分：生活原则 生活原则：1 拥抱现实；应对现实 不要欢笑愿望与现实 不要担心自己形象；而关心能不能实现你的目标 要重视后续的结果以及后续的后续 不要让痛苦妨碍自己的进步 不要把不好归咎与任何人；从自己身上找原因 1.1 做一个超级现实的人在乎梦想；但是扎根于现实 梦想 + 现实 + 决心 = 成功的生活1.2 理解现实；是任何良好结果的根本依据因为当真相与愿望不服的时候；大部分人抗拒真相。 这种认知偏差；有很多心理学现象与之相关；如房间里的大象等。在《需求》 和 《思考快与慢中》都有过相关的论述。说到底；就是要扎根现实。理解现实，然后，改变自己；改变现实 1.3 头脑需要极度开放：头脑极度开放；极度透明有利于快速学习与改进这几乎是整个生活原则中最重要的一条原则了你头脑越是开放，越是不会自欺欺人。其他人给你的反馈就会更加诚实（“你如果是喜欢听与自己意见一样的话；就会得到的反馈就越是虚假”） 如果这些人是可信的人 ；你将会收货很多。 不要担心其他人的看法；那会成为你的障碍你必须以你认为最好的独特的方式行事；这样做一定会收到反馈；我们必须以开放的头脑思考这些反馈。 尽管你的极度透明会让你感觉到不舒服；但是这样对你是最好的。 这一点我略微保留意见~ 得看你身处的环境是否适合极度透明 极度求真，极度透明会带来更加有意义的工作和更好的人际关系1.4 观察自然；学习现实规律两种视角； 自上而下 找事务背后规律： 理解市场；供求关系；宏观大势 自下而上去验证具体情况 ： 验证具体情况是否相符合 不要固守你认为事物 “应该” 是什么样子保持客观： 不要让偏见；使我们无法认识客观情况。 当看到一个认为自然是错误的想法的时候；先假设自己是错的；然后想办法弄明白为什么自然如此是合理的。一个例子： 大草原上鬣狗吃了小幼马；我们会心生同情。但是事实上这是自然法则；自然会走向整体最优；而不是个体最优化。 人也是一样；人们会把对自己或者自己相关的人不利的事情叫做坏事；而忽略更大的好。 群体中也有这种倾向。如宗教歧视。 只根据事务对个人的影响就判断绝对的好与坏是不合理的。（这点很难做到） 一个东西要好；必须符合现实规律；并促进整体的进化；这会带来更大的好进化是宇宙中最强大的力量这里推荐一本书：《基因之河》； 关于进化：还有一本书; 《自私的基因》； 也非常开脑洞 1.5 进化是生命最大的成就和回报个人激励机制必须符合群体目标比如自然给了性行为个体巨大的快乐激励；来达到群体的不断进化迭代 现实为了趋向整体最大化；而不是个体为了整体做贡献，你就有可能收到回报。自然选择让更好产品得以保留；结果是整体的最优化。 通过快速试错以适应现实是无价的实验和适应能带来更快的进步 要意识到你即是一切；又什么都不是。并决定你想成为什么样子“个人即是一切；又什么都不是；这是一个巨大的悖论” 你的未来取决于你的视角 你的未来取决于你的如何看待事物；关心什么事物。 必须决定你多大程度将别人的利益放在你的自己利益之上 拥抱现实，从自然的角度俯视自身很美妙 1.6 理解自然提供的现实教训收益递减规律任何东西在从太少变太多的过程中；边际收益都会递减 没有痛苦就没有收获“人需要困难，这对健康来说是必须的” 1.7 痛苦 + 反思 = 进步如果以正确的态度面对痛苦；感到痛苦就是你的幸运！！ ： 即使反思痛苦 最好的就是在痛苦的当时就进行反思。 1.8 考虑后续与再后续的结果直接结果很可能是诱惑或者痛苦；如果因为直接结果的痛苦而不去做；就很难获得大的成功如果因为直接结果的诱惑而去做了；就会遭遇更大的失败 1.9 接受结果 ： 内控点在生活中不论遇到什么情况；如果你能够负起责任；进行良好的决策；而不是抱怨你无法控制的事情；你将更加容易知找到幸福 不要为喜不喜欢自己的处境担忧；你必须根据自己的愿望找到实现愿望的途径；然后 骨气勇气坚持下去后面的`五部流程会给到你一定帮助 1.10 从更高的层次腐蚀机器想想自己是一个大机器里的一个小机器；拥有改变自己而变得更好的能力通过比较你实现的结果和你的目标；你就能确定如何改进你的机器却别作为机器设计者的你和作为机器中工作者的你最难的事情是在自身所处的环境中 客观的看待我们自己；不高看自己；不承担不应该承担的任务。 擅于请教领域达人；因为你很难客观看待自己；所以你需要依赖他人的意见以及证据如果你头脑开放；足够有决心；你几乎可以实现任何愿望2 五部流程；实现你的人数愿望 1 明确目标 2 找到阻碍目标的问题；并且不容忍问题 3 准确诊断问题，找到问题根源 4 规划可以解决问题的方案 5 做一切必要的事儿来践行这些方案，实现成果 这五个步骤形成一个循环。需要注意的点是： 专注每个点；设定目标的时候就设定目标；不要想实现和出错（延迟批判） 当你诊断问题的时候；就不要想如何解决问题混淆这两个问题会导致你无法发现真正的问题 坚持这些规则；挫折；会让你难受；不完美永远存在；好消息是你可以从错误中吸收学习和成长；坚持下去你就会有收获。 2.1 有明确的目标：排列目标优先级；你几乎可以得到你想要的任何东西；但你无法得到所有东西分清目标和欲望 目标是你真正需要的东西 欲望是你想要但会阻碍你实现目标的东西（比如偷懒） 不要因为某个目标无法实现就否觉他伟大的期望创造伟大的能力 拥有灵活性和自我归咎；那没什么能组织你知道如何应对挫折很重要逆境中；重要的是守住优势；减少损失。你的任务永远是做出尽可能少的选择 吴军老师也说过；成功不难；关键在于 少犯错误 2.2 找出问题但是不容忍令人痛苦的问题待当做考验你潜在进步的机会当你遇到一个问题；那就是一个机会。 大多数人不喜欢这么做。 不要逃避问题；承认问题是改变的第一步忍痛前行；痛苦会给你汇报 不要把某个原因当做问题本身我无法得到很好的睡眠是一个原因我工作效率低是一个问题；前者可能是后者的原因。 重点解决大问题2.3 找到问题根源弄清楚问题；这需要时间去诊断一次良好的诊断一般需要 15-60分钟 区分直接与根本原因2.4 规划方案前进之前先回顾设置方案；写来来所有人都能看到；严格执行规划先于行动；好规划不应定要很多时间2.5 坚定的从头到尾执行方案2.6 保持谦逊； 与其他人高质量交流 保持谦逊；你可以从别人那里得到你需要的东西 找到你最大的弱点；并处理掉2.7 理解自己的认知；理解他人与你不同；保持谦逊提升认知能力；保持头脑开放；从他人那里获得帮助；你可以实现很多事情 3 做到头脑极度开放这一章几乎是生活原则中最重要的一章。(雷达里奥说；这也是全书最重要的一章)主要重点有两个： 一个是为什么要保持头脑开放；一个是什么情况下你是头脑封闭的认识到第二点其实很重要；这会帮助你的日常反思。 认识到自己的障碍和不足； 寻求可信度高的人的意见；设身处地思考和理解；对比自己的；最终做出更好的决策。 3.1 认识你的两大障碍障碍一：意识障碍；理解你的自我意识障碍主要是你潜意识里的防备机制； 使你难以接受你的错误和缺点。 我们有一些根植于内心的需求： 被爱 被需要 害怕死亡 害怕失去 害怕自己无意义 不能让“想要自己正确的需求 ” 压倒 “找出真相” 的需求当有人和你意见不一样；并且要求你解释的时候；你的大脑会把这样的东西当做 攻击；你会变得愤怒。 如果你想要成功；你需要克制这一点。 这样的人你也可以观察一下；身边到处都是。你也可以反思一下；你自己是不是这样的人。（怎么判断自己有这种倾向在后面会说到） 障碍二；思维障碍；理解你的思维盲点障碍人很难理解自己看不到的东西；《需求》 这本书里也有说到 塞缪尔思反射 。如果你一心只想告诉对方自己的认为正确的想法；你就是 一个头脑封闭的人 这样的话；当其他人给你展示各种可能性威胁和批评的时候；你可能会看不见。也无法领会。 3.2 奉行头脑极度开放；不仅仅是“承认自己可能错了”如果你知道自己有盲点；你就能找到一种解决办法。头脑开放不仅仅是“承认自己可能错了”；但是依旧坚持自己的观点。这样作用不大。 a. 诚恳的想想自己也许并不知道最好的解决办法是什么；能不能妥善处理“不知道”很重要很多糟糕的决定是因为他们相信自己是对的。而头脑极度开放的人知道；找到问题的答案很重要。 b. 决策有两个步骤： 1 分析所有相关信息；2 决策听听其他人的观点并加以思考；不会削弱你独立思考；自主决策的自由。只会帮你拥有更广的角度 c. 不要担心你的形象；只担心如何实现目标做出优秀决策的人；很少坚信自己已经掌握了最好的答案；承认自己有缺点 和 盲点 ；并试图了解更多；客服缺陷和盲点。 d 不吸收； 产出也不大好。e 从他人的角度；设身处地；才能评估另一种观点的价值高度接受自己错了的可能性；鼓励别人告诉自己错在哪里 f 记住；你是在寻找最好的答案；不是自己能得出最好的答案知道自己不知道；无比重要。 自问一下；我是不是只是从自己的角度看问题 g 搞清楚你是在争论还是在试图理解一个问题；根据可信度；想想哪种更加合理可信度 有两个特征； 反复的在相关领域成功找到答案（至少三次；拥有硬履历） 再被责问的情况下能对自己的观点做出很好的解释 3.3 领会并感激：深思熟虑的意见分歧沟通方式要让对方觉得：你是试图在理解你需要提问；而不是做出陈述；心平气和的进行讨论，并鼓励对方也这么做。 （某些时候）人们在产生分歧时变得愤怒是毫无意义的当讨论陷入僵局；最没效果的就是；你试图在脑子中将所有的事情都弄得清楚。 3.4 和可信的；愿意表达分歧的人一起审视你的观点既单独询问专家；也鼓励专家在我面前展现意见分歧。 为最坏的做准备。使其看起来不那么糟糕。 3.5 （重要）识别你头脑封闭的迹象a 封闭的人：不喜欢看到自己的观点被挑战不开放：会因为无法说服他人而沮丧；而不是好奇对方为何看法不同。开放： 更想了解为什么会有分歧；明白自己可能是错的 b 封闭的人：喜欢做陈述而不是提问开放的人；可信度很高的人；经常会提出很多问题。并真诚的相信自己可能是错的 c 封闭的人: 更关心自己是否被理解；而不是理解他人封闭的人： 通常担心自己没有被理解开放的人：觉得有必要从他人的视角看问题。 d 封闭的人：“我可能错了。。。但这是我的观点”这是一个敷衍的回答；人们借此来固守自己的观点最好提出一个问题；而不是做出一个断言 e 封闭的人 ： 封闭的人，阻挠别人的发言开放的人更喜欢倾听发言；鼓励表达 f 封闭的人 : 很难同事拥有两种想法同时持有两种想法；并且能保持独立思考。 g 封闭的人 ： 缺乏谦逊开放的人： 时刻担忧自己可能是错误的。 3.6 如何做到头脑开放？ 利用自己的痛苦进行高质量的思考 一旦觉得愤怒；冷静下来；以深思熟虑的方式看待眼前问题 一定要客观；愿意倾听 重视证据 冥想 4 理解人与人大大不相同 要理解：左脑思考偏逻辑；右脑思考偏情感。 要理解：最长发生的斗争就是意识与潜意识；情绪和思考的斗争。 如果你意识不到你的潜意识的存在；你的行为就会像西奥迪尼在《影响力》中做的那个比喻一样；是一个带着按钮的录音机；一按就播放。比如；听到别人反对时候的被侵犯感。 要知道：我们可以改变；通过习惯。 5 如何做出正确的决策好决策最大的敌人是坏情绪如果你被情绪绑架；你讲不可能作出好的决策。作出决策时候必须用逻辑；理性；事实。 正如荣格所说：“如果你不知道潜意识的存在；否则潜意识就会主导你的人生；而你；称之为命运” 先了解；后决策1 是什么 ：先了解决策的基础知识；既包括“是什么”；也包括宏观的因果关系 “习惯性的问自己；我在了解相关情况吗？我已经掌握了决策的所有知识了么？” 为了了解： 要知道应该问什么人 不要高估自己的可信度 不要不区分别人的可信度（在相同领域有过3次以上成功经验的硬简历） 区分事实和观点；不要听到什么信什么；别人说的和做的很可能不一样。 80/20原则：你从20%的信息获得80%的价值；明白关键性的20%是什么 不要完美主义；完美主义的边际效用是 递减的 2 怎么做 ：权衡结果；考虑结果；后续的结果；后续的后续的结果 总结：骗你的，没有惊喜；《原则》说了；别什么都信 23333。 整本书上半部分的重点很清晰： 1 正视现实；有方法的（5步流程）追求你想要的东西。2 通过头脑开放；认识自己的障碍；理解人的大不相同；感谢深思熟虑的意见分歧；从失败中吸取教训。3 不断成长和进化；作出更好的决策；成为更好的自己。 说起来简单；然而知易行难。但即使如此；知道总是改变的第一步。 这本书最大的作用；是让我开始反思自己去年一整年的想法；做事的方法。几乎都是情绪控制着我。大错特错。 感谢原则。保持头脑开放；继续前行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《需求》读书笔记：创造需求的6个关键]]></title>
      <url>%2F2018%2F01%2F25%2F%E3%80%8A%E9%9C%80%E6%B1%82%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%88%9B%E9%80%A0%E9%9C%80%E6%B1%82%E7%9A%846%E4%B8%AD%E9%AD%94%E5%8A%9B%2F</url>
      <content type="text"><![CDATA[这是一本讲需求创造者的书。书名叫 Demand ； 和我们常常说的 Requirement 是不同的，前者更加偏向于人们内心的渴求。而不是明确的索求。 创造需求的大师；就是可以想群众之想。 通过观察用户的麻烦地图，创造有魔力的产品；提供用户之前不存在的需求；并且不断精进，解决用户的烦恼。 但是书并不是一本创造需求的指导手册。他是通过一些原创的案例的分析；将创造需求的可行的以及需要注意的方向进行总结，变成6个关键点。阅读这些案例与总结；可以为我们提供一定的借鉴意义。但绝不要希望可以按照书中的内容就可以知道现实中的产品如何商业化。 创造需求；首先要做的是理解人真正创造需求的大师，会把所有的精力都投入到对 “人” 了解中。 一个人；一个问题；一个点子 我们都不了解自己的需求的时候，需求创造者 就已经看透了我们的内心，他们创造出我们无法抗拒的产品 从情绪中看需求 看出我们 不可理喻，满腔热情，焦虑苦恼，捉摸不定；我们到底需要什么，讨厌什么呢，什么样的东西能够令我们无法抗拒 从麻烦中看需求 我们真正想要的东西，和我们购买的东西之间，总有一道鸿沟； 这就是创造新需求的机会。他们认识到，人们实际购买行为和心理需求之间差异巨大 哈斯汀斯因为还录像带迟了要交罚款感到痛苦，发现了其中的麻烦，并解决。最终创造了奈飞。 诺基亚的1100 洞察了渔民的需求而大卖。 所以，优秀的需求创造者都知道以下6个关键点。同时知道如何传递这些能力给到团队里的其他人 6个关键点这6个关键点，越到值得说道的地方越少，重复性的内容与无用的描述月来越多。只用看标题；就可以大体上知道这一章的主要到底是什么。这样书来作者的总结能力还是很强的 可以说；这本书的核心是案例。脱离的案例；理论就毫无意义。可是这也是一个悖论；你的案例是来说明的你理论；但是否也可以说案例是经过挑选而展现在你的眼前的；为了证明你所说的话是正确的。 我也无法证实我的想法；因为特例总是存在的 关键1 ：魔力：创造无法割舍的情感共鸣魔力M = 卓越功能F X 情感诉求 案例： zipcar；魏格曼超市卷首语： 赢家需要创造情感共鸣；并把握市场方向 需求没有必然可言；提供用户不具备的选择 zipcar : 密度产生魔力zipcar 初始做共享汽车；理想丰满；上线后市场几乎毫无反应。尽管他拥有很好的理念；卓越的功能，但并不能形成魔力产品。因为当时车辆的距离注册的会员很远；用户用车很不方便。所以用户没有使用的动力。 公司立足的鸿沟是 ： 一遍是客户购买汽车的费用和麻烦 ； 一边是 说走就走的自由 找出现有产品的缺陷并没有用，需要有足够的魅力激发客户的激情；吸引用户的关注。 需求的关键，通常是不起眼的小事。 他走向成功的点是密度 。 在典型用户分布区域，在用车高分期进行高密度投放。同时做好营销宣传与细节的掌控，（因为需求很脆弱）可以唤醒用户的心理需求：不被一辆机械绑架的自由。 需求从来没有必然可言。zipcar 创造并满足了这一需求。 魏格曼超市；以减少麻烦为目的；关注用户的情感诉求；提供用户不具备的选择“关注行业新趋势；赶在其前面；敢于提供当时不具备的选择” 形成魔力的6大行为方式；需求创造者需要： 努力减少消除产品和服务中的不便等各种问题 魏格曼超市形成了自己的魔力；他们提供各种不具备的选择：深夜营业的药房；“没有糖果” 的收银台；儿童房间等等。 知道如何调动客户情感上的兴奋度 邀请大厨；退出廉价方便的主菜；提供菜单等等。帮助用户更加愉悦的购物 为每一位员工赋予创造需求的力量 给员工实现自己的创造需求的能力；这样员工才会主动帮助公司做的更好；比如下雨天；给客户提供撑伞到车内的服务。 敢于认真听取顾客的意见 需要孜孜不倦的实验 保护自身的特性把事情作对；比做快重要 关键2 ：麻烦地图：解决用户没告诉你的困扰可以在头脑中绘制麻烦地图；每一个引起失望的结果；都是一个个麻烦点。 “每个没有必要存在的步骤；都是摩擦点；每个摩擦点代表一个需求创造的机会”“需求；是以解决顾客问题为中心的” 苹果：一键世界的先锋 化摩擦为动力；苹果下载一首歌的点击次数是5次，而其他品牌要18 -35次。“想到李明远对百度音乐的定义： 搜得到；能下载” 绘制麻烦地图的过程中； 你需要想用户的心理活动是什么样的；他们希望从人生中获得什么？如何满足？什么样的麻烦让人用户气愤而无奈；是否存在一些；用户没发现但是我们可以解决 一键世界三大维度： 1 外观设计（奈非改了150版本信封的设计）；2 用户体验（每次微调；减少用户的麻烦）； 3 商业系统 CareCore: 协作式医疗的典范 减少麻烦；而不是减少成本。CareCore为用户提供个性化的医疗服务；费用虽然高；但是麻烦却很少；很专业。强调沟通；从用户出发。真正延长用户的寿命。 去倾听用户的声音；他们不会说出真实的动机和欲望；“比如买奔驰想让隔壁邻居看着眼红” “你只要去看，就能观察到很多情况” corecare 为病人提供免费交通的事情，大多数人都想不到 关键3 ：背景因素：那些看似与产品无关的，却决定产品的命运决定一款产品成功与否力量；常常在你看不见的地方。背景因素就是如此。它构成的基础设施与消费需求之间是相辅相成的。 案例：kindle的成功和Librie的失败。 索尼的电子墨水阅读器比kindle要早出好多年，质量和设计也都不差；却没有取得成功的关键原因是可阅读的书籍的不足。因为出版商觉得这会影响他们自己的收入，不愿提供给到索尼优质的电子书的资源。 浮田嘉孝（索尼CD机的设计师，索尼最富设计天赋的人之一）的失败就是没有观察到这些背景因素对产品成败的影响 kindle则不同；发布的当日就有88000本图书可以下载，比索尼要多的多。 贝索斯说，当自己不知道要怎么做的时候，总是问问自己：“怎么样做对用户更好？” 他也确实这么做了。例如：你再次购买一件你曾经买过的书以及CD的时候，下单的时候会弹出提示框来让你确认。 关键4 ：激发力：让潜在的需求变成真正的需求人的行为很大程度上被自己的各种情绪；偏好所左右；需求像发动机；在激发力的驱使下，一拧就着。 激发力可以让冷淡的骑墙派变得热情；并心甘情愿的变成用户 案例：奈飞；配送速度就是激发力它在增长的阶段发现了湾区的注册数字与人数都高于其他地区；讨论需求没有结果；于是，哈斯汀斯调研发现；只有一个地方不同就是 配送速度；因为奈飞的配送中心就在湾区； 高效便捷的第二天就送达的服务；就是用户兴奋的关键点 后来奈用建立配送中心的地方；注册用户数就会立刻翻倍。 关键5 ：精进曲线：缓慢改进就等于平庸快速迭代；甩开竞争者；才能成为最后的赢家案例懒得写了。。 关键6：去平均好：你不能讨好所有人，一次只满足一类客户设计满足所有人的产品；永远是浪费钱和时间。案例懒得写了。。 产品发布：避免阿克琉斯之踵全书我觉得最值得读两遍的一整节；虽然读下来很有一种心理学与行为经济学的混合。（如果你读过思考快与慢，就不用读第二遍了。）但是一切需求；最终都要回归到人本身。所以更好的了解我们，了解群体，总是有好处的。 用数据说话 做一个现实的人。 决定产品发布成败的是人的思维方式。正确的思维方式是用数据说话；俗话说眼见为实；但是 塞默尔斯反射 却直接指出人性弱点：仅仅凭借数据并不能改变现状；很可能没有人会相信你说的话。（只有我信以为实，才能看得见）；强烈的信念和客观数据之间的竞赛；数据永远是输家 想起三本书：《影响力》；告诉我们如何去影响别人的六大武器。如果塞默尔斯知道，也不会英年早逝。《思考快与慢》《原则》一个告诉我们人们思考问题的误区与人性；一个告诉我们要保持极为开放的头脑；时刻反思；我怎么知道我是正确的呢？ 以防止我们陷入同样的陷阱中。 做事前检查预期性后见之明： 沃顿商学院的米切尔与康奈尔大雪的拉索以及科罗拉多大学的彭宁顿研究发现；想象某个事件已经发生会让你 预见结果、分析能力提升30% 《能量之源》的作者盖里·克莱恩人文： 事前分析能让人们表达心中焦虑；如果没有这样的机会；人们倾向于隐藏；担心表现出来之后会显得自己不忠实；或者打击团队信心。 想象灾难发生；问问自己为什么失败了，将所有可能的失败列出来；尽你所能去避免这些失败。 一个案例值得说的思维方式转变的案例：监管局不是敌人；而是重要客户著名制药公司默克公司采取不同的态度对待FDA； 将他看成客户； “这位重要的客户在做决策的时候，需要哪些信息” 而尽力去提供；而不是“怎么不惹麻烦而绕开监管局” 如此依赖，他们的审批就比其他的公司快很多]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[kotlin学习2 kotlin的编译与反编译以及与java的关系]]></title>
      <url>%2F2017%2F10%2F14%2Fkotlin%E5%AD%A6%E4%B9%A02-kotlin%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E4%BB%A5%E5%8F%8A%E4%B8%8Ejava%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
      <content type="text"><![CDATA[这篇文章主要描述 kotlin 的简单编译与反编译的流程。以及与 java 的关系。之前说到 kotlin 是一个静态的代码语言。他也是需要编译的。需要编译就有编译器；而他和java又是可以相互调用的。所以隐隐约约感觉应该编译出来的东西和应该也和java 相关；下面就来看一下。 下载安装编译器方式在官网上都有；我这里选择的是下载压缩包；你通过sdkman；homebrew等安装当然都是 ok 的。官网链接 点我大帅比。 下载完之后，解压，配置好路径；如下：退出；source 一下你的bashrc或者zshrc 文件；而后验证一下 如此一来，你的编译器就安装好了。下面就是测试。 编译与运行kotlin文件首先；vim 编写一个简单的 hello world 文件 HelloKotlin.kt； 123fun main(args:Array&lt;String&gt;) &#123; println("Hello World")&#125; 第二：编译与运行；与 java 类似；kotlinc HelloKotlin.kt 编译； 运行 kotlin HelloKotlinKt 执行；如下图。 这里需要注意的是；编译的时候产生的文件如下：一个 class 文件；以及一个配置文件的文件夹。这个 class 文件就是我们执行的文件；而编译器在文件末尾加上了 Kt 两个字母用于标记这个Kotlin 的编译文件。 反编译 class 文件既然是 class 文件；可以和java相互执行；javap 反编译一下看看 class 文件的结构。因为kotlin 文件中；我们是没有指定类的；那在class 文件中，一定是会生成类的；否则就和 java 的基本逻辑产生了冲突。我们看一下： 可以反编译的更加彻底一点看下方法内部实现；命令是 javap -c可以看到；调用的都是 java 内部的方法。 打包成jar既然是在 jvm 上运行；一定是可以打成 jar 来执行的；kotlinc 提供了支持。1kotlinc HelloKotlin.kt -include-runtime -d HelloKotlin.jar -include-runtime 是将 kotlin 运行时所需要的包都包含进去的参数。 而后就可以用 java -jar 来执行。得到一样的结果 总结：以上说了如何编译和反编译kotlin 以及如何打成 jar 包运行。当然了一般情况下我们用不到这么麻烦，intellij 提供了很好的支持，但这有助于帮助我们理解 kotlin 与 java 的关系。也有注意我们更好的学习 kotlin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[kotlin学习1 为何学习kotlin]]></title>
      <url>%2F2017%2F10%2F14%2Fkotlin%E5%AD%A6%E4%B9%A01-%E4%B8%BA%E4%BD%95%E5%AD%A6%E4%B9%A0kotlin%2F</url>
      <content type="text"><![CDATA[1 为何使用kotlin 这是一门强势技术 语言那么多；不可能什么语言都学习。学习的一定是要有支撑有前景的语言。比如苹果的swift；即使是有呢么多问题；但是由于有苹果的背书 他可以和java进行相互的调用 他解决了java无法通过迭代解决的问题 已经成为安卓的官方支持语言，发展前景很好 spring5 也提供了对kotlin的原生支持 官方文档齐全好用 http://kotlinlang.org/docs/reference/basic-syntax.html可执行 1.2 kotlin 的特点 简洁；一行代码解决所有 getter 和 setter; it 语法糖等等 安全；使用 optional 避免NPE 相互操作；兼容所有jvm 和 Android的第三方库 良好的工具支持 2 简单代码示例通过 intellij；新建一个 kotlin 的项目；新建一个 kotlin 文件； 官网上有清晰的教程： http://kotlinlang.org/docs/tutorials/getting-started.html 1234567891011121314151617181920212223package com.zhumin.kotlin.demoimport java.util.function.Consumerfun main(args: Array&lt;String&gt;) &#123; print(&quot;hello world&quot;) val list : List&lt;String&gt; = listOf(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;) // 遍历 for(str in list) &#123; println(str) &#125; println(&quot;--------------------&quot;) list.forEach (Consumer &#123;println(it)&#125;) println(&quot;--------------------&quot;) list.forEach(System.out::println)&#125; 可以看到引入的是java中的包；对consumer的用法和java8也几乎是一模一样。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Netty 对 WebSocket的简单实现与剖析]]></title>
      <url>%2F2017%2F06%2F07%2FNetty-%E5%AF%B9-WebSocket%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%89%96%E6%9E%90%2F</url>
      <content type="text"><![CDATA[本文主要描述 netty 对 WebSocket 的支持。并编写一个简单 demo; 对 WebSocket 的内容做了简单剖析。 通过文章会了解为何 WebSocket 是 HTTP 协议升级而来； netty 是如何实现对他的支持等。 WebSocket 的由来HTTP 协议的问题HTTP 协议无状态，为了保持状态，引出了 session &amp; cookies等技术。 HTTP 是基于 请求 和 响应 的，请求一定是客户端发出的。（1.1 还有 keepAlive, 持续连接，在一定时间可以进行连接的复用。） 导致的问题， 服务器无法推送数据。所以早期有客户端轮训技术。会导致资源和网络带宽的浪费。因为 Header 数据每次都要构建。 WebSocket 可以做到什么？WebSocket 来自 Html5; 所以是 HTTP 协议的一个升级版本 协议可以建立浏览器和服务器之间的长连接。 可以实现服务端的push 只需要在一开始建立连接的时候构建 Header；其他时间都不需要再有 Header 信息 因为是基于 HTTP 的，所以建立连接的时候，发的请求是一个标准的 http 请求。只不过是在 Header 中添加了信息。 虽然是基于 Http 的，但是不仅仅在 浏览器上使用也可以通过第三方的工具包在 app 端使用 netty 对 webSocket 的简单实现netty 功能众多，可以实现对 HTTP 的支持，可以实现高性能异步 RPC 的功能。同样，他也支持对 WebSocket 的支持。 虽然用过 netty 的人都说 netty 复杂，但是他无论简单和复杂的应用，写起来都是样的复杂，这样一来平均一下，只要你了解了规则，还是比较简单的2333 netty 实现 websocket 服务端三个步骤 Server Initializer Handler Server因为你无论写什么 Server 都基本是这个套路：贴代码 12345678910111213141516171819202122232425/** * 这个示例主要用来阐述 * netty 对于 WebSocket 连接的支持 * 以及如何写一个简单的WebSocket demo */public class WebSocketServer &#123; public static void main(String[] args) throws Exception &#123; EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new WebSocketChannelInitializer()); ChannelFuture channelFuture = serverBootstrap.bind(new InetSocketAddress(8899)).sync(); channelFuture.channel().closeFuture().sync(); &#125; finally &#123; bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); &#125; &#125;&#125; 这里简单解释下为什么有连个 group; 其实一个也没有问题。如果你才会用两个 group；那么 bossGroup 负责接收请求；而 workerGroup 负责处理请求 Initializernetty 的各种复杂功能都是由各个 handler 实现的，实现 WebSocket 也是如此。没啥好说的，贴代码，看注释。 12345678910111213141516171819202122public class WebSocketChannelInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); // 因为是基于HTTP 协议之上的，所以需要使用到 HTTP 的编解码技术 pipeline.addLast(new HttpServerCodec()); // 按照块来写数据 handler pipeline.addLast(new ChunkedWriteHandler()); // http request 和 response 的一个聚合类 // netty 会对http 请求做分段的处理；所以在第一个 http 的示例中，有些会调用多次 pipeline.addLast(new HttpObjectAggregator(8192)); // web socket netty 的特殊支持 // 其中 "ws" 是指的是 websocket 协议路径 // 通常形式 ws://localhost:8899/ws // 8899/ws 后面的 ws 就是我传入的 /ws 路径。 pipeline.addLast(new WebSocketServerProtocolHandler("/ws")); // 插入自定义的 TextWebSocketFrameHandler pipeline.addLast(new TextWebSocketFrameHandler()); &#125;&#125; TextWebSocketFrameHandlerWebSocket 协议的传输是是以 Frame 作为单位的。这里我们处理的是 Text 这种类型的 Frame。传统，贴代码： 12345678910111213141516171819202122232425public class TextWebSocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception &#123; System.out.println("接受到消息：" + msg.text()); // 这里我们接受客户端传来的消息，返回我们当前时间 ctx.writeAndFlush(new TextWebSocketFrame("服务器时间：" + LocalTime.now())); &#125; @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123; System.out.println("连接建立 : " + ctx.channel().id().asLongText()); &#125; @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123; System.out.println("连接断开 : " + ctx.channel().id().asLongText()); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; System.out.println("出异常"); ctx.close(); cause.printStackTrace(); &#125;&#125; Frame 一共有六种，我们可以从类的继承上看六种分别有不同的用途，从字面上都比较容易理解至于为什么是六种？ 那是因为 WebSocket 协议就是这么规定的。 简单的网页客户端为了方便，我们就只用简单的 JS 来进行 WebSocket 的调用 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script type="text/javascript"&gt; var socket; // 判断浏览器是不是支持 if(window.WebSocket) &#123; socket = new WebSocket("ws://localhost:8899/ws") socket.onmessage = function (event) &#123; var ta = document.getElementById("responseText"); ta.value = ta.value + "\n" + event.data &#125; socket.onopen = function (event) &#123; var ta = document.getElementById("responseText"); ta.value = "连接开启" &#125; socket.onclose = function (event) &#123; var ta = document.getElementById("responseText"); ta.value = "连接关闭" &#125; &#125; else &#123; alert("浏览器不支持 WebSocket") &#125; // 发送消息 function send(message) &#123; if(!window.WebSocket) &#123; return; &#125; if(socket.readyState == WebSocket.OPEN) &#123; socket.send(message) &#125; else &#123; alert("连接尚未开启") &#125; &#125;&lt;/script&gt;&lt;form onsubmit="return false;"&gt; &lt;textarea name="message" style="width: 400px; height: 200px"&gt;&lt;/textarea&gt; &lt;input type="button" value="发送数据" onclick="send(this.form.message.value)"/&gt; &lt;h3&gt;服务端输出：&lt;/h3&gt; &lt;textarea id="responseText" style="width: 400px; height: 200px"&gt;&lt;/textarea&gt; &lt;input type="button" value="清空数据" onclick="javascript: document.getElementById('responseText').value=''"/&gt;&lt;/form&gt; 测试 启动服务器： 启动客户端 简单的做发你可以在 IntelliJ 中直接运行 html 他会帮你起一个服务。或者你可以用 Python 1python -m SimpleHTTPServer 8080 我采用第一种： 客户端显示连接已经建立 此时，你可以在服务器端看到我们要打出的信息 然后你可以通过客户端给服务器发送消息：比如我发送 敏哥好帅还用你所？ 服务端会收到： 客户端也会收到服务端的时间： 至此，我们可以的这个例子就成功运行了，你停止服务器会看到客户端输出 连接关闭； 你关闭客户端，会看见服务端输出 连接断开。 更近一步，基于 frame ? 基于 http ?基于 frame 的信息传递刚刚说到，WebSocket 在建立长连接后，不需要在传递头信息。我们可以代开 Chrome 的控制台看一下： 我们能看到的是 ws 的连接的信息里有个 Frames 的标签，你传输的信息都在这里。 WebSocket 连接是基于 HTTP 升级的？我们可以刷新一下你的客户端的网页，观察下 network 的输出： 注意看出了 js 之外的连个请求：第一个就是基本的 http 请求，状态的 304 重点在看一下下面的 ws , 他是一个 WebSocket 请求： request 中还有一个1Upgrade:websocket 的内容，就是它将协议由 http 协议升级成为了 websocket 协议。所以就是这么回事 所以，websocket 需要浏览器的支持。 环境 jdk8 netty 4.1.10.Final gradle]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[老妈的生活哲学]]></title>
      <url>%2F2017%2F05%2F07%2F%E6%9C%B1%E8%80%81%E5%B8%88%E4%B8%8E%E8%80%81%E5%A6%88%E7%9A%84%E7%94%9F%E6%B4%BB%E7%BB%86%E8%8A%82%2F</url>
      <content type="text"><![CDATA[最近家里人感冒的多，姐姐的双胞胎，小的那个被我们带到舅舅家。 中午，我去我妈那里; 我：老妈，今晚舅妈有事儿，我带小宝贝，你给我送点饭。 老妈：你中午剩的饭你热热就好啦。 我 ： 。。。那我叫外卖。。 老妈 ： 那我也去吃 😌 – The End –]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux 上搭建 Anaconda, 远程访问 juypter]]></title>
      <url>%2F2017%2F05%2F05%2FLinux-%E4%B8%8A%E6%90%AD%E5%BB%BA-Anaconda-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE-juypter%2F</url>
      <content type="text"><![CDATA[1 什么是 AnacondaAnaconda 能让你轻松安装在数据科学工作中经常使用的包。你还将使用它创建虚拟环境，以便更轻松地处理多个项目。Anaconda 简化了我的工作流程，并且解决了我在处理包和多个 Python 版本时遇到的大量问题。 Anaconda 实际上是一个软件发行版，它附带了 conda、Python 和 150 多个科学包及其依赖项。应用程序 conda 是包和环境管理器。Anaconda 的下载文件比较大（约 500 MB），因为它附带了 Python 中最常用的数据科学包。如果只需要某些包，或者需要节省带宽或存储空间，也可以使用 Miniconda 这个较小的发行版（仅包含 conda 和 Python）。你仍可以使用 conda 来安装任何可用的包，它只是没有附带这些包而已。 除了管理包之外，conda 还是虚拟环境管理器。它类似于另外两个很流行的环境管理器，即 virtualenv 和 pyenv 环境能让你分隔你要用于不同项目的包。你常常要使用依赖于某个库的不同版本的代码。例如，你的代码可能使用了 Numpy 中的新功能，或者使用了已删除的旧功能。实际上，不可能同时安装两个 Numpy 版本。你要做的应该是，为每个 Numpy 版本创建一个环境，然后在适用于项目的环境中工作。 在应对 Python 2 和 Python 3 时，此问题也会常常发生。你可能会使用在 Python 3 中不能运行的旧代码，以及在 Python 2 中不能运行的新代码。同时安装两个版本可能会造成许多混乱和错误。而创建独立的环境会好很多。 也可以将环境中的包的列表导出为文件，然后将该文件与代码包括在一起。这能让其他人轻松加载代码的所有依赖项。pip 提供了类似的功能，即 1pip freeze &gt; requirements.txt。 2 为什么使用 conda 而不是 virtualenv? 3 安装过程1 下载 ，上传到机器你也可以在机器 wget 1https://repo.continuum.io/archive/Anaconda2-4.3.1-Linux-x86_64.sh 2 安装1sh Anaconda2-4.3.1-Linux-x86_64.sh 选择安装目录。为了节约 根目录空间，安装在 12# 目录事先必须不存在/data/min.zhu/anaconda2 下面 source 一下 .bashrc 1source ~/.bashrc 3 设置国内Anaconda源1234# 添加Anaconda的TUNA镜像conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/# TUNA的help中镜像地址加有引号，需要去掉# 设置搜索时显示通道地址conda config --set show_channel_urls yes 4 安装需要的环境比如安装 3.5 的python 1conda create -n lr3 python=3.5 激活 1source activate lr3 之后进入虚拟环境 可以在通过 conda 进行包的管理 1conda install xxx 5 修改 pip 源为阿里源因为有些包点评直接就没有 比如 tflearn 和 tensorflow 123vim ~/.pip/pip.conftrusted-host=mirrors.aliyun.comindex-url=http://mirrors.aliyun.com/pypi/simple/ 6 远程juypter 访问首先，不建议使用root , 当你使用 root 的时候，需要使用如下方法。 1jupyter notebook --allow-root 第二，远程服务器访问需要做一些配置 可以参考如下文章 1http://blog.leanote.com/post/jevonswang/远程访问jupyter-notebook 进行配置 4 管理环境如果你安装了多个环境，但是不记得名字，或者想修改的话，通过 conda-env 这个命令就可以看到你所有的环境了。 可以看到附带所有操作 比如 conda-env list 就是查看所有命令的格式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CentOS 6.x 如何升级 glibc 2.17]]></title>
      <url>%2F2017%2F05%2F05%2FCentOS-6-x-%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7-glibc-2-17%2F</url>
      <content type="text"><![CDATA[引子本文描述如何在 CentOS 6.x 升级蛋疼的 glibc 2.17. 学习机器的内容，需要用到 tensorFlow, 在自己 Mac 上跑太心疼了。 于是尝试在公司的测试机上跑。然而我搭建好 conda, jupyter notebook , 引入 tf 的时候报错。（关于如何 安装科学计算环境，以及远程访问 jupyter notebook, 请看下一篇文章） 如下 在一看机器上的情况 最高只有 2.15 其实已经是运维升级过了的，默认只到 12。主要还是我们的系统版本太低。 CentOS 7.X，GLIBC 已经到 2.17，GCC 也是 4.8.5但是对于公司来说，稳定是第一位的。所以。。。 如何安装两种方法，一种源码编译，一种是用 rpm 来安装，之前看到这篇文章点这里，其实说的还蛮好的，但是只是升级到 2.15， 而最新的 tf 1.1 版本，需要 2.17 的版本。 其实问题最大的就是找不到给 CentOS 6.x 用的 2.17 的 rpm 包，直到今日，我搜到了有人昨天发布一段脚本，才算找到了解决方法，直接给链接 感激万分的点这里 你不愿点看，我就写下来： 12345678910111213#! /bin/sh# update glibc to 2.17 for CentOS 6wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpmwget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpmwget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpmwget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpmsudo rpm -Uvh glibc-2.17-55.el6.x86_64.rpm \glibc-common-2.17-55.el6.x86_64.rpm \glibc-devel-2.17-55.el6.x86_64.rpm \glibc-headers-2.17-55.el6.x86_64.rpm 其实就是下载资源，然后用 rpm 安装。 可能遇到的错误当你执行 1234rpm -Uvh glibc-2.17-55.el6.x86_64.rpm \ glibc-common-2.17-55.el6.x86_64.rpm \ glibc-devel-2.17-55.el6.x86_64.rpm \ glibc-headers-2.17-55.el6.x86_64.rpm 的时候会报错 解决方案：命令结尾加上参数 1--force --nodeps 原因可以看这篇文章 点这里，造成这个问题的主要原因是套件被重複 (强制) 安装了两次以上. 可以用上面的命令进行依赖忽略，也可以卸载。 总结 搜索的关键词真的很重要，谷歌很重要，英语很重要。 运气很重要(这个问题折腾我两个礼拜) 别用百度搜技术问题。 还有，如果你手动编译安装glibc。。。。万一你安装失败就会导致系统各种命令无法执行。。千万别退出。。你一旦退出，就无法登陆了，只能用光盘恢复系统了。。 但是这篇文章里的方法，可以试一试 解决方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8 一个颠覆了面向对象认知的例子]]></title>
      <url>%2F2017%2F05%2F03%2Fjdk8-%E4%B8%80%E4%B8%AA%E9%A2%A0%E8%A6%86%E4%BA%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%A4%E7%9F%A5%E7%9A%84%E4%BE%8B%E5%AD%90%2F</url>
      <content type="text"><![CDATA[1 起源如果你看了上一篇文章关于 Spliterator 分割迭代器，最后一部分说到了图中的两个强制转换逻辑的不合理之处。 第一处，我传入的是一个 Consumer 接口，但是判断的情况却是判断 1action instanceof IntConsumer 而 IntConsumer 和 Consumer 是没有继承关系的平行函数式接口。这样的转换为何会成功？ 第二处，当第一个判断条件不满足的是时候，使用（IntConsumer）强转 lambda 表达式，这样为何能成功被需要传入 IntConsumer 函数所接受呢？ 如下图： 2 尝试解释看看喽先看第二处：lambda表达式也可以强转？我们先写一个类似的例子，有一个需要传入 Consumer 的方法，我们尝试传入一个 IntConsumer 会发生什么情况。 1234567891011121314151617public class ConsumerTest &#123; public void test(Consumer&lt;? super Integer&gt; consumer) &#123; System.out.println(consumer instanceof IntConsumer); consumer.accept(100); &#125; public static void main(String[] args) &#123; ConsumerTest consumerTest = new ConsumerTest(); Consumer&lt;Integer&gt; consumer = i -&gt; System.out.println(i); IntConsumer intConsumer = i -&gt; System.out.println(i); consumerTest.test(consumer); // 面向对象的方式 consumerTest.test(consumer::accept); // 函数式的方式 consumerTest.test(intConsumer::accept); // 函数式的方式 &#125;&#125; 这个例子的输出结果是： 我们发现这三种传入方式都是可以的，第一第二种没什么好说的，因为 Test 方法就是需要传入一个 Consumer， 无论你使用原来传递对象的方式，还是通过方法引用的方法，都是没有问题，可以被执行。 问题在于，第三种方式 1consumerTest.test(intConsumer::accept); // 函数式的方式 当你按住 command 把鼠标放在双冒号的时候 出现的如下： 当你按住 command 把鼠标放在的 accept 时候 出现的如下： 双冒号代表是的当前 lambda 表达式的类型。因为你看我初始化两个consumer的代码 12Consumer&lt;Integer&gt; consumer = i -&gt; System.out.println(i);IntConsumer intConsumer = i -&gt; System.out.println(i); 我后面的表达式是一模一样的。但是却可以赋予两个不同的类型。所以，重点来了 重点是 lambda 表达式的类型，是要靠上下文进行推断的。 这个是和传统面向的编程不一样的地方。需要注意。刚刚上面的第三种调用的方式，就是如此，编译器推断出，你这个 lambda 表达式 intConsumer::accept 肯定是 Consumer&lt;T super Integer&gt; 类型的。所以不报错而这个时候如果你前面加一个强制转换，就像文章一开始的那张图的第二个强转逻辑一样，也是可以的。不过，略显多余就是了。 在看第一处那么什么情况下，才会出现第一种情况，传入的是 Consumer ，但却同时是 instanceof IntConsumer 呢？ 对了！（对什么对，你又没想到）就是这样，你同时继承者两个接口就可以了呀！ 上代码！ 123456789101112131415161718192021222324252627282930313233343536/** * Created by charleszhu on 2017/5/2. */public class ConsumerTest &#123; // 要求传入 Consumer public void testInt(Consumer&lt;Integer&gt; consumer) &#123; // 判断是否为 IntConsumer System.out.println(consumer instanceof IntConsumer); consumer.accept(100); &#125; public static void main(String[] args) &#123; ConsumerTest consumerTest = new ConsumerTest(); consumerTest.testInt(new MyConsumer2&lt;&gt;()); &#125;&#125;/** * 同时实现两个方法 * @param &lt;Integer&gt; */class MyConsumer2&lt;Integer&gt; implements IntConsumer, Consumer&lt;Integer&gt; &#123; public void accept(int value) &#123; System.out.println(value); &#125; public void accept(Integer t) &#123; System.out.println(t); &#125;&#125; 运行一下结果： 就可以发现，这个时候就和开头的那个例子中的，第一处转换： 需要传入的是 Consumer, 但是也是 IntConsumer 的实例，就会进入第一个判断了 至此两个强转就解释完毕了！ 总结这个例子想给大家说的就是函数式接口的很传统的命令式编程还是有一定差别的。尤其是 lambda 表达式的类型是要靠上下文推断的这一点，需要好好的理解~ 只有慢慢理解这些，才能真正理解函数式编程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8 Stream 解析2 - Spliterator分割迭代器]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk8-Stream-%E8%A7%A3%E6%9E%902-Spliterator%E5%88%86%E5%89%B2%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
      <content type="text"><![CDATA[概述说完Stream 的一些源码解析。我们看下我们的 Stream 是如何产生的。我们最为常见的流的产生方式是 collection.stream(), 你点开Stream()方法, 他是通过 Collection 这个上层接口两个java8 新增特性 default method 进行实现。 这就牵扯到一个关键要点 Spliterator ：分割迭代器。 本文主要描述 Spliterator 的作用，大部分来源于你不愿意读的 JavaDoc。 Spliterator 是 jdk8 非常重要的概念。里面的细节很值得学习玩味。 Spliterator 冗长的JavaDoc 说了什么？基本介绍Spliterator 是一个对源（数组，集合，io流等等）中元素进行遍历和分区的类。 可以通过 tryAdvance() 方法逐个遍历，也可以按照 forEachRemaining() 方法进行按 bulk 逐块的遍历。（内部调用的还是tryAdvance） Spliterator 有类似 Collector 中的 characteristics , 但都是由十六进制来表示的。 SIZED :表示大小固定, Collection常用 DISTINCT : 去重, Set常用 SORTED : 有顺序的 SortedSet 会用等等 原生类型的特化版本特化分割迭代器也被提供，和Stream类似。减少装箱和拆箱的操作 比迭代器Iterator 更加高效的遍历元素的方式提供更加高效的方法，进行数据的迭代。Iterator 的使用需要调用两个组合方法 hasNext() 以及 next() ，同事在多线程访问的情况下还会出现竞争，你需要去同步。而分割迭代器 Spliterator 使用函数式编程的方式，只用一个方法就可以做到这个两个函数动作。就避免了竞争 ，就是 tryAdvance() 方法。后面会介绍 Spliterator的接口方法tryAdvance()同时做了 hasNext() 以及 next() 的工作。 1234/*** 对给定的元素进行判断，如果满足条件就会执行 Action*/boolean tryAdvance(Consumer&lt;? super T&gt; action); forEachRemaining()是一个默认方法，对余下的元素进行操作，直到元素全部被遍历完一般情况下回直接调用上面的tryAdvance() 方法，但是也可以更具需要进行重写。1234567/*** 对余下的元素进行操作，直到元素全部被遍历完* 如果源是有序的，遍历也是有序的*/default void forEachRemaining(Consumer&lt;? super T&gt; action) &#123; do &#123; &#125; while (tryAdvance(action));&#125; 这里有一点很值得注意，方法体中的 do {} 是空的，这个是因为 tryAdvance() 方法本身就完成了两个操作 hasNext() 以及 next()，所以方法体中不需要有任何操作了。这个是 函数式编程带来的好处。以及与命令式编程的区别。 trySplit()尝试切分源来的 Spliterator， 返回的是（注意！！！）返回的是 分割出来的那一部分 数据，原有的数据集将不在包含这部分数据集合。两者 没有交集。剩下的可以继续分割，也许不可以继续分割了 举个例子，我原来有 100个元素，我通过 trySplit 切分出 30 个，作为一个新的 分割迭代器 返回，原有的，就还剩下 70 个。 如果是原有数据集合是 ORDERD 的，分出来的也是有序的。 除非元素数量是无穷的，否则，最后一定会出现不能在分割的情况，这种情况下，返回的结果是 null 1Spliterator&lt;T&gt; trySplit(); estimateSize()估算集合剩余给forEachRemaining大小，不一定精确。但是如果这个 Spliterator 是 SIZED，没有被遍历或者 split， 或是 SUBSIZED的，没有被遍历，那么他这个值一定是准确的。 1long estimateSize(); 还有个与之相关的默认方法，就是利用这个特性。123default long getExactSizeIfKnown() &#123; return (characteristics() &amp; SIZED) == 0 ? -1L : estimateSize(); &#125; characteristics()表示集合的特性，一共8个。 分割之前，返回的结果都是一致的 如果返回结果不一致，则操作是不受保证的 而分割之后，不保证一致 有一个默认方法用于判断 Spliterator 是否包含这个特性123default boolean hasCharacteristics(int characteristics) &#123; return (characteristics() &amp; characteristics) == characteristics; &#125; getComparator如果源是SORTED 类型的，且有比较器 Comparator 的话，则返回这个 Comparator，如果是SORTED 类型的，但是没有比较器，则返回 null , 除此之外，都抛出异常 接口的默认方法里，就是抛出了异常 123default Comparator&lt;? super T&gt; getComparator() &#123; throw new IllegalStateException(); &#125; Spliterator的8个Characteristics 特性ORDERED源的元素有序，tryAdvance ，forEachRemaining和 trySplit 都会保证有序的进行元素的处理 需要注意 hashSet 这类 Collection 是不保证有序的 有ORDERED 特性的数据，在并发计算的时候客户端也要做顺序限制的保证 DISTINCT太简单，唯一性。 类似 Set 这样的传入集合会拥有这样的特性 SORTED有这种特性的 Spliterator ，有一个特定的顺序。或者是所有元素都是可比较的，或者是有特定的比较器。 有 SORTED 一定会有 ORDERED SIZED有这种属性的 Spliterator 在遍历和分割之前，estimateSize() 返回的大小是固定的，并且是准确的。 NONNULL不为 NULL, 大部分并发的集合，队列，Map 都可能会有这样的特性。 IMMUTABLE不可变的。元素遍历期间不可以被 添加，替换，删除（cannot be added, replaced, or removed）否则，应该抛出异常。 CONCURRENT支持并发操作的。 顶层的 Spliterator 不可以 CONCURRENT 与 SIZED。 这两者是相互冲突的。 但是分割之后的 Spliterator ， 可能是 SIZED， 顶层不能决定底层 SUBSIZED从trySplit()被分割后的所有分割迭代器都是 SIZED 以及 SUBSIZED 的。如果分割后，没有按照要求返回SIZED 以及 SUBSIZED 属性，那么操作是不被保证的，也就是结果不可预测。 这个属性和 SIZED 的区别就是， SIZED 不保证 SUBSIZED。而 SUBSIZED 会要求保证 SIZED 内部特化而做的函数式接口 (OfPrimitive)除了上面的函数，以及特性，Spliterator 迭代器中，还有几个定义在内部的接口。 OfPrimitive 重载了（overloads）了 Spliterator 的方法。用于实现特化的分割迭代器。 overloads：返回类型名称一致，参数不一致。注意与 override 的区别 一个颠覆面向对象编程常识的现象请大家看图 这两次类型转换奇怪的地方是： IntConsumer 与 Consumer 两个接口，没有继承关系，两个接口是平行的。 这样的转换，在之前是不可能成功的。 简直是颠覆认知啊！ 我悄悄说啊（并没有。。你也基本不会关心不是么。。） 但是在函数式编程中能转换成功呢？ 你可以等我下一篇文章~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8 Stream & BaseStream 源码难点浅析1]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk8-Stream-BaseStream-%E6%BA%90%E7%A0%81%E9%9A%BE%E7%82%B9%E6%B5%85%E6%9E%901%2F</url>
      <content type="text"><![CDATA[概述 简要介绍 Stream 的 javadoc，与集合的关系以及区别，一些重要的注意事项 难懂的 Stream 类的声明，介绍比较难懂的 onClose() 方法的调用 Stream的javadocStream 的作用与特化版本Stream 是对一个序列做 串行 或者 并行 聚合操作。他继承自 StreamStream 同时还有几个特化的版本 ，IntStream , LongStream, DoubleStream. 他们为了减少流操作的时候一些不必要的装箱和拆箱的操作。 需要注意的是，以上四个 Stream 是平行关系，他们都是继承自 BaseStream 举个简单的例子： 12345678910/*** 将集合 widgets 中的元素中红色的元素的重量求和* 第一步 filter() 过滤红色* 第二步 mapToInt() 拿出所有的Red的重量，生成一个 IntStream* 第三步 sum() 求和，并返回*/int sum = widgets.stream() .filter(w -&gt; w.getColor() == RED) .mapToInt(w -&gt; w.getWeight()) .sum(); Stream 的组成与特点要想实现计算，所有操作，都会被放入一个 pipeline 当中（类似liunx）中的操作。 而一个流管道（pipeline）包含： source(源)： 数组，集合，迭代器，I/O 操作等等 0个或者多个中间操作： 将一个流转成另外一个流 1个终止操作 : 产生一个结果(比如上面的例子中的求和) or 或者修改传入对象的属性。 流是Lazy的懒惰的！！ 你不加 终止操作 流的操作，就不会被执行。如上面的例子，没有最后的 Sum() 函数，前面的操作是不会被执行的。 集合和Stream 的区别集合： 注重存储，主要考虑元素的访问与管理Stream ：注重计算，主要考虑以一种描述性 的语言来对源进行一系列的操作，并将操作聚合起来。 流的注意事项1 流中的操作，都应是函数式接口（lambda表达式或者方法引用）2 流不能被重用，每个流只能应用一次。想再次操作你需要重新生成一个流 3 流虽然实现了 AutoCloseable 接口，但是几乎所有的流都是不用关闭的，因为他的源大部分情况下都是集合，而集合是不用关闭的。 除非源是一个 I/O Channel。 比如 Files.lines() 方法。如果是这样，Stream 就可以申明在 try-with-resources block 中。关于这个 j7 新接口的使用，可以看我之前的一篇关于 AutoCloseable 的介绍 jdk1.7新增自动关闭接口AutoCloseable 多说一句，Files.lines() 是 j8 中新增的方法，有点类似 python 中 readlines() 方法。很好用。 Stream &amp; BaseStream 解析看不懂的声明我们可以看一下 Stream 以及 BaseStream 的类的声明 1234//Streampublic interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; //BaseStreampublic interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt; BaseStream 中，第二个泛型是 S extends BaseStream&lt;T, S&gt; ，而 Stream 中，第二个泛型是 Stream&lt;T&gt;， 正好是满足 extends BaseStream&lt;T, S&gt; 的条件的，所以可以这么写。 两个泛型有没有感觉有点晕。其实比较好理解。 T 这个泛型很好理解，就是流中元素的类型 S ？ 如果你看过javadoc的描述，流的所有中间操作，都会返回一个流，而这个S 就代表着中间操作返回的流的类型。比如我们看一下这个在 Stream 中的方法（其他方法与其一致） 难懂的 onClose() 方法上面我们知道 BaseStream 实现了 AutoCloseable 接口，也就是 Close() 方法可以得到调用。但是 BaseStream 中，给我们提供了要给OnClose() 方法。我们看下截图 这个方法，就是当 Close() 方法被调用的时候 onClose()会被调用。但是有几个注意的点 onColse() 方法也返回一个流，也就是说可以多次调用。 如果你写了多个onClose() 方法，它会按照顺序调用。 前一个 onClose() 方法除了异常不影响后续 onClose 方法的使用 如果多个 onClose() 方法都抛出异常，只展示第一个异常的堆栈，而其他异常会被压缩，只展示部分信息 上代码！！！！！！ 12345678910111213141516171819202122232425/** * Created by charleszhu on 2017/5/2. */public class StreamTestOnCloseTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; testString = Arrays.asList(&quot;min&quot;, &quot;ge&quot;, &quot;da&quot;, &quot;shuaibi&quot;); /** * 两次关闭 * 两次异常 * 预期：两次关闭输出依次打出；两次关闭异常只打印一次堆栈，另外一次只展示 */ try(Stream&lt;String&gt; stream = testString.stream()) &#123; stream.onClose(() -&gt;&#123; System.out.println(&quot;closing 1&quot;); // throw new NullPointerException(&quot;exception 1&quot;); &#125;).onClose(() -&gt; &#123; System.out.println(&quot;closing 2&quot;); throw new NullPointerException(&quot;exception 2&quot;); &#125;).forEach(System.out::println); &#125; &#125;&#125; 结果如下图： 你们明白了吧（我是天才） 好懂的其他方法BaseStream 中有的一些其他方法，除了分割迭代器(后面会单独说，因为太重要) 1Spliterator&lt;T&gt; spliterator(); 其他都比较好懂。值得一说的是以下两个方法： 12S sequential(); // 返回串行流S parallel(); // 返回并行流 你可以看到他们都返回流对象，也就是可以继续调用 sequential 或者 parallel 方法。但是！！！ 无论你中间怎么调用 ，比如 sequential.parallel.parallel.sequential…. 只以最后一个为最终流的类型！！！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk1.7新增自动关闭接口AutoCloseable]]></title>
      <url>%2F2017%2F05%2F02%2Fjdk1-7%E6%96%B0%E5%A2%9E%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%8E%A5%E5%8F%A3AutoCloseable%2F</url>
      <content type="text"><![CDATA[1 AutoCloseable 接口这是JDK1.7 的新增语法。帮助你自动关闭一些资源。可能你还不知道这个接口 这个接口好就好在，只有一个方法，名叫 close(), 而这正好有是我们各个资源关闭的方法名，所以使用起来相当方便，因为名称一样，代码兼容。 JDK8 中就在很多地方应用了这个接口，比如 Stream 继承了 BaseStream，而 BaseStream 则继承了 AutoCloseable 这个接口。 这个接口的说明很清楚，当你在使用 try-with-resources block 这种语法调用来进行资源获取的时候，在 block 退出之后自动关闭 try-with-resources block 代码块，就是将资源的声明，放在 try 里面； 可以看后面的代码示例 你不用像之前写 finally{} 代码那样的进行关闭。就不会有资源未被释放的问题。 2 测试代码简单测试代码如下 1234567891011121314151617181920212223/** * Created by charleszhu on 2017/5/2. */public class AutoCloseAbleTest implements AutoCloseable&#123; public void doSth() &#123; System.out.println("doStm"); &#125; @Override public void close() throws Exception &#123; System.out.println("Close() 看到没，我被吊了"); &#125; public static void main(String[] args) throws Exception &#123; /** * try-with-resources 语法块 */ try(AutoCloseAbleTest autoCloseAbleTest = new AutoCloseAbleTest()) &#123; autoCloseAbleTest.doSth(); &#125; &#125;&#125; 运行一下，结果如下：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[老版本MacBookPro (厚的) 格式化, U盘安装 MacOS Sierra]]></title>
      <url>%2F2017%2F05%2F01%2F%E8%80%81%E7%89%88%E6%9C%ACMacBookPro-%E5%8E%9A%E7%9A%84-%E6%A0%BC%E5%BC%8F%E5%8C%96-U%E7%9B%98%E5%AE%89%E8%A3%85-MacOS-Sierra%2F</url>
      <content type="text"><![CDATA[引子主要写的点是：U 盘安装盘的制作，以及，为什么会有 can’t be verified 已损坏，重新下载 这些问题，即使你是从 app store 中下载的完整版本。 前两天，我一个朋友拿了一台很老的 MacBook pro , 说他不小心格式化了硬盘，要我重装系统。。 电脑图如下。。 有点洁癖的我看到了想说说，要不你砸了吧（当然我没说。。）但是碍于面子（毕竟我是程序员，外界都说是搞电脑的，约等于 修电脑的，近似于你是修电脑的，也就是说电脑相关的你全都会，不会就是大傻逼）。。 我当然是很愤怒的，之所以没有发作是因为他是我老师。。 如何制作安装盘准备工作你需要一下物品： 一个只要8G的U盘 一台工作良好的 macbook pro 良好的网络 我（你没戏了） 言归正传： 步骤一 ： 在App Store 中下载最新的 macos连接如下 下载地址她会跳转到 app store. 点击下载即可。它会弹出提示让你更新啥的，不用管它，直接下载 下载好了之后，你在你的 应用程序 文件夹，你就可以看到这个了 至此，你的第一任务完成。 步骤二 ：用磁盘工具格式化你的U盘打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致。) 如果不成功，你就多试几次 步骤三 ： 制作安装盘打开你的终端，输入如下命令1sudo /Applications/Install\ macOS\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\ macOS\ Sierra.app --nointeraction 注意空格前面需要有 \ 进行转义 耐心得到 done, 你就可以拿着 U 盘去安装了 无法验证？or 已经损坏？重装的步骤简单，插入u盘，开机按住 option, 选择u 盘的安装盘。接下来选择安装就可以了。 但是，大部分情况下，都会遇到类似 This copy of the Install OS X El Capitan application can’t be verified. It may have been corrupted or tampered with during downloading 或者，直接告诉你损坏了，让你再去下载完整版本。 导致这个的原因是，当你决定将一台mac格式化后，在重装系统的时候，系统的时间已经被改变了。这个时候安装程序就会爆出各种错误。你可以通过 终端输入 date 进行查看，时间应该变成了 2001 年。 这个时候， 你只要通过 date 命令重置时间，就可以解决这个问题。他的参数如下 123456date MMDDHHmmYY replacing the letters as follows.MM - 2 digit month 01 - 12DD - 2 digit date 01 - 31HH - 2 digit hour 01 - 24mm - 2 digit minute 01 - 59YY - 2 digit year &gt; 15 你将时间设置成，你要安装的系统发布之后的一个时间后，退出终端，再次点击操作，就不会有问题。 你也可以看做这个视频 土逼视频 ，需要翻墙。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-32-groupingBy 源码分析]]></title>
      <url>%2F2017%2F04%2F30%2Fjdk8-32-groupingBy-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[jdk8 集合的工厂类 Collectors 提供了两个很好用的静态函数。 groupingBy partitioningBy groupingBy 实现类似 Mysql 中分分组功能。返回一个 Map; 而 partitioningBy可以看做是 groupingBy 的特殊形式。我们后面会接着介绍。 使用的是比如统计每个城市人的“姓”，可以这么写 1Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity, mapping(Person::getLastName, toSet()))); 那么，他到底如何利用 Collector 的各个接口来实现的呢？下面我们将深入 JDK 的 Collectors 的源码中，分析一下他是如何工作的。 groupingBy1 第一个重载方法, 要简单就别那么多要求，给你个List不错了分组 groupingBy 有三个重载方法。一个比一复杂。 先看最简单的 12345678/** * @param &lt;T&gt; the type of the input elements * @param &lt;K&gt; the type of the keys*/public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier) &#123; return groupingBy(classifier, toList()); &#125; 这里 T 是输入集合的元素类型， K 是最后产生的 Map 的主键key 的类型。 函数需要传入一个 Function 的函数式接口，Function 的中作就是分类器，比如传入的类型是T 是一个 Person类型 ， 通过 apply() 方法，返回 Person 的属性 name；因为我们要按照 name 来分组。 所以，如果 name 的类型是 String ； 那么 K 就是 String 故而，这个 groupingBy(function) 的功能就很清晰了，就是通过 function 对传入的 T 类型进行分类。然后调用 toList() 方法，也就是说每个分类的Person 会放进一个 List&lt;Person&gt; 中 最终返回的类型就是 Map&lt;String, List&lt;Person&gt;&gt;. 而如果你不想返回的是一个List , 希望是一个 Set. 你就要使用第二个重载方法~ 他允许你定义最后的输出函数。 2 第二个重载方法：我要输出Set看一下函数的定义： 12345678910111213/** * @param &lt;T&gt; the type of the input elements * @param &lt;K&gt; the type of the keys * @param &lt;A&gt; the intermediate accumulation type of the downstream collector * @param &lt;D&gt; the result type of the downstream reduction * @param classifier a classifier function mapping input elements to keys * @param downstream a &#123;@code Collector&#125; implementing the downstream reduction*/public static &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream) &#123; return groupingBy(classifier, HashMap::new, downstream); &#125; 这个函数，明显比上一个要复杂，可以看到，多了一个 Collector 的 downstream , 可以自定义输出的集合。上面那个简单版本的函数是是写死的 List 这个函数有四个泛型。 T 原始元素类型，比如我们这是 Person K 返回 Map 的 key, 即最终返回的Map 的建的类型。如果你想按照人的名字分类，那T就是 String, 如果按照年龄分类，那就是 Interger A 是 downstream 的 accumulation 的中间结果类型 D 是最终输出 Map 的 Value 的类型。比如 List 或者 Set 这个方法会调用第三个重载函数，比第二个函数，多了中间的 HashMap::new； 这个是最终返回的 Map 的类型，这里写死的是 HashMap, 如果你想用其他类型，就需要使用最终的也是最复杂的第三个重载函数。 越是你用起来简单的函数，背后的实现就越来越复杂。 3 第三个重载方法: 能看懂就随便你怎么玩12345678910111213141516171819202122232425262728293031323334353637383940414243/*** @param &lt;T&gt; the type of the input elements* @param &lt;K&gt; the type of the keys* @param &lt;A&gt; the intermediate accumulation type of the downstream collector* @param &lt;D&gt; the result type of the downstream reduction* @param &lt;M&gt; the type of the resulting &#123;@code Map&#125;* @param classifier a classifier function mapping input elements to keys* @param downstream a &#123;@code Collector&#125; implementing the downstream reduction* @param mapFactory a function which, when called, produces a new empty* &#123;@code Map&#125; of the desired type*/ public static &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Supplier&lt;M&gt; mapFactory, Collector&lt;? super T, A, D&gt; downstream) &#123; Supplier&lt;A&gt; downstreamSupplier = downstream.supplier(); BiConsumer&lt;A, ? super T&gt; downstreamAccumulator = downstream.accumulator(); BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123; K key = Objects.requireNonNull(classifier.apply(t), "element cannot be mapped to a null key"); A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get()); downstreamAccumulator.accept(container, t); &#125;; BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner()); @SuppressWarnings("unchecked") Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory; if (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123; return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID); &#125; else &#123; @SuppressWarnings("unchecked") Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher(); Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123; intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v)); @SuppressWarnings("unchecked") M castResult = (M) intermediate; return castResult; &#125;; return new CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID); &#125; &#125; 这个函数有5个泛型，除去上面说的 T，K，A，D多了一个 mapFactory 的 Supplier() , 用于得到最终返回的 Map 的类型，第二个重载函数写死的 HashMap，这就可以进行自定义。 这个函数有连个值得注意的点： 所有的Collectors 中函数，如果函数内部还要做集合处理的，都是使用 downstream 这种模式，利用 downstream 的各种已有的的 Supplier Accumulator等，修改来实现自己的功能。比如在 groupingBy 这个函数，一开始就获取了 downstream 的各个组件，组合成自己需要的收集器，进而用于完成分类的行为。（你还可以去看一看 collectingAndThen() 这个函数） groupingBy 函数中有有两处强制类型转换。这里其实很难理解，为何可以直接成功的转换呢？ 第一处 第二处 两处其实都是将最终结果泛型 D 转成 中间结果 A。对于第一处， mapFactory 是作为一个 Supplier 出现，而他的目的是提供中间结果类型，而他上面的 accumulator 的中间结果类型，就是K,A， 所以这样的强转是一定可以成功的 第二处也是一样的，因为全称都使用了 A，其实 A 和 D 在这里，是等价的。所以转换都可以成功。 你去可以从这么一个角度思考问题： 你最终需要生成 D 类型，为何中间要给自己生成一个不一样的 A 类型添堵呢？ 你 4 不 4 sa？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-31-工厂方法收集器Collectors的中的常用函数]]></title>
      <url>%2F2017%2F04%2F13%2Fjdk8-31-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86%E5%99%A8Collectors%E7%9A%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[1 collectorImpl Collectors 中的 的基础 collectorImpl 两个构造方法一个有 finisher(), 一个没有。这个很容易理解，一个需要转换中间结果，一个中间结果和最终结果一致，所以不需要使用 finisher() 方法 2 两种实现方式对于工厂类 两种实现方式 CollectorImpl 来实现。 reduceing 来实现， 而 reducing 方法归根还是用的是 CollectorImpl 方法来实现 3 常见函数1） toList() &amp; toCollection 两个最常用的方法 toList() &amp; toCollection toSet() 方法是也是 toCollection 的特化。 2） joining() joining 三种重载方法 3） mapping() mapping() 将输入元素转换成输出元素 1234Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity= people.stream().collect(groupingBy(Person::getCity,mapping(Person::getLastName, toSet()) // Mapping , 将Person 转换成String , 提供给下游 Collector 使用)); 4） collectingAndThen() collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher) 先过完上层收集器 downstream ，在进行一次 finisher() 转换结果 比如说，你在 toList() 之后，想将它转换成一个 immutableList() 就可以如下使用 List&lt;String&gt; people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList)); 实现其实很有意思 5） counting() , minBy() , maxBy() counting() , minBy() , maxBy() 用 reducing() 实现, reducing() 又是基于 CollectorImpl 实现 6） summingInt() , averagingInt() , averagingDouble() summingInt() 对每一个元素使用 toIntFunction 在累加，实现很有意思 Supplier() 采用生成了一个 长度为1 的 int 数组，而不是直接使用的整形数字？因为数字是一个 值， 值是无法传递的，而数组是一个 引用， 引用是可以传递的。 averagingInt() 求平均值 对于averagingDouble() 的实现可以再去看一下，他的初始数组长度为4，他们视为浮点数计算的补偿产生的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-28-30-自定义收集器&坑]]></title>
      <url>%2F2017%2F04%2F12%2Fjdk8-28-30-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%B6%E9%9B%86%E5%99%A8-%E5%9D%91%2F</url>
      <content type="text"><![CDATA[收集器中有很5个抽象方法，每个抽象方法都有自己特殊的作用，如果说我们要自己实现要给收集器的话，我们就需要分别实现下面五个方法。 1 简单自定义一个收集器这个收集器的目的是将一个 list 转换成一个 set 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class MySetCollector&lt;T&gt; implements Collector&lt;T, Set&lt;T&gt;, Set&lt;T&gt;&gt; &#123; @Override public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123; System.out.println("supplier invoked!!!"); return HashSet::new; &#125; @Override public BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123; System.out.println("accumulator invoked!!!"); return Set&lt;T&gt;::add; &#125; /** * 并行性流才会调用，将两个分段的集合 * @return */ @Override public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123; System.out.println("combiner invoked!!!"); return (t1, t2) -&gt; &#123; t1.addAll(t2); return t1; &#125;; &#125; @Override public Function&lt;Set&lt;T&gt;, Set&lt;T&gt;&gt; finisher() &#123; System.out.println("finisher invoked!!!"); return Function.identity(); &#125; /** * 描述这个集合的特性 * IDENTITY_FINISH 表示结果容器和中间容器是一致的，这个时候 JDK 会在返回的时候自动帮助我们做类型转换。而不用再去调用 finisher * @return */ @Override public Set&lt;Characteristics&gt; characteristics() &#123; System.out.println("characteristics invoked!!!"); return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH,UNORDERED)); &#125; public static void main(String[] args) &#123; List&lt;String&gt; words = Arrays.asList("hello" , "world", "welcome", "hello"); Set&lt;String&gt; stringSet = words.stream().collect(new MySetCollector&lt;&gt;()); System.out.println(stringSet); &#125;&#125; 实现类里，我们分别实现了5个方法。 其中比较重要的两个方式 finisher 和 characteristics 方法 这俩方法是相互影响的。首先看 characteristics 方法，这个方法要求返回一个 Characteristics 枚举类型对的 Set。而 Characteristics 一共有三个枚举值。分别有不同的含义。 123456789101112131415161718/** * 当我们采用并行流的时候，同时设置了 CONCURRENT 作为这个流的特性 * 那么，操作的是同一个集合，而不是多个 * 同样的道理，我们采用了并行流的方式，但是没有这个特性，我们就会生成多个 * 集合 */ CONCURRENT, /** * 代表集合是否是有序的 */ UNORDERED, /** * 表示 finisher function 可以被省略，因为中间结果和最后的返回的结果的类型是一致的。 * 所以当我们设置了这个属性之后，我们就必须了解到， 最后的返回的类型，可以由中间结果类型进行强制的返回。 */ IDENTITY_FINISH 上面的例子中，我们为我们自己的 collector 设置了两个属性， IDENTITY_FINISH &amp; UNORDERED ; 意思就是这个收集器收集的元素是无序的。 而同时，返回的类型和中间结果类型是可以完全强制转换的（如果不可以，则会报错，下面会说到）；而 finisher() 函数是不会被执行的，即使你在函数内部直接抛出一个异常都没有问题，因为根本不会执行。执行结果我们可以看一下： 这里需要注意两点： 虽然 combiner() 函数被调用了，但是只是返回了一个 BinaryOperator 而已，而这个 BinaryOperator 并不会被调用。 finisher() 函数并没有被调用，原因上面已经说过 characteristics() 函数被调用了两次，分别代表不同的意思 对于第3点，我们跟进 collector() 源代码里看一下, 便会有答案。 图中书说法其实不准确，其实是 evaluate 方法中的 ReduceOps.makeRef(collector) 中，会逐个调用相关方法， 包括 characteristics() 方法。 所以 characteristics() 被调用了两次，第一次用于判断 是否是无序集合 ；第二次用于判断 是否需要执行 finisher 用于中间结果和最终结果的类型转换 2 当中间结果与返回结果不一致看下面这个改造的自定义收集器，中间结果是个 set 而返回的是个 map，也就是中间结果和最终最终结果是不一致的。这个时候，finisher 函数就会排上用场了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MySetCollector2&lt;T&gt; implements Collector&lt;T, Set&lt;T&gt;, Map&lt;T,T&gt;&gt; &#123; @Override public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123; System.out.println("supplier invoked!!!!!"); return HashSet::new; &#125; @Override public BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123; System.out.println("accumulator invoked!!!!!"); return (set, item) -&gt; &#123; System.out.println(set); System.out.println("threadName: " + Thread.currentThread().getName()); set.add(item); &#125;;// return Set&lt;T&gt;::add; &#125; @Override public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123; System.out.println("combiner invoked!!!!!"); return (set1, set2) -&gt; &#123; set1.addAll(set2); return set1; &#125;; &#125; @Override public Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123; System.out.println("finisher invoked!!!!"); return set -&gt; &#123; Map&lt;T, T&gt; map = new HashMap&lt;&gt;(); set.stream().forEach(item -&gt; map.put(item, item)); return map; &#125;; &#125; /** * 当有 Characteristics.CONCURRENT 意味着如果有并发，则是多个线程操作一个集合。 * 这个时候 accumulator 如果有 遍历操作，就有可能会抛出 ConcurrentModificationException * @return */ @Override public Set&lt;Characteristics&gt; characteristics() &#123; System.out.println("characteristics invoked!!!!"); return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT)); &#125; public static void main(String[] args) &#123; for(int i = 0; i &lt; 100; i ++) &#123; List&lt;String&gt; words = Arrays.asList("hello", "word", "helloword", "hello", "a", "b", "c", "d", "e"); Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(words); Map&lt;String, String&gt; map = set.parallelStream().collect(new MySetCollector2&lt;&gt;()); System.out.println(map); &#125; &#125;&#125; 这里由于我输出与中间结果类型并不一致，所以如果我在 characteristics() 方法中，依旧使用 IDENTITY_FINISH ，也就是进行类型强转，则必然报错，类型转换异常。大家可以自己试一下。 3 并发与并行的区别-并行时候的一些坑这里，有另外一个很要命的坑。 在说这个概念之前，先说一下收集器中 parallel 和 concurrent 的区别 parallel 是并行，会将产生多个集合，多个线程操作，最后合并，也就是会调用 combiner() 方法 concurrent 是并发， 是多个线程对同一个集合进行操作，首先 combiner() 函数不会被执行，而同时，如果你在 accumulator() 函数中进行累加操作，又进行遍历操作，就会抛出并发异常。 用例子说话，首先我们必须采用 并行流 ， 在 accumulator() 函数中遍历 set, 同时将 characteristics() 函数中加入 CONCURRENT 这个属性，你执行100次，基本都会抛出异常 原因很简答也比较复杂： 程序采用了并行流 set.parallelStream()，同时设置了 CONCURRENT 属性；也就是说，多个线程操作同一个集合。 而在 accumulator() 函数中同时遍历了集合，也修改了集合。由于是多线程操作，很大的概率就会发生你一边遍历集合，一遍修改，就会报错。顺被大家可看看 ConcurrentModificationException 的 javadoc. 而如果，你不添加 CONCURRENT 这个属性，就不会报错。因为会生成多个中间集合。这一点，我们可以改造 supplier() 方法，在其中答应一条语句，通过打印了几条语句，就可以看出产生了几个集合。 当然了，如果你在 accumulator() 中不去有那个遍历的操作，也是即使你添加了 CONCURRENT 属性，也是不会报错的。因为你没有并发的即遍历又修改一个集合 而一般产生多少集合，由产生多少个线程决定，而产生多少线程一般由机器经过 超线程 技术之后有多少个处理器而确定的。当然也是可以修改的，但是一般没有必要。 12// 查看有多少处理器Runtime.getRuntime().availableProcessors();]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-2-流初步以及Function详解]]></title>
      <url>%2F2017%2F02%2F14%2Fjdk8-2-%E6%B5%81%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8AFunction%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[一 流初步java 8提供一种更加方便的操作集合方式，即流~ StreamStream的概念其实类似于 liunx 操作系统的中的 PipeLine 的概念，可以将数据传输； 流 分为两种： 中间流：数据通过后还返回一个流，不是数据的终点 节点流：数据流入后不再返回流，操作结束，没有返回 使用java8 中的 List 来写一个例子，这个例子是将集合中的所有元素，全部变为大写，而后将元素逐一输出12345678910111213141516171819202122public class Test3 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list1 = Arrays.asList("min.zhu", "yi.yu", "nai.nai");// list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; System.out.println(item)); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); // 流的操作方式 类似 linux 的管道功能 // 流 分为： 中间流 和 节点流 // map 称之为 映射 与 mapper-reducer 阶段的map 功能是一致的，给定一个值，返回会一个由于之映射的值 list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; list2.add(item)); // 函数引用的做法 // String::toUpperCase 其实 和 item -&gt; item.toUpperCase() /** * 一致，都是有输入有输出，而 toUpperCase 的输入，就是调用他的实例对象 * 因为一个类是无法调用他的实例方法的，一定是实例才可以调用实例方法 */ list1.stream().map(String::toUpperCase).forEach(System.out::println); list1.stream().map(String::toUpperCase).forEach(list2::add); &#125;&#125; java8 的调用流的方式，是使用集合的 stream() 方法， 这个方法会返回一个流，之后就可以调用 map() 方法对 list 中的元素做一定的处理。 map() 函数，还是返回了一个流，这个流也有 forEach 方法，这个时候我们还可以调用 forEach 方法对流中的数据进行逐一的处理。 需要注意的是，forEach 函数中, 需要传递的函数的参数是一个 Consumer 的函数式接口，这个接口的抽象方法 accpt() 是没有返回值的，所以，他不在可以返回一个可以继续操作的流。 而我们在看看 map 方法中，需要传递的是一个我们没有见过的 Function 的函数式接口，这个函数式接口，有两个参数，一个是输入参数，一个是返回值。他的唯一的抽象方法中，是接受一个参数，返回一个值。具体见下图，唯一的方法是 apply 方法，它是有返回值的，这一点和现实中的函数很像 我们之前说过，java8 中，新增了很多个函数式接口，分别用于不同的场景如之前说的 Consumer 接口，他是没有返回值的一个场景，专用于处理数据以及今天说的有返回值的 Function 接口 那么这个 Function 的函数式接口，就是我们今天的重点。 二 Functon 接口 以及 BiFunction简介我们可以用一个例子来完整的说明问题： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * 函数式接口 Function 的经典案例 * jdk 8 新增很多 函数式接口 * 之前看的 forEach 方法中的 Consumer 接口 ，他的作用就是 对给定的参数进行一系列操作，不返回值 * 而现在的 以及 Test3 中流的 map 方法中 Function 接口 ，他唯一的操作 是apply , 他有返回值，一个value 一个 Return ，与现实当中数学的函数很类似 * * jdk 8 中，接口中 除了可以有 default 方法以外， 还可以有一个 static 方法， static 方法可以有默认的实现 * 可以参考 Function 这个函数式接口 */public class FunctionTest &#123; public static void main(String[] args) &#123; FunctionTest functionTest = new FunctionTest(); // 函数式接口，以及 lambda 表达式，让我们可以在函数操作的时候，传递函数，即传递行为 // 而之前的编程方法，行为必须已经确定，而后进行调用 // 故而 之前的编程方法称之为命令式编程，而后面的方法称之为 函数式编程 // 而 可以传递，或者 返回函数的函数，称之为高阶函数（ js 中随处可见高阶函数 System.out.println(functionTest.compute(1, item -&gt; 2 * item)); // 这种返回方式是 statement 方法 // 上面那种方式是 expression 方式 // 一个是一个标准的语句，而一个是一个表达式 /* * 表达式是不需要分好结尾的 * 而使用 标准语句，则必须要 ； 而且要 &#123;&#125; */ System.out.println(functionTest.compute(1, item -&gt; &#123;return 2 * item;&#125;)); System.out.println(functionTest.compute(2, item -&gt; item * item)); System.out.println(functionTest.convert("hello", item -&gt; item + " world !!")); &#125; public int compute(int value, Function&lt;Integer, Integer&gt; function) &#123; return function.apply(value); &#125; public String convert(String value , Function&lt;String, String&gt; function) &#123; return function.apply(value); &#125;&#125; 主要去看代码的注释，上面写完了所有重点的内容，我们再去看看 Function 这个函数式接口的实现，我们知道，java8 允许接口有 default 方法，而 Function 接口中有两个默认方法： 利用这个两个方法，可以做函数的组合，用一个函数的输出，作为一个函数的输入。 compose 方法，是先执行 before 这个function, 在执行本身这个function； andThen 方法，则是先执行 Function 本体的 apply 方法，在执行传入的 after 的方法 我们来写个例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class FunctionTest2 &#123; public static void main(String[] args) &#123; FunctionTest2 functionTest2 = new FunctionTest2(); // 12 System.out.println(functionTest2.compute(2, item -&gt; item * 3, item -&gt; item * item)); // 36 System.out.println(functionTest2.compute2(2, item -&gt; item * 3, item -&gt; item * item)); // 25 System.out.println(functionTest2.compute3(2, 3, (a,b)-&gt; a+b , result -&gt; result * result)); &#125; public int compute (int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; /** * compose 就是 先执行 function2.apply * 再将 function2.apply 的返回值，作为 function1 的输入 * 此时再执行 function1 apply */ return function1.compose(function2).apply(a); &#125; public int compute2 (int a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2) &#123; /** * compose 就是 先执行 function1.apply * 再将 function1.apply 的返回值，作为 function2 的输入 * 此时再执行 function2 apply */ return function1.andThen(function2).apply(a); &#125; /** * 如果想做有两个参数的Function 就需要使用BiFunction * 而 BiFunction 只有一个 andThen , andThen 的输入 是 Function， * 因为是将 Apply 的结果返回，结果只有一个，所以 参数只能是 Function , 而不是 BiFunction * 所以 BiFunction 方法不可能有 compose 方法 * * 对应的 consumer 也有着 BiConsumer 同时，二者因为没有返回值，所以也只可能有 andThen 方法 * @return */ public int compute3 (int a, int b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function) &#123; return biFunction.andThen(function).apply(a,b); &#125; compose 和 andThen 的功能可以从例子中很好的看出来，例子中还有一个新的接口叫 BiFunction, 这个函数式接口是给定两个输入，返回一个输出，解决了有两个参数的函数的问题，对应的，其实 Comsumer 接口也还有一个对应的 BiConsumer 接口。 而当我们去观察这俩 Bi 的接口，都只有一个 andThen 的接口，为啥没有 compose 方法呢？给读者自己思考吧~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-1.1-方法引用：lambda表达式的语法糖]]></title>
      <url>%2F2017%2F02%2F12%2Fjdk8-1-1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96%2F</url>
      <content type="text"><![CDATA[方法应用其实是 jdk 8 中的对于 lambda 表达式给予的一种 语法糖 而方法引用一共分为 4 种； 1 类名::静态方法名 2 对象名::方法名 3 类名::实例方法名 4 构造方法引用::new 我们有intellj 编写 lambda 表达式的时候，编译器总是标黄来告诉你，这里可以使用方法引用的方法来进行代码的简化 而方法引用，method reference 其实就是lambda表达式一种语法糖但是 不是所有的 lambda 表达式，都可以用方法引用的方式来编写复杂的 lambda 表达式还是需要老老实实写相关代码 我们通过一个例子来分别讲解这四种方法引用的方式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public static void main(String[] args) &#123; // 第一种 Student student1 = new Student("zhumin1",10); Student student2 = new Student("zhumin2",20); Student student3 = new Student("zhumin3",40); Student student4 = new Student("zhumin4",80); List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4); // jdk 1.8 的新方法 List 中新增加了 sort 方法 // 传统的 lambda 表达式 students.sort((studentP1, studentP2) -&gt; Student.compareByScore(studentP1, studentP2)); // 第一种方法引用的方式 类名::静态方法名 // 不需要传参数，因为可以自动推断出 Student 类型 students.sort(Student::compareByScore); // 第二种 对象名称::方法名称 // 其实和第一种很类似 StudentComparator studentComparator = new StudentComparator(); students.sort((studentP1, studentP2) -&gt; studentComparator.comparator(studentP1, studentP2)); // 对象名称::方法名称 (方法引用的第二种方式) students.sort(studentComparator::comparator); // 第三种方法 类名::实例方法 /** * 比较难理解的的地方是，你会看到调用的函数，和 lambda 表达式需要的参数个数不一致， 会少一个 * 而且类名是没法调用方法名的 * 而理解方式是：调用方法的实例，就是传入lambda 表达式的第一个参数，而剩下所有参数，都作为 调用的实例方法 的参数 * 我们看下面的例子 ， Student 类调用的是其的实例方法 compare（Student） 只有一个参数 * 而 List 的默认方法需要的 Comparator 的函数式接口需要两个参数，看似对应不上，而且，类名也无法调用实例方法 * 实际是，传入的第一参数就是 comare（student）这个函数的调用者，而第二个参数以及后续所有的参数（如果有跟多也是一样），是作为实例方法的参数传入 * 所以少一个参数也没什么 * 而更为关键的是这个就是一个语法糖，为了简化代码而生。理解就好 * 如此一来； 这个第三种方式就很好理解了 * * 类名::实例方法 * 即 lambda 表达式的第一参数就是 实例方法 的调用者，后续所有的参数就是 实例方法的传入参数 */ students.sort(Student::compare); // 再看一个例子 List&lt;String&gt; cities = Arrays.asList("haha","lala","nihao","memeda"); // 对比二者 Collections.sort(cities, (city1, city2) -&gt; city1.compareToIgnoreCase(city2)); Collections.sort(cities, String::compareToIgnoreCase); // 对于第四种，构造方法引用，对于带参数和不带参数的都可以，编译器会自动的进行腿短 MethodRefrenceTest methodRefrenceTest = new MethodRefrenceTest(); // 点击 new 看看会跳到那个方法里去 methodRefrenceTest.getName(String::new); // 点击 new 看看会跳到那个方法里去 methodRefrenceTest.getName2("haa", String::new); &#125; public String getName(Supplier&lt;String&gt; supplier) &#123; return supplier.get() + "haha"; &#125; public String getName2(String name, Function&lt;String ,String&gt; stringFunction) &#123; return stringFunction.apply(name); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jdk8-1-函数式接口&lambda表达式]]></title>
      <url>%2F2017%2F02%2F11%2Fjdk8-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[1 lmabda表达式首先看两段对比代码:为jbutton 添加一个时间监听器12345678910// 老写法: 匿名内部类jButton.addActionListener(new AbstractAction() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println("Hello Button"); &#125;&#125;); // lambda 表达式写法jButton.addActionListener(e -&gt; System.out.println("Hello Button")); 对比两个写法，lambda表达式的写法会简单很多，如果你有多行处理逻辑：12345// 加个大括号jButton.addActionListener(e -&gt;&#123; System.out.println("Hello Button!!!!"); System.out.println("Hello Button2!!!!");&#125;); 这里的e，没有声明类型，并不是表示java 不是一个静态语言了，而是，编译器的类型推断告诉可以推断出来这个 e 的类型肯定是一个 AbstractAction, 所以无需去写，当然如写上也没有问题，需要加上括号 1234jButton.addActionListener((AbstractAction e) -&gt;&#123; System.out.println("Hello Button!!!!"); System.out.println("Hello Button2!!!!");&#125;) 所以 lambda 表达式的基本结构如下（根据单个参数和单个操作可以有一定的省略）1234(event e1, event e2 ...) -&gt; &#123; action1; action2;&#125; 一开始可能不是特别好理解，我们可以结合 java8 新增的另一个特性 函数式接口 来一起理解为何我们可以如此编写代码 2 函数式接口什么叫函数式接口呢？ 函数式接口是 jdk1.8 中新增的一个接口类型，为此还新增了一个注解 @FunctionalInterface 用于标注函数接口；我们通过阅读 @FunctionalInterface 的 jdk 文档来进行概念认知。总结起来： 当一个接口 有且只有一个抽象方法，并且这个抽象方法不是继承自 Object 的方法，就会被当做一个 函数式接口 当一个接口被 @FunctionalInterface 注解时，可以当做一个函数式接口 当一个接口被 @FunctionalInterface 注解，但不满足第一个条件的时候，编译器会报错。 当一个接口 没有被 @FunctionalInterface 注解标注，但是满足函数式接口的条件，也会被当做函数式接口 这里的第一条后半部分很重要，如果一个接口，有两个抽象方法，但是其中一个是继承自 Object 类（因为其实万类师祖）, 他仍然是一个函数式接口。 例如以下实例就是一个完整的函数式接口，即使他有2个抽象方法，但是toString是继承自 Object 的方法，所以不会算作函数式接口的抽象方法，所以其中的 test() 方法, 是函数式接口认定的唯一的抽象方法。同理，如果下面的例子只有 toString() 方法，而没有 test() 方法，同时又有 @FunctionalInterface 注解的话，那么编译器会报错。1234567891011121314@FunctionalInterfaceinterface MyInterface &#123; /** * 函数式接口，只能有唯一的抽象方法 */ void test(); /** * 因为改抽象方法，继承自 Object，所以不算函数式接口的抽象方法 * 故而，接口可以算作一个函数式接口 */ String toString();&#125; 我们可以看一下 @FunctionalInterface 的jdk文档，里面有一句: 意思就是说，函数式接口的实现，可以通过 lambda 表达式 方法引用 以及 构造方法引用 的方式来实现。其实我们上面的 lambda 表达式的例子，就是实现的函数式接口。我们来新写一个例子。 12345678910111213141516171819public class Test2 &#123; public void testInterface(MyInterface myInterface) &#123; System.out.println("start ------------------"); myInterface.test(); System.out.println("end --------------------"); &#125; public static void main(String[] args) &#123; Test2 test2 = new Test2(); /* * 因为函数式接口的里唯一的抽象方法test里面，没有参数 * 但是（）不能省略 * 参考Test1 程序里面的Jframe 里的ActionListener */ test2.testInterface(() -&gt; &#123; System.out.println("函数式接口接口实现"); &#125;); &#125;&#125; 我们可以看到，testInterface 方法需要传递一个 testInterface的接口，而我们使用的方式就是 lambda 表达式来实现了一个函数式接口。 可以运用下面的形式来理解。 (函数式接口唯一的抽象方法的参数列表) -&gt; {唯一抽象函数的实现} 这个时候，我们看一下最开始的那个给 button 加 action 的例子。其实实现就是 ActionListener 这个函数式接口的唯一的抽象方法：虽然该类没有 @FunctionalInterface 注解，但是满足条件，只有一个抽象方法，所以他也是一个函数式接口，所以我们可以去使用 lambda 表达式去实现他。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[new start]]></title>
      <url>%2F2017%2F01%2F11%2Fnew-start%2F</url>
      <content type="text"><![CDATA[重新开始维护这个网站。让自己配得上这个不错的域名 movingon.cn! 我14年买了这个域名，本来想自己要好好做，实在不行，这域名也是一个不错的督促。 然而，自己维护了一段时间之后，就忘记了要去维护。 但是这一次，我用这里记录自己的技术成长以及个人感悟，作为自己的成长的记录。]]></content>
    </entry>

    
  
  
</search>
