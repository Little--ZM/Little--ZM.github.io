<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>待葡萄嗖透</title>
  <subtitle>你说啥？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-14T08:19:42.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>朱老师&amp;敏哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kotlin学习1 为何学习kotlin</title>
    <link href="http://yoursite.com/2017/10/14/2017-10-14/"/>
    <id>http://yoursite.com/2017/10/14/2017-10-14/</id>
    <published>2017-10-14T07:42:07.000Z</published>
    <updated>2017-10-14T08:19:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为何使用kotlin"><a href="#1-为何使用kotlin" class="headerlink" title="1 为何使用kotlin"></a>1 为何使用kotlin</h2><ul>
<li>这是一门强势技术</li>
</ul>
<p>语言那么多；不可能什么语言都学习。学习的一定是要有支撑有前景的语言。比如苹果的<code>swift</code>；即使是有呢么多问题；但是由于有苹果的背书</p>
<ul>
<li>他可以和java进行相互的调用</li>
<li>他解决了java无法通过迭代解决的问题</li>
<li>已经成为安卓的官方支持语言，发展前景很好</li>
<li>spring5 也提供了对kotlin的原生支持</li>
<li>官方文档齐全好用</li>
</ul>
<blockquote>
<p><a href="http://kotlinlang.org/docs/reference/basic-syntax.html" target="_blank" rel="external">http://kotlinlang.org/docs/reference/basic-syntax.html</a><br>可执行</p>
</blockquote>
<h3 id="1-2-kotlin-的特点"><a href="#1-2-kotlin-的特点" class="headerlink" title="1.2 kotlin 的特点"></a>1.2 kotlin 的特点</h3><p><img src="http://static.zybuluo.com/zhumin1990719/5raonicmc2dqbskdf001hafg/image_1bs6sjqm91tu3k8fu8a1l4ok8a9.png" alt="image_1bs6sjqm91tu3k8fu8a1l4ok8a9.png-80.9kB"></p>
<ul>
<li><p>简洁；一行代码解决所有 <code>getter</code> 和 <code>setter</code>; <code>it</code> 语法糖等等<br><img src="http://static.zybuluo.com/zhumin1990719/8xq7h590sr000r5ze0snl7u2/image_1bs6tdkff1ce325evtb1pia16aom.png" alt="image_1bs6tdkff1ce325evtb1pia16aom.png-134.7kB"></p>
</li>
<li><p>安全；使用 <code>optional</code> 避免NPE</p>
</li>
<li>相互操作；兼容所有jvm 和 Android的第三方库</li>
<li>良好的工具支持</li>
</ul>
<h2 id="2-简单代码示例"><a href="#2-简单代码示例" class="headerlink" title="2 简单代码示例"></a>2 简单代码示例</h2><p>通过 intellij；新建一个 <code>kotlin</code> 的项目；新建一个 <code>kotlin</code> 文件；</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/0g1fq8rd1lj6784rr4ptupgt/image_1bs6tp5vvc47ho929omcq1p9213.png" alt="image_1bs6tp5vvc47ho929omcq1p9213.png-59.8kB"></p>
<p>官网上有清晰的教程： <a href="http://kotlinlang.org/docs/tutorials/getting-started.html" target="_blank" rel="external">http://kotlinlang.org/docs/tutorials/getting-started.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.zhumin.kotlin.demo</div><div class="line"></div><div class="line">import java.util.function.Consumer</div><div class="line"></div><div class="line">fun main(args: Array&lt;String&gt;) &#123;</div><div class="line"></div><div class="line">    print(&quot;hello world&quot;)</div><div class="line"></div><div class="line">    val list : List&lt;String&gt; = listOf(&quot;hello&quot;, &quot;world&quot;, &quot;hello world&quot;)</div><div class="line"></div><div class="line">    // 遍历</div><div class="line">    for(str in list) &#123;</div><div class="line">        println(str)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    println(&quot;--------------------&quot;)</div><div class="line"></div><div class="line">    list.forEach (Consumer &#123;println(it)&#125;)</div><div class="line"></div><div class="line">    println(&quot;--------------------&quot;)</div><div class="line"></div><div class="line">    list.forEach(System.out::println)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到引入的是java中的包；对consumer的用法和java8也几乎是一模一样。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-为何使用kotlin&quot;&gt;&lt;a href=&quot;#1-为何使用kotlin&quot; class=&quot;headerlink&quot; title=&quot;1 为何使用kotlin&quot;&gt;&lt;/a&gt;1 为何使用kotlin&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;这是一门强势技术&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;语
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="kotlin" scheme="http://yoursite.com/tags/kotlin/"/>
    
  </entry>
  
  <entry>
    <title>Netty 对 WebSocket的简单实现与剖析</title>
    <link href="http://yoursite.com/2017/06/07/Netty-%E5%AF%B9-WebSocket%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%89%96%E6%9E%90/"/>
    <id>http://yoursite.com/2017/06/07/Netty-对-WebSocket的简单实现与剖析/</id>
    <published>2017-06-07T10:42:07.000Z</published>
    <updated>2017-06-07T10:48:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要描述 <code>netty</code> 对 <code>WebSocket</code> 的支持。并编写一个简单 <code>demo</code>; 对 <code>WebSocket</code> 的内容做了简单剖析。</p>
<p>通过文章会了解为何 <code>WebSocket</code> 是 <code>HTTP</code> 协议升级而来； <code>netty</code> 是如何实现对他的支持等。</p>
<a id="more"></a>
<h2 id="WebSocket-的由来"><a href="#WebSocket-的由来" class="headerlink" title="WebSocket 的由来"></a>WebSocket 的由来</h2><h3 id="HTTP-协议的问题"><a href="#HTTP-协议的问题" class="headerlink" title="HTTP 协议的问题"></a>HTTP 协议的问题</h3><p><code>HTTP</code> 协议无状态，为了保持状态，引出了 <code>session</code> &amp; <code>cookies</code>等技术。</p>
<p><code>HTTP</code> 是基于 <code>请求</code> 和 <code>响应</code> 的，请求一定是客户端发出的。（1.1 还有 <code>keepAlive</code>, 持续连接，在一定时间可以进行连接的复用。）</p>
<p>导致的问题， 服务器无法推送数据。所以早期有客户端轮训技术。<br>会导致资源和网络带宽的浪费。因为 <code>Header</code> 数据每次都要构建。</p>
<h3 id="WebSocket-可以做到什么？"><a href="#WebSocket-可以做到什么？" class="headerlink" title="WebSocket 可以做到什么？"></a>WebSocket 可以做到什么？</h3><p><code>WebSocket</code> 来自 <code>Html5</code>; 所以是 <code>HTTP</code> 协议的一个升级版本</p>
<ul>
<li>协议可以建立浏览器和服务器之间的长连接。</li>
<li>可以实现服务端的push</li>
<li>只需要在一开始建立连接的时候构建 <code>Header</code>；其他时间都不需要再有 <code>Header</code> 信息</li>
</ul>
<blockquote>
<p>因为是基于 HTTP 的，所以建立连接的时候，发的请求是一个标准的 http  请求。只不过是在 <code>Header</code> 中添加了信息。</p>
</blockquote>
<p>虽然是基于 <code>Http</code> 的，但是不仅仅在 <code>浏览器上使用</code><br>也可以通过第三方的工具包在 <code>app</code> 端使用</p>
<h2 id="netty-对-webSocket-的简单实现"><a href="#netty-对-webSocket-的简单实现" class="headerlink" title="netty 对 webSocket 的简单实现"></a>netty 对 webSocket 的简单实现</h2><p>netty 功能众多，可以实现对 <code>HTTP</code> 的支持，可以实现高性能异步 <code>RPC</code> 的功能。同样，他也支持对 <code>WebSocket</code> 的支持。</p>
<p>虽然用过 <code>netty</code> 的人都说 <code>netty</code> 复杂，但是他无论简单和复杂的应用，写起来都是样的复杂，这样一来平均一下，只要你了解了规则，还是比较简单的2333</p>
<h3 id="netty-实现-websocket-服务端"><a href="#netty-实现-websocket-服务端" class="headerlink" title="netty 实现 websocket 服务端"></a>netty 实现 websocket 服务端</h3><p>三个步骤</p>
<ul>
<li>Server</li>
<li>Initializer</li>
<li>Handler</li>
</ul>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><p>因为你无论写什么 <code>Server</code> 都基本是这个套路：贴代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 这个示例主要用来阐述</div><div class="line"> * netty 对于 WebSocket 连接的支持</div><div class="line"> * 以及如何写一个简单的WebSocket demo</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</div><div class="line">            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</div><div class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</div><div class="line">                    .childHandler(<span class="keyword">new</span> WebSocketChannelInitializer());</div><div class="line"></div><div class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8899</span>)).sync();</div><div class="line">            channelFuture.channel().closeFuture().sync();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            bossGroup.shutdownGracefully();</div><div class="line">            workerGroup.shutdownGracefully();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里简单解释下为什么有连个 group; 其实一个也没有问题。如果你才会用两个 group；那么 <code>bossGroup</code> 负责接收请求；而 <code>workerGroup</code> 负责处理请求</p>
</blockquote>
<h4 id="Initializer"><a href="#Initializer" class="headerlink" title="Initializer"></a>Initializer</h4><p><code>netty</code> 的各种复杂功能都是由各个 <code>handler</code> 实现的，实现 <code>WebSocket</code> 也是如此。没啥好说的，贴代码，看注释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketChannelInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ChannelPipeline pipeline = ch.pipeline();</div><div class="line"></div><div class="line">        <span class="comment">// 因为是基于HTTP 协议之上的，所以需要使用到 HTTP 的编解码技术</span></div><div class="line">        pipeline.addLast(<span class="keyword">new</span> HttpServerCodec());</div><div class="line">        <span class="comment">// 按照块来写数据 handler</span></div><div class="line">        pipeline.addLast(<span class="keyword">new</span> ChunkedWriteHandler());</div><div class="line">        <span class="comment">// http request 和 response 的一个聚合类</span></div><div class="line">        <span class="comment">// netty 会对http 请求做分段的处理；所以在第一个 http 的示例中，有些会调用多次</span></div><div class="line">        pipeline.addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">8192</span>));</div><div class="line"></div><div class="line">        <span class="comment">// web socket netty 的特殊支持</span></div><div class="line">        <span class="comment">// 其中 "ws" 是指的是 websocket 协议路径</span></div><div class="line">        <span class="comment">// 通常形式   ws://localhost:8899/ws</span></div><div class="line">        <span class="comment">// 8899/ws 后面的 ws 就是我传入的 /ws 路径。</span></div><div class="line">        pipeline.addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">"/ws"</span>));</div><div class="line">        <span class="comment">// 插入自定义的 TextWebSocketFrameHandler</span></div><div class="line">        pipeline.addLast(<span class="keyword">new</span> TextWebSocketFrameHandler());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="TextWebSocketFrameHandler"><a href="#TextWebSocketFrameHandler" class="headerlink" title="TextWebSocketFrameHandler"></a>TextWebSocketFrameHandler</h4><p><code>WebSocket</code> 协议的传输是是以 <code>Frame</code> 作为单位的。这里我们处理的是 <code>Text</code> 这种类型的 <code>Frame</code>。<br>传统，贴代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextWebSocketFrameHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"接受到消息："</span> + msg.text());</div><div class="line">        <span class="comment">// 这里我们接受客户端传来的消息，返回我们当前时间</span></div><div class="line">        ctx.writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(<span class="string">"服务器时间："</span> + LocalTime.now()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"连接建立 : "</span> + ctx.channel().id().asLongText());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"连接断开 : "</span> + ctx.channel().id().asLongText());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"出异常"</span>);</div><div class="line">        ctx.close();</div><div class="line">        cause.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><code>Frame</code> 一共有六种，我们可以从类的继承上看<br><img src="http://static.zybuluo.com/zhumin1990719/vhfib8y17vai9qufzhdar6lk/image_1bi10abjtij3k1fol91c5dkrq9.png" alt="image_1bi10abjtij3k1fol91c5dkrq9.png-138.7kB"><br>六种分别有不同的用途，从字面上都比较容易理解<br>至于为什么是六种？ 那是因为 <code>WebSocket</code> 协议就是这么规定的。</p>
</blockquote>
<h3 id="简单的网页客户端"><a href="#简单的网页客户端" class="headerlink" title="简单的网页客户端"></a>简单的网页客户端</h3><p>为了方便，我们就只用简单的 <code>JS</code> 来进行 <code>WebSocket</code> 的调用</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&lt;script type="text/javascript"&gt;</div><div class="line">    var socket;</div><div class="line">    // 判断浏览器是不是支持</div><div class="line">    if(window.WebSocket) &#123;</div><div class="line">        socket = new WebSocket("ws://localhost:8899/ws")</div><div class="line">        socket.onmessage = function (event) &#123;</div><div class="line">            var ta = document.getElementById("responseText");</div><div class="line">            ta.value = ta.value + "\n" + event.data</div><div class="line">        &#125;</div><div class="line">        socket.onopen = function (event) &#123;</div><div class="line">            var ta = document.getElementById("responseText");</div><div class="line">            ta.value = "连接开启"</div><div class="line">        &#125;</div><div class="line">        socket.onclose = function (event) &#123;</div><div class="line">            var ta = document.getElementById("responseText");</div><div class="line">            ta.value = "连接关闭"</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        alert("浏览器不支持 WebSocket")</div><div class="line">    &#125;</div><div class="line">    // 发送消息</div><div class="line">    function send(message) &#123;</div><div class="line">        if(!window.WebSocket) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if(socket.readyState == WebSocket.OPEN) &#123;</div><div class="line">            socket.send(message)</div><div class="line">        &#125; else &#123;</div><div class="line">            alert("连接尚未开启")</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line"></div><div class="line">&lt;form onsubmit="return false;"&gt;</div><div class="line">    &lt;textarea name="message" style="width: 400px; height: 200px"&gt;&lt;/textarea&gt;</div><div class="line">    &lt;input type="button" value="发送数据" onclick="send(this.form.message.value)"/&gt;</div><div class="line">    &lt;h3&gt;服务端输出：&lt;/h3&gt;</div><div class="line">    &lt;textarea id="responseText" style="width: 400px; height: 200px"&gt;&lt;/textarea&gt;</div><div class="line">    &lt;input type="button" value="清空数据" onclick="javascript: document.getElementById('responseText').value=''"/&gt;</div><div class="line">&lt;/form&gt;</div></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li><p>启动服务器：<br><img src="http://static.zybuluo.com/zhumin1990719/zx0v9dsjaum7lajszic0e65y/image_1bi10qil21u2ul2hhck541m1jm.png" alt="image_1bi10qil21u2ul2hhck541m1jm.png-89.1kB"></p>
</li>
<li><p>启动客户端</p>
</li>
</ul>
<p>简单的做发你可以在 <code>IntelliJ</code> 中直接运行 <code>html</code> 他会帮你起一个服务。或者你可以用 <code>Python</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python -m SimpleHTTPServer 8080</div></pre></td></tr></table></figure>
<p>我采用第一种：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/7n4gc92bqydxrl621vo7bsae/image_1bi1122017ar1ans1bm8fr71nm513.png" alt="image_1bi1122017ar1ans1bm8fr71nm513.png-64.4kB"><br>客户端显示连接已经建立</p>
<p>此时，你可以在服务器端看到我们要打出的信息<br><img src="http://static.zybuluo.com/zhumin1990719/gp12rirel4wu1dphfwbdn4e9/image_1bi11329c1gjgn4t1rnjvii1t7o1g.png" alt="image_1bi11329c1gjgn4t1rnjvii1t7o1g.png-41.2kB"></p>
<p>然后你可以通过客户端给服务器发送消息：比如我发送</p>
<blockquote>
<p>敏哥好帅<br>还用你所？</p>
</blockquote>
<p>服务端会收到：<br><img src="http://static.zybuluo.com/zhumin1990719/7s4ne8auqwdfjwf5ao0f5hgf/image_1bi116pi91bq35iqpn4150u1t9h1t.png" alt="image_1bi116pi91bq35iqpn4150u1t9h1t.png-41.9kB"></p>
<p>客户端也会收到服务端的时间：<br><img src="http://static.zybuluo.com/zhumin1990719/a0ftuajhha27h8d5npao2mz4/image_1bi117a54qu0k151sfo98a1q6t2a.png" alt="image_1bi117a54qu0k151sfo98a1q6t2a.png-17.4kB"></p>
<p>至此，我们可以的这个例子就成功运行了，你停止服务器会看到客户端输出 <code>连接关闭</code>； 你关闭客户端，会看见服务端输出 <code>连接断开</code>。</p>
<h3 id="更近一步，基于-frame-基于-http"><a href="#更近一步，基于-frame-基于-http" class="headerlink" title="更近一步，基于 frame ? 基于 http ?"></a>更近一步，基于 frame ? 基于 http ?</h3><h4 id="基于-frame-的信息传递"><a href="#基于-frame-的信息传递" class="headerlink" title="基于 frame 的信息传递"></a>基于 frame 的信息传递</h4><p>刚刚说到，<code>WebSocket</code> 在建立长连接后，不需要在传递头信息。我们可以代开 <code>Chrome</code> 的控制台看一下：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/6xc9j5iqby6fbn3oj37sb32k/image_1bi11g7qkkrtt5ud4sop536d2n.png" alt="image_1bi11g7qkkrtt5ud4sop536d2n.png-149.2kB"></p>
<p>我们能看到的是 <code>ws</code> 的连接的信息里有个 <code>Frames</code> 的标签，你传输的信息都在这里。</p>
<h4 id="WebSocket-连接是基于-HTTP-升级的？"><a href="#WebSocket-连接是基于-HTTP-升级的？" class="headerlink" title="WebSocket 连接是基于 HTTP 升级的？"></a>WebSocket 连接是基于 HTTP 升级的？</h4><p>我们可以刷新一下你的客户端的网页，观察下 network 的输出：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/sxu6eoau4d10t21cy45v5ijr/image_1bi11n5ke12tr19kve631ot01p6a34.png" alt="image_1bi11n5ke12tr19kve631ot01p6a34.png-153kB"><br>注意看出了 <code>js</code> 之外的连个请求：第一个就是基本的 <code>http</code> 请求，状态的 <code>304</code></p>
<p><img src="http://static.zybuluo.com/zhumin1990719/c3lmwkxat1yv6xxvwexfggq7/image_1bi11pgoo1kdfao6mi3r8e1i6p3h.png" alt="image_1bi11pgoo1kdfao6mi3r8e1i6p3h.png-135.4kB"></p>
<p>重点在看一下下面的 <code>ws</code> , 他是一个 <code>WebSocket</code> 请求：<br><img src="http://static.zybuluo.com/zhumin1990719/t8ga6azf75757rytx4xcba7d/image_1bi11rlob15li1k8r1ars5pt1mb33u.png" alt="image_1bi11rlob15li1k8r1ars5pt1mb33u.png-166.7kB"></p>
<p><code>request</code> 中还有一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Upgrade:websocket</div></pre></td></tr></table></figure></p>
<p>的内容，就是它将协议由 <code>http</code> 协议升级成为了 <code>websocket</code> 协议。<br>所以就是这么回事</p>
<p>所以，<code>websocket</code> 需要浏览器的支持。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li><code>jdk8</code></li>
<li><code>netty 4.1.10.Final</code></li>
<li><code>gradle</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要描述 &lt;code&gt;netty&lt;/code&gt; 对 &lt;code&gt;WebSocket&lt;/code&gt; 的支持。并编写一个简单 &lt;code&gt;demo&lt;/code&gt;; 对 &lt;code&gt;WebSocket&lt;/code&gt; 的内容做了简单剖析。&lt;/p&gt;
&lt;p&gt;通过文章会了解为何 &lt;code&gt;WebSocket&lt;/code&gt; 是 &lt;code&gt;HTTP&lt;/code&gt; 协议升级而来； &lt;code&gt;netty&lt;/code&gt; 是如何实现对他的支持等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
      <category term="websocket" scheme="http://yoursite.com/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>老妈的生活哲学</title>
    <link href="http://yoursite.com/2017/05/07/%E6%9C%B1%E8%80%81%E5%B8%88%E4%B8%8E%E8%80%81%E5%A6%88%E7%9A%84%E7%94%9F%E6%B4%BB%E7%BB%86%E8%8A%82/"/>
    <id>http://yoursite.com/2017/05/07/朱老师与老妈的生活细节/</id>
    <published>2017-05-07T05:28:51.000Z</published>
    <updated>2017-05-07T05:35:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近家里人感冒的多，姐姐的双胞胎，小的那个被我们带到舅舅家。</p>
<p>中午，我去我妈那里;</p>
<p><strong><em>我</em></strong>：老妈，今晚舅妈有事儿，我带小宝贝，你给我送点饭。</p>
<p><strong><em>老妈</em></strong>：你中午剩的饭你热热就好啦。</p>
<p><strong><em>我</em></strong> ： 。。。那我叫外卖。。</p>
<p><strong><em>老妈</em></strong> ： 那我也去吃 😌</p>
<p>– The End –</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近家里人感冒的多，姐姐的双胞胎，小的那个被我们带到舅舅家。&lt;/p&gt;
&lt;p&gt;中午，我去我妈那里;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;我&lt;/em&gt;&lt;/strong&gt;：老妈，今晚舅妈有事儿，我带小宝贝，你给我送点饭。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;老妈&lt;/em&gt;&lt;/
    
    </summary>
    
    
      <category term="生活细节" scheme="http://yoursite.com/tags/%E7%94%9F%E6%B4%BB%E7%BB%86%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>Linux 上搭建 Anaconda, 远程访问 juypter</title>
    <link href="http://yoursite.com/2017/05/05/Linux-%E4%B8%8A%E6%90%AD%E5%BB%BA-Anaconda-%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE-juypter/"/>
    <id>http://yoursite.com/2017/05/05/Linux-上搭建-Anaconda-远程访问-juypter/</id>
    <published>2017-05-05T09:10:35.000Z</published>
    <updated>2017-05-05T09:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是-Anaconda"><a href="#1-什么是-Anaconda" class="headerlink" title="1 什么是 Anaconda"></a>1 什么是 Anaconda</h3><p>Anaconda 能让你轻松安装在数据科学工作中经常使用的包。你还将使用它创建虚拟环境，以便更轻松地处理多个项目。Anaconda 简化了我的工作流程，并且解决了我在处理包和多个 Python 版本时遇到的大量问题。</p>
<a id="more"></a>
<p>Anaconda 实际上是一个软件发行版，它附带了 conda、Python 和 150 多个科学包及其依赖项。应用程序 conda 是包和环境管理器。Anaconda 的下载文件比较大（约 500 MB），因为它附带了 Python 中最常用的数据科学包。如果只需要某些包，或者需要节省带宽或存储空间，也可以使用 Miniconda 这个较小的发行版（仅包含 conda 和 Python）。你仍可以使用 conda 来安装任何可用的包，它只是没有附带这些包而已。</p>
<p>除了管理包之外，conda 还是虚拟环境管理器。它类似于另外两个很流行的环境管理器，即 virtualenv 和 pyenv</p>
<p>环境能让你分隔你要用于不同项目的包。你常常要使用依赖于某个库的不同版本的代码。例如，你的代码可能使用了 Numpy 中的新功能，或者使用了已删除的旧功能。实际上，不可能同时安装两个 Numpy 版本。你要做的应该是，为每个 Numpy 版本创建一个环境，然后在适用于项目的环境中工作。</p>
<p>在应对 Python 2 和 Python 3 时，此问题也会常常发生。你可能会使用在 Python 3 中不能运行的旧代码，以及在 Python 2 中不能运行的新代码。同时安装两个版本可能会造成许多混乱和错误。而创建独立的环境会好很多。</p>
<p>也可以将环境中的包的列表导出为文件，然后将该文件与代码包括在一起。这能让其他人轻松加载代码的所有依赖项。pip 提供了类似的功能，即 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip freeze &gt; requirements.txt。</div></pre></td></tr></table></figure>
<h3 id="2-为什么使用-conda-而不是-virtualenv"><a href="#2-为什么使用-conda-而不是-virtualenv" class="headerlink" title="2 为什么使用 conda 而不是 virtualenv?"></a>2 为什么使用 conda 而不是 virtualenv?</h3><p><img src="http://static.zybuluo.com/zhumin1990719/cgmj2er08c6xivvx1wmlni09/14937979458924.jpg" alt="14937979458924.jpg-832.6kB"></p>
<h3 id="3-安装过程"><a href="#3-安装过程" class="headerlink" title="3 安装过程"></a>3 安装过程</h3><h4 id="1-下载-，上传到机器"><a href="#1-下载-，上传到机器" class="headerlink" title="1 下载 ，上传到机器"></a>1 下载 ，上传到机器</h4><p>你也可以在机器 <code>wget</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">https://repo.continuum.io/archive/Anaconda2-4.3.1-Linux-x86_64.sh</div></pre></td></tr></table></figure>
<h4 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh Anaconda2-4.3.1-Linux-x86_64.sh</div></pre></td></tr></table></figure>
<p>选择安装目录。为了节约 根目录空间，安装在</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># 目录事先必须不存在</div><div class="line">/data/min.zhu/anaconda2</div></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/zhumin1990719/trullxxzkf24s8z8xbhppybo/14937997286423.jpg" alt="14937997286423.jpg-166kB"></p>
<p>下面</p>
<p>source 一下 <code>.bashrc</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure>
<h4 id="3-设置国内Anaconda源"><a href="#3-设置国内Anaconda源" class="headerlink" title="3 设置国内Anaconda源"></a>3 设置国内Anaconda源</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 添加Anaconda的TUNA镜像</span></div><div class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</div><div class="line"><span class="comment"># TUNA的help中镜像地址加有引号，需要去掉# 设置搜索时显示通道地址</span></div><div class="line">conda config --set show_channel_urls yes</div></pre></td></tr></table></figure>
<h4 id="4-安装需要的环境"><a href="#4-安装需要的环境" class="headerlink" title="4 安装需要的环境"></a>4 安装需要的环境</h4><p>比如安装 3.5 的python</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conda create -n lr3 python=3.5</div></pre></td></tr></table></figure>
<p>激活</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">source activate lr3</div></pre></td></tr></table></figure>
<p>之后进入虚拟环境</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/us41d1smtqaxgfxt558kbeyn/14927645672574.jpg" alt="14927645672574.jpg-153.7kB"></p>
<p>可以在通过 <code>conda</code> 进行包的管理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">conda install xxx</div></pre></td></tr></table></figure>
<h4 id="5-修改-pip-源为阿里源"><a href="#5-修改-pip-源为阿里源" class="headerlink" title="5 修改 pip 源为阿里源"></a>5 修改 pip 源为阿里源</h4><p>因为有些包点评直接就没有 比如 <code>tflearn</code> 和 <code>tensorflow</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">vim ~/.pip/pip.conf</div><div class="line">trusted-host=mirrors.aliyun.com</div><div class="line">index-url=http://mirrors.aliyun.com/pypi/simple/</div></pre></td></tr></table></figure>
<h4 id="6-远程juypter-访问"><a href="#6-远程juypter-访问" class="headerlink" title="6 远程juypter 访问"></a>6 远程juypter 访问</h4><p>首先，不建议使用root , 当你使用 root 的时候，需要使用如下方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jupyter notebook --allow-root</div></pre></td></tr></table></figure>
<p>第二，远程服务器访问需要做一些配置</p>
<p>可以参考如下文章</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://blog.leanote.com/post/jevonswang/远程访问jupyter-notebook</div></pre></td></tr></table></figure>
<p>进行配置</p>
<h3 id="4-管理环境"><a href="#4-管理环境" class="headerlink" title="4 管理环境"></a>4 管理环境</h3><p>如果你安装了多个环境，但是不记得名字，或者想修改的话，通过 <code>conda-env</code> 这个命令就可以看到你所有的环境了。 可以看到附带所有操作<br><img src="http://static.zybuluo.com/zhumin1990719/87mdmv1tpyp79dnmy8mdzhye/14931020058855.jpg" alt="14931020058855.jpg-188.6kB"></p>
<p>比如 <code>conda-env list</code> 就是查看所有命令的格式</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-什么是-Anaconda&quot;&gt;&lt;a href=&quot;#1-什么是-Anaconda&quot; class=&quot;headerlink&quot; title=&quot;1 什么是 Anaconda&quot;&gt;&lt;/a&gt;1 什么是 Anaconda&lt;/h3&gt;&lt;p&gt;Anaconda 能让你轻松安装在数据科学工作中经常使用的包。你还将使用它创建虚拟环境，以便更轻松地处理多个项目。Anaconda 简化了我的工作流程，并且解决了我在处理包和多个 Python 版本时遇到的大量问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="conda" scheme="http://yoursite.com/tags/conda/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 6.x 如何升级 glibc 2.17</title>
    <link href="http://yoursite.com/2017/05/05/CentOS-6-x-%E5%A6%82%E4%BD%95%E5%8D%87%E7%BA%A7-glibc-2-17/"/>
    <id>http://yoursite.com/2017/05/05/CentOS-6-x-如何升级-glibc-2-17/</id>
    <published>2017-05-05T08:55:00.000Z</published>
    <updated>2017-05-05T10:04:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>本文描述如何在 <code>CentOS 6.x</code> 升级蛋疼的 <code>glibc 2.17</code>.</p>
<p>学习机器的内容，需要用到 <code>tensorFlow</code>, 在自己 <code>Mac</code> 上跑太心疼了。 于是尝试在公司的测试机上跑。然而我搭建好 <code>conda</code>, <code>jupyter notebook</code> , 引入 <code>tf</code> 的时候报错。<br>（关于如何 安装科学计算环境，以及远程访问 <code>jupyter notebook</code>, 请看下一篇文章）</p>
<p>如下<br><img src="http://static.zybuluo.com/zhumin1990719/1qx1afr47y8ok3gyzwlqobeu/image_1bfbrng2h1mgr110uuqj1l0239n9.png" alt="image_1bfbrng2h1mgr110uuqj1l0239n9.png-26.6kB"></p>
<a id="more"></a>
<p>在一看机器上的情况 最高只有 2.15<br><img src="http://static.zybuluo.com/zhumin1990719/iey92s8tqlehk14a5dddq5lo/image_1bfbrqvjh3eg1qjl1g0i1d1r3kvm.png" alt="image_1bfbrqvjh3eg1qjl1g0i1d1r3kvm.png-55.9kB"></p>
<p>其实已经是运维升级过了的，默认只到 12。主要还是我们的系统版本太低。</p>
<blockquote>
<p>CentOS 7.X，GLIBC 已经到 <code>2.17</code>，GCC 也是 <code>4.8.5</code><br>但是对于公司来说，稳定是第一位的。所以。。。</p>
</blockquote>
<h2 id="如何安装"><a href="#如何安装" class="headerlink" title="如何安装"></a>如何安装</h2><p>两种方法，一种源码编译，一种是用 rpm 来安装，之前看到这篇文章<a href="http://blog.ttionya.com/article-1559.html" target="_blank" rel="external">点这里</a>，其实说的还蛮好的，但是只是升级到 <code>2.15</code>， 而最新的 <code>tf 1.1</code> 版本，需要 <code>2.17</code> 的版本。</p>
<p>其实问题最大的就是找不到给 <code>CentOS 6.x</code> 用的 <code>2.17</code> 的 <code>rpm</code> 包，直到今日，我搜到了有人昨天发布一段脚本，才算找到了解决方法<br>，直接给链接 <a href="https://gist.github.com/harv/f86690fcad94f655906ee9e37c85b174" target="_blank" rel="external">感激万分的点这里</a></p>
<p>你不愿点看，我就写下来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#! /bin/sh</div><div class="line"></div><div class="line"># update glibc to 2.17 for CentOS 6</div><div class="line"></div><div class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-2.17-55.el6.x86_64.rpm</div><div class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-common-2.17-55.el6.x86_64.rpm</div><div class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-devel-2.17-55.el6.x86_64.rpm</div><div class="line">wget http://copr-be.cloud.fedoraproject.org/results/mosquito/myrepo-el6/epel-6-x86_64/glibc-2.17-55.fc20/glibc-headers-2.17-55.el6.x86_64.rpm</div><div class="line"></div><div class="line">sudo rpm -Uvh glibc-2.17-55.el6.x86_64.rpm \</div><div class="line">glibc-common-2.17-55.el6.x86_64.rpm \</div><div class="line">glibc-devel-2.17-55.el6.x86_64.rpm \</div><div class="line">glibc-headers-2.17-55.el6.x86_64.rpm</div></pre></td></tr></table></figure>
<p>其实就是下载资源，然后用 <code>rpm</code> 安装。</p>
<h2 id="可能遇到的错误"><a href="#可能遇到的错误" class="headerlink" title="可能遇到的错误"></a>可能遇到的错误</h2><p>当你执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">rpm -Uvh glibc-2.17-55.el6.x86_64.rpm \ </div><div class="line">glibc-common-2.17-55.el6.x86_64.rpm \ </div><div class="line">glibc-devel-2.17-55.el6.x86_64.rpm \ </div><div class="line">glibc-headers-2.17-55.el6.x86_64.rpm</div></pre></td></tr></table></figure>
<p>的时候会报错</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/qbu7fz3fl6784ng3k9nv7dkm/image_1bfbsmbs2h3m1o5t163o1luhkhe13.png" alt="image_1bfbsmbs2h3m1o5t163o1luhkhe13.png-84.4kB"></p>
<p>解决方案：<br>命令结尾加上参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--force --nodeps</div></pre></td></tr></table></figure>
<p>原因可以看这篇文章 <a href="http://blog.csdn.net/wulantian/article/details/8804696" target="_blank" rel="external">点这里</a>，造成这个问题的主要原因是套件被重複 (强制) 安装了两次以上. 可以用上面的命令进行依赖忽略，也可以卸载。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>搜索的关键词真的很重要，谷歌很重要，英语很重要。</li>
<li>运气很重要(这个问题折腾我两个礼拜)</li>
<li>别用百度搜技术问题。</li>
</ul>
<h2 id="还有，如果你手动编译安装glibc。。。。"><a href="#还有，如果你手动编译安装glibc。。。。" class="headerlink" title="还有，如果你手动编译安装glibc。。。。"></a>还有，如果你手动编译安装glibc。。。。</h2><p>万一你安装失败就会导致系统各种命令无法执行。。千万别退出。。你一旦退出，就无法登陆了，只能用光盘恢复系统了。。</p>
<p>但是这篇文章里的方法，可以试一试 <a href="https://cnodejs.org/topic/56dc21f1502596633dc2c3dc" target="_blank" rel="external">解决方法</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;本文描述如何在 &lt;code&gt;CentOS 6.x&lt;/code&gt; 升级蛋疼的 &lt;code&gt;glibc 2.17&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;学习机器的内容，需要用到 &lt;code&gt;tensorFlow&lt;/code&gt;, 在自己 &lt;code&gt;Mac&lt;/code&gt; 上跑太心疼了。 于是尝试在公司的测试机上跑。然而我搭建好 &lt;code&gt;conda&lt;/code&gt;, &lt;code&gt;jupyter notebook&lt;/code&gt; , 引入 &lt;code&gt;tf&lt;/code&gt; 的时候报错。&lt;br&gt;（关于如何 安装科学计算环境，以及远程访问 &lt;code&gt;jupyter notebook&lt;/code&gt;, 请看下一篇文章）&lt;/p&gt;
&lt;p&gt;如下&lt;br&gt;&lt;img src=&quot;http://static.zybuluo.com/zhumin1990719/1qx1afr47y8ok3gyzwlqobeu/image_1bfbrng2h1mgr110uuqj1l0239n9.png&quot; alt=&quot;image_1bfbrng2h1mgr110uuqj1l0239n9.png-26.6kB&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>jdk8 一个颠覆了面向对象认知的例子</title>
    <link href="http://yoursite.com/2017/05/03/jdk8-%E4%B8%80%E4%B8%AA%E9%A2%A0%E8%A6%86%E4%BA%86%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%A4%E7%9F%A5%E7%9A%84%E4%BE%8B%E5%AD%90/"/>
    <id>http://yoursite.com/2017/05/03/jdk8-一个颠覆了面向对象认知的例子/</id>
    <published>2017-05-03T15:27:20.000Z</published>
    <updated>2017-05-03T15:35:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-起源"><a href="#1-起源" class="headerlink" title="1 起源"></a>1 起源</h2><p>如果你看了上一篇文章关于 <code>Spliterator</code> 分割迭代器，最后一部分说到了图中的两个强制转换逻辑的不合理之处。</p>
<ul>
<li>第一处，我传入的是一个 <code>Consumer</code> 接口，但是判断的情况却是判断 </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">action <span class="keyword">instanceof</span>  IntConsumer</div></pre></td></tr></table></figure>
<p>而 IntConsumer 和 Consumer 是没有继承关系的平行函数式接口。这样的转换为何会成功？</p>
<ul>
<li>第二处，当第一个判断条件不满足的是时候，使用（IntConsumer）强转 <code>lambda</code> 表达式，这样为何能成功被需要传入 <code>IntConsumer</code> 函数所接受呢？</li>
</ul>
<p>如下图：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/b5fvbgzis7apng5pcmv4rxfj/image_1bf48rn8nbi1lrs1hgq1f72ass1t.png" alt="image_1bf48rn8nbi1lrs1hgq1f72ass1t.png-236.6kB"></p>
<a id="more"></a>
<h2 id="2-尝试解释看看喽"><a href="#2-尝试解释看看喽" class="headerlink" title="2 尝试解释看看喽"></a>2 尝试解释看看喽</h2><h3 id="先看第二处：lambda表达式也可以强转？"><a href="#先看第二处：lambda表达式也可以强转？" class="headerlink" title="先看第二处：lambda表达式也可以强转？"></a>先看第二处：lambda表达式也可以强转？</h3><p>我们先写一个类似的例子，有一个需要传入 <code>Consumer</code> 的方法，我们尝试传入一个 <code>IntConsumer</code> 会发生什么情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> Integer&gt; consumer)</span> </span>&#123;</div><div class="line">        System.out.println(consumer <span class="keyword">instanceof</span> IntConsumer);</div><div class="line">        consumer.accept(<span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        ConsumerTest consumerTest = <span class="keyword">new</span> ConsumerTest();</div><div class="line"></div><div class="line">        Consumer&lt;Integer&gt; consumer = i -&gt; System.out.println(i);</div><div class="line">        IntConsumer intConsumer = i -&gt; System.out.println(i);</div><div class="line"></div><div class="line">        consumerTest.test(consumer);  <span class="comment">// 面向对象的方式</span></div><div class="line">        consumerTest.test(consumer::accept); <span class="comment">// 函数式的方式</span></div><div class="line">        consumerTest.test(intConsumer::accept); <span class="comment">// 函数式的方式</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子的输出结果是：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/twikzu01ww4e7t9u8x63tw9h/image_1bf77758l13l11agu1ekeshv1134l.png" alt="image_1bf77758l13l11agu1ekeshv1134l.png-28kB"></p>
<p>我们发现这三种传入方式都是可以的，第一第二种没什么好说的，因为 <code>Test</code> 方法就是需要传入一个 <code>Consumer</code>， 无论你使用原来传递对象的方式，还是通过方法引用的方法，都是没有问题，可以被执行。</p>
<p>问题在于，第三种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">consumerTest.test(intConsumer::accept); <span class="comment">// 函数式的方式</span></div></pre></td></tr></table></figure>
<p>当你按住 command 把鼠标放在双冒号的时候 出现的如下：<br><img src="http://static.zybuluo.com/zhumin1990719/kk9ld6ktzbhctlv3xitujalv/image_1bf7diai619ibfi64uk13hp1viv1s.png" alt="image_1bf7diai619ibfi64uk13hp1viv1s.png-121.5kB"></p>
<p>当你按住 command 把鼠标放在的 <code>accept</code> 时候 出现的如下：<br><img src="http://static.zybuluo.com/zhumin1990719/wne2ek9nxhs90tx5zygzc7cc/image_1bf7dhepa1cpp7gi28b1r7v1m3r1f.png" alt="image_1bf7dhepa1cpp7gi28b1r7v1m3r1f.png-155.1kB"></p>
<p>双冒号代表是的当前 <code>lambda</code> 表达式的类型。因为你看我初始化两个consumer的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Integer&gt; consumer = i -&gt; System.out.println(i);</div><div class="line">IntConsumer intConsumer = i -&gt; System.out.println(i);</div></pre></td></tr></table></figure>
<p>我后面的表达式是一模一样的。但是却可以赋予两个不同的类型。<br>所以，重点来了</p>
<blockquote>
<p>重点是 lambda 表达式的类型，<code>是要靠上下文进行推断的</code>。</p>
</blockquote>
<p>这个是和传统面向的编程不一样的地方。需要注意。<br>刚刚上面的第三种调用的方式，就是如此，编译器推断出，你这个 <code>lambda</code> 表达式 <code>intConsumer::accept</code> 肯定是 <code>Consumer&lt;T super Integer&gt;</code> 类型的。所以不报错而这个时候如果你前面加一个强制转换，就像文章一开始的那张图的第二个强转逻辑一样，也是可以的。不过，略显多余就是了。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/s65e3diseksbvgh87sgxu6t5/image_1bf7e1upp1aa69mamubh2krap29.png" alt="image_1bf7e1upp1aa69mamubh2krap29.png-57.5kB"></p>
<h3 id="在看第一处"><a href="#在看第一处" class="headerlink" title="在看第一处"></a>在看第一处</h3><p>那么什么情况下，才会出现第一种情况，传入的是 <code>Consumer</code> ，但却同时是 <code>instanceof IntConsumer</code> 呢？</p>
<p>对了！（对什么对，你又没想到）就是这样，你同时继承者两个接口就可以了呀！</p>
<p>上代码！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by charleszhu on 2017/5/2.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</div><div class="line">    <span class="comment">// 要求传入 Consumer</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInt</span><span class="params">(Consumer&lt;Integer&gt; consumer)</span> </span>&#123;</div><div class="line">        <span class="comment">// 判断是否为 IntConsumer</span></div><div class="line">        System.out.println(consumer <span class="keyword">instanceof</span> IntConsumer);</div><div class="line">        consumer.accept(<span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        ConsumerTest consumerTest = <span class="keyword">new</span> ConsumerTest();</div><div class="line"></div><div class="line">        consumerTest.testInt(<span class="keyword">new</span> MyConsumer2&lt;&gt;());</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 同时实现两个方法</div><div class="line"> * <span class="doctag">@param</span> &lt;Integer&gt;</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyConsumer2</span>&lt;<span class="title">Integer</span>&gt; <span class="keyword">implements</span> <span class="title">IntConsumer</span>, <span class="title">Consumer</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        System.out.println(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer t)</span> </span>&#123;</div><div class="line">        System.out.println(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行一下结果：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/sfq22rxzqdmtkaqpnlpiqeko/image_1bf7ehq7bgaj1qrg8k61eiq1e1b2m.png" alt="image_1bf7ehq7bgaj1qrg8k61eiq1e1b2m.png-28.5kB"></p>
<p>就可以发现，这个时候就和开头的那个例子中的，第一处转换： 需要传入的是 <code>Consumer</code>, 但是也是 <code>IntConsumer</code> 的实例，就会进入第一个判断了</p>
<p>至此两个强转就解释完毕了！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个例子想给大家说的就是函数式接口的很传统的命令式编程还是有一定差别的。尤其是 <code>lambda</code> 表达式的类型是要靠上下文推断的这一点，需要好好的理解~</p>
<p>只有慢慢理解这些，才能真正理解函数式编程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-起源&quot;&gt;&lt;a href=&quot;#1-起源&quot; class=&quot;headerlink&quot; title=&quot;1 起源&quot;&gt;&lt;/a&gt;1 起源&lt;/h2&gt;&lt;p&gt;如果你看了上一篇文章关于 &lt;code&gt;Spliterator&lt;/code&gt; 分割迭代器，最后一部分说到了图中的两个强制转换逻辑的不合理之处。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一处，我传入的是一个 &lt;code&gt;Consumer&lt;/code&gt; 接口，但是判断的情况却是判断 &lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;action &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt;  IntConsumer&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而 IntConsumer 和 Consumer 是没有继承关系的平行函数式接口。这样的转换为何会成功？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第二处，当第一个判断条件不满足的是时候，使用（IntConsumer）强转 &lt;code&gt;lambda&lt;/code&gt; 表达式，这样为何能成功被需要传入 &lt;code&gt;IntConsumer&lt;/code&gt; 函数所接受呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/zhumin1990719/b5fvbgzis7apng5pcmv4rxfj/image_1bf48rn8nbi1lrs1hgq1f72ass1t.png&quot; alt=&quot;image_1bf48rn8nbi1lrs1hgq1f72ass1t.png-236.6kB&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8 Stream 解析2 - Spliterator分割迭代器</title>
    <link href="http://yoursite.com/2017/05/02/jdk8-Stream-%E8%A7%A3%E6%9E%902-Spliterator%E5%88%86%E5%89%B2%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://yoursite.com/2017/05/02/jdk8-Stream-解析2-Spliterator分割迭代器/</id>
    <published>2017-05-02T09:48:43.000Z</published>
    <updated>2017-05-02T09:57:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>说完<code>Stream</code> 的一些源码解析。我们看下我们的 <code>Stream</code> 是如何产生的。我们最为常见的流的产生方式是 <code>collection.stream()</code>, 你点开<code>Stream()</code>方法, 他是通过 <code>Collection</code> 这个上层接口两个java8 新增特性 <code>default method</code> 进行实现。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/x7mirnxozw9czo58sgxezv03/image_1bf3u1l911o5rf825gv39aqe9.png" alt="image_1bf3u1l911o5rf825gv39aqe9.png-41.3kB"></p>
<p>这就牵扯到一个关键要点 <code>Spliterator</code> ：分割迭代器。</p>
<p>本文主要描述 <code>Spliterator</code> 的作用，大部分来源于你不愿意读的 <code>JavaDoc</code>。</p>
<p><code>Spliterator</code> 是 <code>jdk8</code> 非常重要的概念。里面的细节很值得学习玩味。</p>
<a id="more"></a>
<h2 id="Spliterator-冗长的JavaDoc-说了什么？"><a href="#Spliterator-冗长的JavaDoc-说了什么？" class="headerlink" title="Spliterator 冗长的JavaDoc 说了什么？"></a>Spliterator 冗长的JavaDoc 说了什么？</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><code>Spliterator</code> 是一个对源（数组，集合，io流等等）中元素进行遍历和分区的类。</p>
<p>可以通过 <code>tryAdvance()</code> 方法逐个遍历，也可以按照 <code>forEachRemaining()</code> 方法进行按 <em>bulk</em> 逐块的遍历。（内部调用的还是<em>tryAdvance</em>）</p>
<p><code>Spliterator</code> 有类似 <code>Collector</code> 中的 <code>characteristics</code> , 但都是由十六进制来表示的。</p>
<blockquote>
<ul>
<li>SIZED :表示大小固定, Collection常用</li>
<li>DISTINCT : 去重, Set常用</li>
<li>SORTED : 有顺序的 SortedSet 会用<br>等等</li>
</ul>
</blockquote>
<h3 id="原生类型的特化版本"><a href="#原生类型的特化版本" class="headerlink" title="原生类型的特化版本"></a>原生类型的特化版本</h3><p>特化分割迭代器也被提供，和Stream类似。减少装箱和拆箱的操作<br><img src="http://static.zybuluo.com/zhumin1990719/fdux697e4pizzdyhgfsb51lx/image_1bf3vbfdl10r5vl7ef8t47kium.png" alt="image_1bf3vbfdl10r5vl7ef8t47kium.png-128.9kB"></p>
<h3 id="比迭代器Iterator-更加高效的遍历元素的方式"><a href="#比迭代器Iterator-更加高效的遍历元素的方式" class="headerlink" title="比迭代器Iterator 更加高效的遍历元素的方式"></a>比迭代器Iterator 更加高效的遍历元素的方式</h3><p>提供更加高效的方法，进行数据的迭代。<br><code>Iterator</code> 的使用需要调用两个组合方法 <code>hasNext()</code> 以及 <code>next()</code> ，同事在多线程访问的情况下还会出现竞争，你需要去同步。<br>而分割迭代器 <code>Spliterator</code> 使用函数式编程的方式，只用一个方法就可以做到这个两个函数动作。就避免了竞争 ，就是 <code>tryAdvance()</code> 方法。后面会介绍</p>
<h2 id="Spliterator的接口方法"><a href="#Spliterator的接口方法" class="headerlink" title="Spliterator的接口方法"></a>Spliterator的接口方法</h2><h3 id="tryAdvance"><a href="#tryAdvance" class="headerlink" title="tryAdvance()"></a>tryAdvance()</h3><p>同时做了  <code>hasNext()</code> 以及 <code>next()</code> 的工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 对给定的元素进行判断，如果满足条件就会执行 Action</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="forEachRemaining"><a href="#forEachRemaining" class="headerlink" title="forEachRemaining()"></a>forEachRemaining()</h3><p>是一个<code>默认方法</code>，对余下的元素进行操作，直到元素全部被遍历完<br>一般情况下回直接调用上面的<code>tryAdvance()</code> 方法，但是也可以更具需要进行重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 对余下的元素进行操作，直到元素全部被遍历完</div><div class="line">* 如果源是有序的，遍历也是有序的</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</div><div class="line">        <span class="keyword">do</span> &#123; &#125; <span class="keyword">while</span> (tryAdvance(action));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里有一点很值得注意，方法体中的 <code>do {}</code> 是空的，这个是因为 <code>tryAdvance()</code> 方法本身就完成了两个操作 <code>hasNext()</code> 以及 <code>next()</code>，所以方法体中不需要有任何操作了。这个是 函数式编程带来的好处。以及与命令式编程的区别。</p>
</blockquote>
<h3 id="trySplit"><a href="#trySplit" class="headerlink" title="trySplit()"></a>trySplit()</h3><p>尝试切分源来的 <code>Spliterator</code>， 返回的是（注意！！！）返回的是 <strong><code>分割出来的那一部分</code></strong> 数据，原有的数据集将不在包含这部分数据集合。两者 <code>没有交集</code>。剩下的可以继续分割，也许不可以继续分割了</p>
<blockquote>
<p>举个例子，我原来有 100个元素，我通过 <code>trySplit</code> 切分出 <code>30</code> 个，作为一个新的 <code>分割迭代器</code> 返回，原有的，就还剩下 <code>70</code> 个。</p>
</blockquote>
<ul>
<li>如果是原有数据集合是 <code>ORDERD</code> 的，分出来的也是有序的。</li>
<li>除非元素数量是无穷的，否则，最后一定会出现不能在分割的情况，这种情况下，返回的结果是 <code>null</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<h3 id="estimateSize"><a href="#estimateSize" class="headerlink" title="estimateSize()"></a>estimateSize()</h3><p>估算集合剩余给<code>forEachRemaining</code>大小，不一定精确。<br>但是如果这个 <code>Spliterator</code> 是 <code>SIZED</code>，没有被遍历或者 split， 或是 <code>SUBSIZED</code>的，没有被遍历，那么他这个值一定是准确的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure>
<p>还有个与之相关的默认方法，就是利用这个特性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">long</span> <span class="title">getExactSizeIfKnown</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (characteristics() &amp; SIZED) == <span class="number">0</span> ? -<span class="number">1L</span> : estimateSize();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="characteristics"><a href="#characteristics" class="headerlink" title="characteristics()"></a>characteristics()</h3><p>表示集合的特性，一共8个。</p>
<ul>
<li>分割之前，返回的结果都是一致的</li>
</ul>
<blockquote>
<p>如果返回结果不一致，则操作是不受保证的</p>
</blockquote>
<ul>
<li>而分割之后，不保证一致</li>
</ul>
<p>有一个默认方法用于判断 <code>Spliterator</code> 是否包含这个特性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">hasCharacteristics</span><span class="params">(<span class="keyword">int</span> characteristics)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (characteristics() &amp; characteristics) == characteristics;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h3 id="getComparator"><a href="#getComparator" class="headerlink" title="getComparator"></a>getComparator</h3><p>如果源是<code>SORTED</code> 类型的，且有比较器 <code>Comparator</code> 的话，则返回这个 <code>Comparator</code>，如果是<code>SORTED</code> 类型的，但是没有比较器，则返回 <code>null</code> , 除此之外，都抛出异常</p>
<p>接口的默认方法里，就是抛出了异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">default Comparator&lt;? super T&gt; getComparator() &#123;</div><div class="line">        throw new IllegalStateException();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="Spliterator的8个Characteristics-特性"><a href="#Spliterator的8个Characteristics-特性" class="headerlink" title="Spliterator的8个Characteristics 特性"></a>Spliterator的8个Characteristics 特性</h2><h3 id="ORDERED"><a href="#ORDERED" class="headerlink" title="ORDERED"></a>ORDERED</h3><p>源的元素有序，<code>tryAdvance</code> ，<code>forEachRemaining</code>和 <code>trySplit</code> 都会保证有序的进行元素的处理</p>
<ul>
<li>需要注意 <code>hashSet</code> 这类 <code>Collection</code> 是不保证有序的</li>
<li>有<code>ORDERED</code> 特性的数据，在并发计算的时候客户端也要做顺序限制的保证</li>
</ul>
<h3 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h3><p>太简单，唯一性。 类似 <code>Set</code> 这样的传入集合会拥有这样的特性</p>
<h3 id="SORTED"><a href="#SORTED" class="headerlink" title="SORTED"></a>SORTED</h3><p>有这种特性的 <code>Spliterator</code> ，有一个特定的顺序。或者是所有元素都是可比较的，或者是有特定的比较器。</p>
<ul>
<li>有 <code>SORTED</code> 一定会有 <code>ORDERED</code></li>
</ul>
<h3 id="SIZED"><a href="#SIZED" class="headerlink" title="SIZED"></a>SIZED</h3><p>有这种属性的 <code>Spliterator</code> 在遍历和分割之前，<code>estimateSize()</code> 返回的大小是固定的，并且是准确的。</p>
<h3 id="NONNULL"><a href="#NONNULL" class="headerlink" title="NONNULL"></a>NONNULL</h3><p>不为 <code>NULL</code>, 大部分并发的集合，队列，Map 都可能会有这样的特性。</p>
<h3 id="IMMUTABLE"><a href="#IMMUTABLE" class="headerlink" title="IMMUTABLE"></a>IMMUTABLE</h3><p>不可变的。元素遍历期间不可以被 添加，替换，删除（cannot be added, replaced, or removed）<br>否则，应该抛出异常。</p>
<h3 id="CONCURRENT"><a href="#CONCURRENT" class="headerlink" title="CONCURRENT"></a>CONCURRENT</h3><p>支持并发操作的。 </p>
<ul>
<li>顶层的 <code>Spliterator</code> 不可以 <code>CONCURRENT</code> 与 <code>SIZED</code>。 这两者是相互冲突的。</li>
<li>但是分割之后的 <code>Spliterator</code> ， 可能是 <code>SIZED</code>， 顶层不能决定底层</li>
</ul>
<h3 id="SUBSIZED"><a href="#SUBSIZED" class="headerlink" title="SUBSIZED"></a>SUBSIZED</h3><p>从<code>trySplit()</code>被分割后的所有分割迭代器都是 <code>SIZED</code> 以及 <code>SUBSIZED</code> 的。<br>如果分割后，没有按照要求返回<code>SIZED</code> 以及 <code>SUBSIZED</code> 属性，那么操作是不被保证的，也就是结果不可预测。</p>
<blockquote>
<p>这个属性和 <code>SIZED</code> 的区别就是， <code>SIZED</code> 不保证 <code>SUBSIZED</code>。而 <code>SUBSIZED</code> 会要求保证 <code>SIZED</code></p>
</blockquote>
<h2 id="内部特化而做的函数式接口-OfPrimitive"><a href="#内部特化而做的函数式接口-OfPrimitive" class="headerlink" title="内部特化而做的函数式接口 (OfPrimitive)"></a>内部特化而做的函数式接口 (OfPrimitive)</h2><p>除了上面的函数，以及特性，<code>Spliterator</code> 迭代器中，还有几个定义在内部的接口。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/ai9cdxr36s7o0zv3bdb67d1r/image_1bf4821k2kft1nsq13981l5j1h1d13.png" alt="image_1bf4821k2kft1nsq13981l5j1h1d13.png-207.1kB"></p>
<p><code>OfPrimitive</code> 重载了（overloads）了 <code>Spliterator</code> 的方法。用于实现特化的分割迭代器。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/gj8uepdtipdysdlreaypan5n/image_1bf487rnqvk11cpuoeve911ss81g.png" alt="image_1bf487rnqvk11cpuoeve911ss81g.png-41.2kB"></p>
<blockquote>
<p><strong>overloads</strong>：返回类型名称一致，参数不一致。<br>注意与 <code>override</code> 的区别</p>
</blockquote>
<h3 id="一个颠覆面向对象编程常识的现象"><a href="#一个颠覆面向对象编程常识的现象" class="headerlink" title="一个颠覆面向对象编程常识的现象"></a>一个颠覆面向对象编程常识的现象</h3><p>请大家看图<br><img src="http://static.zybuluo.com/zhumin1990719/tr2zzp41rvb62w9t2xo1lb38/image_1bf48rn8nbi1lrs1hgq1f72ass1t.png" alt="image_1bf48rn8nbi1lrs1hgq1f72ass1t.png-236.6kB"></p>
<p>这两次类型转换奇怪的地方是：</p>
<p><code>IntConsumer</code> 与 <code>Consumer</code> 两个接口，没有继承关系，两个接口是平行的。 这样的转换，在之前是不可能成功的。 简直是颠覆认知啊！</p>
<blockquote>
<p>我悄悄说啊（并没有。。你也基本不会关心不是么。。）</p>
</blockquote>
<p>但是在函数式编程中能转换成功呢？ 你可以等我下一篇文章~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;说完&lt;code&gt;Stream&lt;/code&gt; 的一些源码解析。我们看下我们的 &lt;code&gt;Stream&lt;/code&gt; 是如何产生的。我们最为常见的流的产生方式是 &lt;code&gt;collection.stream()&lt;/code&gt;, 你点开&lt;code&gt;Stream()&lt;/code&gt;方法, 他是通过 &lt;code&gt;Collection&lt;/code&gt; 这个上层接口两个java8 新增特性 &lt;code&gt;default method&lt;/code&gt; 进行实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://static.zybuluo.com/zhumin1990719/x7mirnxozw9czo58sgxezv03/image_1bf3u1l911o5rf825gv39aqe9.png&quot; alt=&quot;image_1bf3u1l911o5rf825gv39aqe9.png-41.3kB&quot;&gt;&lt;/p&gt;
&lt;p&gt;这就牵扯到一个关键要点 &lt;code&gt;Spliterator&lt;/code&gt; ：分割迭代器。&lt;/p&gt;
&lt;p&gt;本文主要描述 &lt;code&gt;Spliterator&lt;/code&gt; 的作用，大部分来源于你不愿意读的 &lt;code&gt;JavaDoc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Spliterator&lt;/code&gt; 是 &lt;code&gt;jdk8&lt;/code&gt; 非常重要的概念。里面的细节很值得学习玩味。&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8 Stream &amp; BaseStream 源码难点浅析1</title>
    <link href="http://yoursite.com/2017/05/02/jdk8-Stream-BaseStream-%E6%BA%90%E7%A0%81%E9%9A%BE%E7%82%B9%E6%B5%85%E6%9E%901/"/>
    <id>http://yoursite.com/2017/05/02/jdk8-Stream-BaseStream-源码难点浅析1/</id>
    <published>2017-05-02T04:15:00.000Z</published>
    <updated>2017-05-02T04:27:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul>
<li>简要介绍 <code>Stream</code> 的 javadoc，与集合的关系以及区别，一些重要的注意事项</li>
<li>难懂的 <code>Stream</code> 类的声明，介绍比较难懂的 <code>onClose()</code> 方法的调用</li>
</ul>
<a id="more"></a>
<h2 id="Stream的javadoc"><a href="#Stream的javadoc" class="headerlink" title="Stream的javadoc"></a>Stream的javadoc</h2><h3 id="Stream-的作用与特化版本"><a href="#Stream-的作用与特化版本" class="headerlink" title="Stream 的作用与特化版本"></a>Stream 的作用与特化版本</h3><p>Stream 是对一个序列做 <code>串行</code> 或者 <code>并行</code> 聚合操作。他继承自 <code>Stream</code><br>Stream 同时还有几个特化的版本 ，<code>IntStream</code> , <code>LongStream</code>, <code>DoubleStream</code>. 他们为了减少流操作的时候一些不必要的装箱和拆箱的操作。</p>
<blockquote>
<p>需要注意的是，以上四个 <code>Stream</code> 是平行关系，他们都是继承自 <code>BaseStream</code></p>
</blockquote>
<p>举个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 将集合 widgets 中的元素中红色的元素的重量求和</div><div class="line">* 第一步 filter() 过滤红色</div><div class="line">* 第二步 mapToInt() 拿出所有的Red的重量，生成一个 IntStream</div><div class="line">* 第三步 sum() 求和，并返回</div><div class="line">*/</div><div class="line"><span class="keyword">int</span> sum = widgets.stream()</div><div class="line">                      .filter(w -&gt; w.getColor() == RED)</div><div class="line">                      .mapToInt(w -&gt; w.getWeight())</div><div class="line">                      .sum();</div></pre></td></tr></table></figure>
<h3 id="Stream-的组成与特点"><a href="#Stream-的组成与特点" class="headerlink" title="Stream 的组成与特点"></a>Stream 的组成与特点</h3><p>要想实现计算，所有操作，都会被放入一个 <code>pipeline</code> 当中（类似liunx）中的操作。</p>
<p>而一个流管道（pipeline）包含：</p>
<blockquote>
<ul>
<li>source(源)： 数组，集合，迭代器，I/O 操作等等</li>
<li>0个或者多个中间操作： 将一个流转成另外一个流</li>
<li>1个终止操作 : 产生一个结果(比如上面的例子中的求和) or 或者修改传入对象的属性。</li>
</ul>
</blockquote>
<p>流是Lazy的懒惰的！！ 你不加 <code>终止操作</code> 流的操作，就不会被执行。<br>如上面的例子，没有最后的 <code>Sum()</code> 函数，前面的操作是不会被执行的。</p>
<h3 id="集合和Stream-的区别"><a href="#集合和Stream-的区别" class="headerlink" title="集合和Stream 的区别"></a>集合和Stream 的区别</h3><p>集合： 注重存储，主要考虑元素的访问与管理<br>Stream ：注重计算，主要考虑以一种<code>描述性</code> 的语言来对源进行一系列的操作，并将操作聚合起来。</p>
<h3 id="流的注意事项"><a href="#流的注意事项" class="headerlink" title="流的注意事项"></a>流的注意事项</h3><p>1 流中的操作，都应是函数式接口（lambda表达式或者方法引用）<br>2 流不能被重用，每个流只能应用一次。想再次操作你需要重新生成一个流</p>
<p>3 流虽然实现了 <code>AutoCloseable</code> 接口，但是几乎所有的流都是不用关闭的，因为他的源大部分情况下都是集合，而集合是不用关闭的。</p>
<blockquote>
<p>除非源是一个 <code>I/O Channel</code>。 比如 Files.lines() 方法。<br>如果是这样，Stream 就可以申明在 <code>try-with-resources block</code> 中。<br>关于这个 <code>j7</code> 新接口的使用，可以看我之前的一篇关于 <code>AutoCloseable</code> 的介绍 <a href="http://movingon.cn/2017/05/02/jdk1-7%E6%96%B0%E5%A2%9E%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%8E%A5%E5%8F%A3AutoCloseable/" target="_blank" rel="external">jdk1.7新增自动关闭接口AutoCloseable</a></p>
</blockquote>
<p>多说一句，<code>Files.lines()</code> 是 j8 中新增的方法，有点类似 <code>python</code> 中 <code>readlines()</code> 方法。很好用。</p>
<h2 id="Stream-amp-BaseStream-解析"><a href="#Stream-amp-BaseStream-解析" class="headerlink" title="Stream &amp; BaseStream 解析"></a>Stream &amp; BaseStream 解析</h2><h3 id="看不懂的声明"><a href="#看不懂的声明" class="headerlink" title="看不懂的声明"></a>看不懂的声明</h3><p>我们可以看一下 <code>Stream</code> 以及 <code>BaseStream</code> 的类的声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//Stream</div><div class="line">public interface Stream&lt;T&gt; extends BaseStream&lt;T, Stream&lt;T&gt;&gt; </div><div class="line">//BaseStream</div><div class="line">public interface BaseStream&lt;T, S extends BaseStream&lt;T, S&gt;&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p><code>BaseStream</code> 中，第二个泛型是 <code>S extends BaseStream&lt;T, S&gt;</code> ，而 <code>Stream</code> 中，第二个泛型是 <code>Stream&lt;T&gt;</code>， 正好是满足 <code>extends BaseStream&lt;T, S&gt;</code> 的条件的，所以可以这么写。</p>
</blockquote>
<p>两个泛型有没有感觉有点晕。其实比较好理解。</p>
<ul>
<li><code>T</code> 这个泛型很好理解，就是流中元素的类型</li>
<li><code>S</code> ？</li>
</ul>
<p>如果你看过javadoc的描述，流的所有中间操作，都会返回一个流，而这个<code>S</code> 就代表着中间操作返回的流的类型。<br>比如我们看一下这个在 <code>Stream</code> 中的方法（其他方法与其一致）</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/m1x94rwz2ygkwzgfwbap4prp/image_1bf3j7bv61mi710k61td11d8l5o79.png" alt="image_1bf3j7bv61mi710k61td11d8l5o79.png-124.2kB"></p>
<h3 id="难懂的-onClose-方法"><a href="#难懂的-onClose-方法" class="headerlink" title="难懂的 onClose() 方法"></a>难懂的 onClose() 方法</h3><p>上面我们知道 <code>BaseStream</code> 实现了 <code>AutoCloseable</code> 接口，也就是 <code>Close()</code> 方法可以得到调用。但是 <code>BaseStream</code> 中，给我们提供了要给<code>OnClose()</code> 方法。我们看下截图</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/p8cudj4reir8u8t9eenmtrct/image_1bf3kmgk61641d2k1euk992t28m.png" alt="image_1bf3kmgk61641d2k1euk992t28m.png-165.3kB"></p>
<p>这个方法，就是当 <code>Close()</code> 方法被调用的时候 <code>onClose()</code>会被调用。但是有几个注意的点</p>
<blockquote>
<ul>
<li><code>onColse()</code> 方法也返回一个流，也就是说可以多次调用。</li>
<li>如果你写了多个<code>onClose()</code> 方法，它会按照顺序调用。</li>
<li>前一个 <code>onClose()</code> 方法除了异常不影响后续 <code>onClose</code> 方法的使用</li>
<li>如果多个 <code>onClose()</code> 方法都抛出异常，只展示第一个异常的堆栈，而其他异常会被压缩，只展示部分信息</li>
</ul>
</blockquote>
<p>上代码！！！！！！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by charleszhu on 2017/5/2.</div><div class="line"> */</div><div class="line">public class StreamTestOnCloseTest &#123;</div><div class="line">    </div><div class="line">    public static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        List&lt;String&gt; testString = Arrays.asList(&quot;min&quot;, &quot;ge&quot;, &quot;da&quot;, &quot;shuaibi&quot;);</div><div class="line"></div><div class="line">        /**</div><div class="line">         * 两次关闭</div><div class="line">         * 两次异常</div><div class="line">         * 预期：两次关闭输出依次打出；两次关闭异常只打印一次堆栈，另外一次只展示</div><div class="line">         */</div><div class="line">        try(Stream&lt;String&gt; stream = testString.stream()) &#123;</div><div class="line">            stream.onClose(() -&gt;&#123;</div><div class="line">                System.out.println(&quot;closing 1&quot;); //</div><div class="line">                throw new NullPointerException(&quot;exception 1&quot;);</div><div class="line">            &#125;).onClose(() -&gt; &#123;</div><div class="line">                System.out.println(&quot;closing 2&quot;);</div><div class="line">                throw new NullPointerException(&quot;exception 2&quot;);</div><div class="line">            &#125;).forEach(System.out::println);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果如下图：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/qzz76okwh4vyzc62m1u0ibuj/image_1bf3lgle8tfjq0nqm2jjd17hk13.png" alt="image_1bf3lgle8tfjq0nqm2jjd17hk13.png-149.2kB"></p>
<p>你们明白了吧（我是天才）</p>
<h3 id="好懂的其他方法"><a href="#好懂的其他方法" class="headerlink" title="好懂的其他方法"></a>好懂的其他方法</h3><p><code>BaseStream</code> 中有的一些其他方法，除了<strong><em>分割迭代器</em></strong>(后面会单独说，因为太重要)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Spliterator&lt;T&gt; spliterator();</div></pre></td></tr></table></figure>
<p>其他都比较好懂。值得一说的是以下两个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">S sequential(); // 返回串行流</div><div class="line">S parallel(); // 返回并行流</div></pre></td></tr></table></figure>
<p>你可以看到他们都返回流对象，也就是可以继续调用 <code>sequential</code> 或者 <code>parallel</code> 方法。但是！！！</p>
<blockquote>
<p>无论你中间怎么调用 ，比如 sequential.parallel.parallel.sequential…. </p>
<p><strong>只以最后一个为最终流的类型！！！</strong></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;简要介绍 &lt;code&gt;Stream&lt;/code&gt; 的 javadoc，与集合的关系以及区别，一些重要的注意事项&lt;/li&gt;
&lt;li&gt;难懂的 &lt;code&gt;Stream&lt;/code&gt; 类的声明，介绍比较难懂的 &lt;code&gt;onClose()&lt;/code&gt; 方法的调用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk1.7新增自动关闭接口AutoCloseable</title>
    <link href="http://yoursite.com/2017/05/02/jdk1-7%E6%96%B0%E5%A2%9E%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%8E%A5%E5%8F%A3AutoCloseable/"/>
    <id>http://yoursite.com/2017/05/02/jdk1-7新增自动关闭接口AutoCloseable/</id>
    <published>2017-05-02T01:13:09.000Z</published>
    <updated>2017-05-02T09:54:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-AutoCloseable-接口"><a href="#1-AutoCloseable-接口" class="headerlink" title="1 AutoCloseable 接口"></a>1 AutoCloseable 接口</h3><p>这是JDK1.7 的新增语法。帮助你自动关闭一些资源。可能你还不知道这个接口<br><img src="http://static.zybuluo.com/zhumin1990719/rydvwpav6zkm6jhel6244jxl/image_1bf3bdg6r6da1bha17s9cm81bej13.png" alt="image_1bf3bdg6r6da1bha17s9cm81bej13.png-90.6kB"></p>
<a id="more"></a>
<p>这个接口好就好在，只有一个方法，名叫 <code>close()</code>, 而这正好有是我们各个资源关闭的方法名，所以使用起来相当方便，因为名称一样，代码兼容。</p>
<p>JDK8 中就在很多地方应用了这个接口，比如 <code>Stream</code> 继承了 <code>BaseStream</code>，而 <code>BaseStream</code> 则继承了 <code>AutoCloseable</code> 这个接口。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/tmv8f7uvw289fjrfibxcr77y/image_1bf3avqeh1sjr8061aa9kr1bpc9.png" alt="image_1bf3avqeh1sjr8061aa9kr1bpc9.png-45.6kB"></p>
<p>这个接口的说明很清楚，当你在使用 <code>try-with-resources block</code> 这种语法调用来进行资源获取的时候，在 <code>block</code> 退出之后自动关闭</p>
<blockquote>
<p> <code>try-with-resources block</code>  代码块，就是将资源的声明，放在 <code>try</code> 里面； 可以看后面的代码示例</p>
</blockquote>
<p>你不用像之前写 <code>finally{}</code> 代码那样的进行关闭。就不会有资源未被释放的问题。</p>
<h3 id="2-测试代码"><a href="#2-测试代码" class="headerlink" title="2 测试代码"></a>2 测试代码</h3><p>简单测试代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by charleszhu on 2017/5/2.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoCloseAbleTest</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"doStm"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Close() 看到没，我被吊了"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * try-with-resources 语法块</div><div class="line">         */</div><div class="line">        <span class="keyword">try</span>(AutoCloseAbleTest autoCloseAbleTest = <span class="keyword">new</span> AutoCloseAbleTest()) &#123;</div><div class="line">            autoCloseAbleTest.doSth();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行一下，结果如下：<br><img src="http://static.zybuluo.com/zhumin1990719/c709aferpg4yr5myxks8txnu/image_1bf3bcj84433l37sm41vrf10dhm.png" alt="image_1bf3bcj84433l37sm41vrf10dhm.png-120.6kB"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-AutoCloseable-接口&quot;&gt;&lt;a href=&quot;#1-AutoCloseable-接口&quot; class=&quot;headerlink&quot; title=&quot;1 AutoCloseable 接口&quot;&gt;&lt;/a&gt;1 AutoCloseable 接口&lt;/h3&gt;&lt;p&gt;这是JDK1.7 的新增语法。帮助你自动关闭一些资源。可能你还不知道这个接口&lt;br&gt;&lt;img src=&quot;http://static.zybuluo.com/zhumin1990719/rydvwpav6zkm6jhel6244jxl/image_1bf3bdg6r6da1bha17s9cm81bej13.png&quot; alt=&quot;image_1bf3bdg6r6da1bha17s9cm81bej13.png-90.6kB&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>老版本MacBookPro (厚的) 格式化, U盘安装 MacOS Sierra</title>
    <link href="http://yoursite.com/2017/05/01/%E8%80%81%E7%89%88%E6%9C%ACMacBookPro-%E5%8E%9A%E7%9A%84-%E6%A0%BC%E5%BC%8F%E5%8C%96-U%E7%9B%98%E5%AE%89%E8%A3%85-MacOS-Sierra/"/>
    <id>http://yoursite.com/2017/05/01/老版本MacBookPro-厚的-格式化-U盘安装-MacOS-Sierra/</id>
    <published>2017-05-01T15:12:25.000Z</published>
    <updated>2017-05-02T00:51:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>主要写的点是：U 盘安装盘的制作，以及，为什么会有 </p>
<ul>
<li>can’t be verified</li>
<li>已损坏，重新下载</li>
</ul>
<p>这些问题，即使你是从 app store 中下载的完整版本。</p>
<a id="more"></a>
<p>前两天，我一个朋友拿了一台很老的 <code>MacBook pro</code> , 说他不小心格式化了硬盘，要我重装系统。。</p>
<p>电脑图如下。。<br><img src="http://static.zybuluo.com/zhumin1990719/ky6nya8775sxhivrqgdiqq7c/image_1bf10mmqp1ifr1lgpklstgs1h9o9.png" alt="image_1bf10mmqp1ifr1lgpklstgs1h9o9.png-308.8kB"></p>
<p>有点洁癖的我看到了想说说，要不你砸了吧（当然我没说。。）<br>但是碍于面子（毕竟我是程序员，外界都说是搞电脑的，约等于 修电脑的，近似于你是修电脑的，也就是说电脑相关的你全都会，不会就是大傻逼）。。</p>
<blockquote>
<p>我当然是很愤怒的，之所以没有发作是因为他是我老师。。</p>
</blockquote>
<h2 id="如何制作安装盘"><a href="#如何制作安装盘" class="headerlink" title="如何制作安装盘"></a>如何制作安装盘</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>你需要一下物品：</p>
<blockquote>
<ul>
<li>一个只要8G的U盘</li>
<li>一台工作良好的 macbook pro</li>
<li>良好的网络</li>
<li>我（你没戏了）</li>
</ul>
</blockquote>
<p>言归正传：</p>
<h3 id="步骤一-：-在App-Store-中下载最新的-macos"><a href="#步骤一-：-在App-Store-中下载最新的-macos" class="headerlink" title="步骤一 ： 在App Store 中下载最新的 macos"></a>步骤一 ： 在App Store 中下载最新的 macos</h3><p>连接如下 <a href="https://itunes.apple.com/cn/app/macos-sierra/id1127487414?mt=12" target="_blank" rel="external">下载地址</a><br>她会跳转到 app store. 点击下载即可。它会弹出提示让你更新啥的，不用管它，直接下载</p>
<p>下载好了之后，你在你的 <code>应用程序</code> 文件夹，你就可以看到这个了</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/y0agrs81opqu504ydcxb59nl/image_1bf1226d41kb315mb1ja21bi6fkbm.png" alt="image_1bf1226d41kb315mb1ja21bi6fkbm.png-253.8kB"></p>
<p>至此，你的第一任务完成。</p>
<h3 id="步骤二-：用磁盘工具格式化你的U盘"><a href="#步骤二-：用磁盘工具格式化你的U盘" class="headerlink" title="步骤二 ：用磁盘工具格式化你的U盘"></a>步骤二 ：用磁盘工具格式化你的U盘</h3><p>打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为<br>「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致。)</p>
<blockquote>
<p>如果不成功，你就多试几次</p>
</blockquote>
<h3 id="步骤三-：-制作安装盘"><a href="#步骤三-：-制作安装盘" class="headerlink" title="步骤三 ： 制作安装盘"></a>步骤三 ： 制作安装盘</h3><p>打开你的终端，输入如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /Applications/Install\ macOS\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\ macOS\ Sierra.app --nointeraction</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意空格前面需要有 <code>\</code> 进行转义</p>
</blockquote>
<p><img src="http://static.zybuluo.com/zhumin1990719/wx8yijvchu5smsimltbdgl9p/image_1bf28fv4l1uph1cvgv581u0uecs13.png" alt="image_1bf28fv4l1uph1cvgv581u0uecs13.png-51.3kB"></p>
<p>耐心得到 <code>done</code>,  你就可以拿着 U 盘去安装了</p>
<h2 id="无法验证？or-已经损坏？"><a href="#无法验证？or-已经损坏？" class="headerlink" title="无法验证？or 已经损坏？"></a>无法验证？or 已经损坏？</h2><p>重装的步骤简单，插入u盘，开机按住 <code>option</code>, 选择u 盘的安装盘。接下来选择安装就可以了。</p>
<p>但是，大部分情况下，都会遇到类似</p>
<blockquote>
<p> This copy of the Install OS X El Capitan application can’t be verified. It may have been corrupted or tampered with during downloading</p>
</blockquote>
<p><img src="http://static.zybuluo.com/zhumin1990719/v32y8u4lwltu78uco91rnee0/image_1bf28oaj5122pbej121d1nfgq831g.png" alt="image_1bf28oaj5122pbej121d1nfgq831g.png-57.5kB"></p>
<p>或者，直接告诉你损坏了，让你再去下载完整版本。</p>
<p>导致这个的原因是，当你决定将一台mac格式化后，在重装系统的时候，系统的时间已经被改变了。这个时候安装程序就会爆出各种错误。你可以通过 终端输入 date 进行查看，时间应该变成了 2001 年。</p>
<p>这个时候， 你只要通过 <code>date</code> 命令重置时间，就可以解决这个问题。<br>他的参数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">date MMDDHHmmYY replacing the letters as follows.</div><div class="line">MM - 2 digit month  01 - 12</div><div class="line">DD - 2 digit date   01 - 31</div><div class="line">HH - 2 digit hour   01 - 24</div><div class="line">mm - 2 digit minute 01 - 59</div><div class="line">YY - 2 digit year   &gt; 15</div></pre></td></tr></table></figure>
<p>你将时间设置成，你要安装的系统发布之后的一个时间后，退出终端，再次点击操作，就不会有问题。</p>
<p>你也可以看做这个视频 <a href="https://www.youtube.com/watch?v=LRPiynS15_U" target="_blank" rel="external">土逼视频</a> ，需要翻墙。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;主要写的点是：U 盘安装盘的制作，以及，为什么会有 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;can’t be verified&lt;/li&gt;
&lt;li&gt;已损坏，重新下载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些问题，即使你是从 app store 中下载的完整版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-32-groupingBy 源码分析</title>
    <link href="http://yoursite.com/2017/04/30/jdk8-32-groupingBy-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/04/30/jdk8-32-groupingBy-源码分析/</id>
    <published>2017-04-30T08:58:34.000Z</published>
    <updated>2017-04-30T09:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>jdk8 集合的工厂类 <code>Collectors</code> 提供了两个很好用的静态函数。</p>
<ul>
<li>groupingBy</li>
<li>partitioningBy</li>
</ul>
<a id="more"></a>
<p><code>groupingBy</code> 实现类似 Mysql 中分分组功能。返回一个 Map; 而 <code>partitioningBy</code>可以看做是 <code>groupingBy</code> 的特殊形式。我们后面会接着介绍。 使用的是比如统计每个城市人的“姓”，可以这么写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity,                                            mapping(Person::getLastName, toSet())));</div></pre></td></tr></table></figure>
<p>那么，他到底如何利用 <code>Collector</code> 的各个接口来实现的呢？下面我们将深入 JDK 的 <code>Collectors</code> 的源码中，分析一下他是如何工作的。 </p>
<h2 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h2><h3 id="1-第一个重载方法-要简单就别那么多要求，给你个List不错了"><a href="#1-第一个重载方法-要简单就别那么多要求，给你个List不错了" class="headerlink" title="1 第一个重载方法, 要简单就别那么多要求，给你个List不错了"></a>1 第一个重载方法, 要简单就别那么多要求，给你个List不错了</h3><p>分组 <code>groupingBy</code> 有三个重载方法。一个比一复杂。</p>
<p>先看最简单的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input elements</div><div class="line">     * <span class="doctag">@param</span> &lt;K&gt; the type of the keys</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</div><div class="line">    groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;</div><div class="line">        <span class="keyword">return</span> groupingBy(classifier, toList());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里 <code>T</code> 是输入集合的元素类型， <code>K</code> 是最后产生的 Map 的主键key 的类型。</p>
<p>函数需要传入一个 <code>Function</code> 的函数式接口，<code>Function</code> 的中作就是分类器，比如传入的类型是<code>T</code> 是一个 <code>Person</code>类型 ， 通过 <code>apply()</code> 方法，返回 <code>Person</code> 的属性 <code>name</code>；因为我们要按照 <code>name</code> 来分组。</p>
<p>所以，如果 <code>name</code> 的类型是 <code>String</code> ； 那么 <code>K</code> 就是 <code>String</code></p>
<p>故而，这个 <code>groupingBy(function)</code> 的功能就很清晰了，就是通过 <code>function</code> 对传入的 <code>T</code> 类型进行分类。然后调用 <code>toList()</code> 方法，也就是说每个分类的<code>Person</code> 会放进一个 <code>List&lt;Person&gt;</code> 中</p>
<p>最终返回的类型就是 <code>Map&lt;String, List&lt;Person&gt;&gt;</code>.</p>
<p>而如果你不想返回的是一个<code>List</code> , 希望是一个 <code>Set</code>. 你就要使用第二个重载方法~ 他允许你定义最后的输出函数。</p>
<h3 id="2-第二个重载方法：我要输出Set"><a href="#2-第二个重载方法：我要输出Set" class="headerlink" title="2 第二个重载方法：我要输出Set"></a>2 第二个重载方法：我要输出Set</h3><p>看一下函数的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input elements</div><div class="line">     * <span class="doctag">@param</span> &lt;K&gt; the type of the keys</div><div class="line">     * <span class="doctag">@param</span> &lt;A&gt; the intermediate accumulation type of the downstream collector</div><div class="line">     * <span class="doctag">@param</span> &lt;D&gt; the result type of the downstream reduction</div><div class="line">     * <span class="doctag">@param</span> classifier a classifier function mapping input elements to keys</div><div class="line">     * <span class="doctag">@param</span> downstream a &#123;<span class="doctag">@code</span> Collector&#125; implementing the downstream reduction</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt;</div><div class="line">    Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</div><div class="line">                                          Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</div><div class="line">        <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个函数，明显比上一个要复杂，可以看到，多了一个 <code>Collector</code> 的 <code>downstream</code> , 可以自定义输出的集合。上面那个简单版本的函数是是写死的 <code>List</code></p>
<p>这个函数有四个泛型。</p>
<ul>
<li><code>T</code> 原始元素类型，比如我们这是 <code>Person</code></li>
<li><code>K</code> 返回 Map 的 key, 即最终返回的Map 的建的类型。如果你想按照人的名字分类，那T就是 <code>String</code>, 如果按照年龄分类，那就是 <code>Interger</code></li>
<li><code>A</code> 是 downstream 的 accumulation 的中间结果类型</li>
<li><code>D</code> 是最终输出 Map 的 Value 的类型。比如 <code>List</code> 或者 <code>Set</code> </li>
</ul>
<p>这个方法会调用第三个重载函数，比第二个函数，多了中间的 <code>HashMap::new</code>； 这个是最终返回的 Map 的类型，这里写死的是 HashMap, 如果你想用其他类型，就需要使用最终的也是最复杂的第三个重载函数。</p>
<p>越是你用起来简单的函数，背后的实现就越来越复杂。</p>
<h3 id="3-第三个重载方法-能看懂就随便你怎么玩"><a href="#3-第三个重载方法-能看懂就随便你怎么玩" class="headerlink" title="3 第三个重载方法: 能看懂就随便你怎么玩"></a>3 第三个重载方法: 能看懂就随便你怎么玩</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; the type of the input elements</div><div class="line">* <span class="doctag">@param</span> &lt;K&gt; the type of the keys</div><div class="line">* <span class="doctag">@param</span> &lt;A&gt; the intermediate accumulation type of the downstream collector</div><div class="line">* <span class="doctag">@param</span> &lt;D&gt; the result type of the downstream reduction</div><div class="line">* <span class="doctag">@param</span> &lt;M&gt; the type of the resulting &#123;<span class="doctag">@code</span> Map&#125;</div><div class="line">* <span class="doctag">@param</span> classifier a classifier function mapping input elements to keys</div><div class="line">* <span class="doctag">@param</span> downstream a &#123;<span class="doctag">@code</span> Collector&#125; implementing the downstream reduction</div><div class="line">* <span class="doctag">@param</span> mapFactory a function which, when called, produces a new empty</div><div class="line">*                   &#123;<span class="doctag">@code</span> Map&#125; of the desired type</div><div class="line">*/</div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;</div><div class="line">    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</div><div class="line">                                  Supplier&lt;M&gt; mapFactory,</div><div class="line">                                  Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</div><div class="line">        Supplier&lt;A&gt; downstreamSupplier = downstream.supplier();</div><div class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> T&gt; downstreamAccumulator = downstream.accumulator();</div><div class="line">        BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123;</div><div class="line">            K key = Objects.requireNonNull(classifier.apply(t), <span class="string">"element cannot be mapped to a null key"</span>);</div><div class="line">            A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get());</div><div class="line">            downstreamAccumulator.accept(container, t);</div><div class="line">        &#125;;</div><div class="line">        BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner());</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher();</div><div class="line">            Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123;</div><div class="line">                intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v));</div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                M castResult = (M) intermediate;</div><div class="line">                <span class="keyword">return</span> castResult;</div><div class="line">            &#125;;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个函数有5个泛型，除去上面说的 <code>T</code>，<code>K</code>，<code>A</code>，<code>D</code><br>多了一个 mapFactory 的 Supplier() , 用于得到最终返回的 Map 的类型，第二个重载函数写死的 HashMap，这就可以进行自定义。</p>
<p>这个函数有连个值得注意的点：</p>
<ul>
<li>所有的Collectors 中函数，如果函数内部还要做集合处理的，都是使用 <code>downstream</code> 这种模式，利用 <code>downstream</code> 的各种已有的的 <code>Supplier</code> <code>Accumulator</code>等，修改来实现自己的功能。比如在 <code>groupingBy</code> 这个函数，一开始就获取了 <code>downstream</code> 的各个组件，组合成自己需要的收集器，进而用于完成分类的行为。（你还可以去看一看 <code>collectingAndThen()</code> 这个函数）</li>
</ul>
<p><img src="http://static.zybuluo.com/zhumin1990719/r9lzmhqejhu4poxfa65jrwg0/image_1be34fqkpdosrnqo8317uhcnc9.png" alt="image_1be34fqkpdosrnqo8317uhcnc9.png-228kB"></p>
<ul>
<li><code>groupingBy</code> 函数中有有两处强制类型转换。这里其实很难理解，为何可以直接成功的转换呢？</li>
</ul>
<p>第一处<br><img src="http://static.zybuluo.com/zhumin1990719/9aw6m36vtunxhzintfqzhw8x/image_1be351ek7187m19721kb3vijudj13.png" alt="image_1be351ek7187m19721kb3vijudj13.png-186.2kB"></p>
<p>第二处<br><img src="http://static.zybuluo.com/zhumin1990719/lqq4sk8y37vbchc9m7ajs0cn/image_1be353p451uuhvefd57r2u16ad1g.png" alt="image_1be353p451uuhvefd57r2u16ad1g.png-161.3kB"></p>
<p>两处其实都是将最终结果泛型 <code>D</code> 转成 中间结果 <code>A</code>。<br>对于第一处， mapFactory 是作为一个 <code>Supplier</code> 出现，而他的目的是提供中间结果类型，而他上面的 <code>accumulator</code> 的中间结果类型，就是<strong>K,A</strong>， 所以这样的强转是一定可以成功的</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/sqtr5d56vcc4y5qtm6yhv271/image_1be35m758itj1grmlc71nu81rrm1t.png" alt="image_1be35m758itj1grmlc71nu81rrm1t.png-139.5kB"></p>
<p>第二处也是一样的，因为全称都使用了 <code>A</code>，其实 <code>A</code> 和 <code>D</code> 在这里，是等价的。所以转换都可以成功。</p>
<p>你去可以从这么一个角度思考问题：</p>
<blockquote>
<p>你最终需要生成 <code>D</code> 类型，为何中间要给自己生成一个不一样的 <code>A</code> 类型添堵呢？ 你 4 不 4 sa？</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk8 集合的工厂类 &lt;code&gt;Collectors&lt;/code&gt; 提供了两个很好用的静态函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;groupingBy&lt;/li&gt;
&lt;li&gt;partitioningBy&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-31-工厂方法收集器Collectors的中的常用函数</title>
    <link href="http://yoursite.com/2017/04/13/jdk8-31-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86%E5%99%A8Collectors%E7%9A%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/04/13/jdk8-31-工厂方法收集器Collectors的中的常用函数/</id>
    <published>2017-04-13T13:28:28.000Z</published>
    <updated>2017-04-14T07:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-collectorImpl"><a href="#1-collectorImpl" class="headerlink" title="1   collectorImpl"></a>1   collectorImpl</h3><ul>
<li><code>Collectors</code> 中的 的基础 <code>collectorImpl</code> 两个构造方法一个有 <code>finisher()</code>, 一个没有。这个很容易理解，一个需要转换中间结果，一个中间结果和最终结果一致，所以不需要使用 <code>finisher()</code> 方法</li>
</ul>
<a id="more"></a>
<h3 id="2-两种实现方式"><a href="#2-两种实现方式" class="headerlink" title="2  两种实现方式"></a>2  两种实现方式</h3><p>对于工厂类 两种实现方式</p>
<ol>
<li><code>CollectorImpl</code> 来实现。</li>
<li><code>reduceing</code> 来实现， 而 <code>reducing</code> 方法归根还是用的是 <code>CollectorImpl</code> 方法来实现</li>
</ol>
<h3 id="3-常见函数"><a href="#3-常见函数" class="headerlink" title="3  常见函数"></a>3  常见函数</h3><h4 id="1）-toList-amp-toCollection"><a href="#1）-toList-amp-toCollection" class="headerlink" title="1）  toList() &amp; toCollection"></a>1）  <code>toList()</code> &amp; <code>toCollection</code></h4><ul>
<li><p>两个最常用的方法 <code>toList()</code> &amp; <code>toCollection</code><br><img src="http://ooapi4q4v.bkt.clouddn.com/14918251558881.jpg" alt=""></p>
</li>
<li><p><code>toSet()</code> 方法是也是 <code>toCollection</code> 的特化。</p>
</li>
</ul>
<h4 id="2）-joining"><a href="#2）-joining" class="headerlink" title="2）  joining()"></a>2）  <code>joining()</code></h4><ul>
<li><code>joining</code> 三种重载方法</li>
</ul>
<h4 id="3）-mapping"><a href="#3）-mapping" class="headerlink" title="3）  mapping()"></a>3）  <code>mapping()</code></h4><ul>
<li><code>mapping()</code> 将输入元素转换成输出元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity= people.stream().collect(groupingBy(</div><div class="line">Person::getCity,</div><div class="line">mapping(Person::getLastName, toSet()) <span class="comment">// Mapping , 将Person 转换成String , 提供给下游 Collector 使用</span></div><div class="line">));</div></pre></td></tr></table></figure>
<h4 id="4）-collectingAndThen"><a href="#4）-collectingAndThen" class="headerlink" title="4）  collectingAndThen()"></a>4）  <code>collectingAndThen()</code></h4><ul>
<li><p><code>collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher)</code>  先过完上层收集器 <code>downstream</code> ，在进行一次 <code>finisher()</code> 转换结果</p>
<p> 比如说，你在 <code>toList()</code> 之后，想将它转换成一个 <code>immutableList()</code> 就可以如下使用</p>
</li>
</ul>
<pre><code class="java">List&lt;String&gt; people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));
</code></pre>
<p>实现其实很有意思<br><img src="http://ooapi4q4v.bkt.clouddn.com/14918263223655.jpg" alt=""></p>
<h4 id="5）-counting-minBy-maxBy"><a href="#5）-counting-minBy-maxBy" class="headerlink" title="5）  counting() , minBy() , maxBy()"></a>5）  <code>counting()</code> , <code>minBy()</code> , <code>maxBy()</code></h4><ul>
<li><code>counting()</code> , <code>minBy()</code> , <code>maxBy()</code> 用 <code>reducing()</code> 实现, <code>reducing()</code> 又是基于 <code>CollectorImpl</code> 实现</li>
</ul>
<h4 id="6）-summingInt-averagingInt-averagingDouble"><a href="#6）-summingInt-averagingInt-averagingDouble" class="headerlink" title="6）  summingInt() , averagingInt() , averagingDouble()"></a>6）  <code>summingInt()</code> , <code>averagingInt()</code> , <code>averagingDouble()</code></h4><ul>
<li><code>summingInt()</code> 对每一个元素使用 <code>toIntFunction</code> 在累加，实现很有意思</li>
</ul>
<p><img src="http://ooapi4q4v.bkt.clouddn.com/14918267966242.jpg" alt=""></p>
<p><code>Supplier()</code> 采用生成了一个 长度为1 的 <code>int</code> 数组，而不是直接使用的整形数字？<br>因为数字是一个 <code>值</code>， 值是无法传递的，而数组是一个 <code>引用</code>， 引用是可以传递的。</p>
<ul>
<li><code>averagingInt()</code> 求平均值</li>
</ul>
<p><img src="http://ooapi4q4v.bkt.clouddn.com/14918270760778.jpg" alt=""></p>
<ul>
<li>对于<code>averagingDouble()</code> 的实现可以再去看一下，他的初始数组长度为4，他们视为浮点数计算的补偿产生的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-collectorImpl&quot;&gt;&lt;a href=&quot;#1-collectorImpl&quot; class=&quot;headerlink&quot; title=&quot;1   collectorImpl&quot;&gt;&lt;/a&gt;1   collectorImpl&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Collectors&lt;/code&gt; 中的 的基础 &lt;code&gt;collectorImpl&lt;/code&gt; 两个构造方法一个有 &lt;code&gt;finisher()&lt;/code&gt;, 一个没有。这个很容易理解，一个需要转换中间结果，一个中间结果和最终结果一致，所以不需要使用 &lt;code&gt;finisher()&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-28-30-自定义收集器&amp;坑</title>
    <link href="http://yoursite.com/2017/04/12/jdk8-28-30-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%B6%E9%9B%86%E5%99%A8-%E5%9D%91/"/>
    <id>http://yoursite.com/2017/04/12/jdk8-28-30-自定义收集器-坑/</id>
    <published>2017-04-12T00:32:03.000Z</published>
    <updated>2017-05-02T01:57:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>收集器中有很5个抽象方法，每个抽象方法都有自己特殊的作用，如果说我们要自己实现要给收集器的话，我们就需要分别实现下面五个方法。</p>
<a id="more"></a>
<h3 id="1-简单自定义一个收集器"><a href="#1-简单自定义一个收集器" class="headerlink" title="1 简单自定义一个收集器"></a>1 简单自定义一个收集器</h3><p>这个收集器的目的是将一个 <code>list</code> 转换成一个 <code>set</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</div><div class="line">        System.out.println(<span class="string">"supplier invoked!!!"</span>);</div><div class="line">        <span class="keyword">return</span> HashSet::<span class="keyword">new</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</div><div class="line">	    System.out.println(<span class="string">"accumulator invoked!!!"</span>);</div><div class="line">        <span class="keyword">return</span> Set&lt;T&gt;::add;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 并行性流才会调用，将两个分段的集合</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</div><div class="line">        System.out.println(<span class="string">"combiner invoked!!!"</span>);</div><div class="line">        <span class="keyword">return</span> (t1, t2) -&gt; &#123;</div><div class="line">            t1.addAll(t2);</div><div class="line">            <span class="keyword">return</span> t1;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Set&lt;T&gt;&gt; finisher() &#123;</div><div class="line">        System.out.println(<span class="string">"finisher invoked!!!"</span>);</div><div class="line">        <span class="keyword">return</span> Function.identity();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 描述这个集合的特性</div><div class="line">     * IDENTITY_FINISH 表示结果容器和中间容器是一致的，这个时候 JDK 会在返回的时候自动帮助我们做类型转换。而不用再去调用 finisher</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"characteristics invoked!!!"</span>);</div><div class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH,UNORDERED));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; words = Arrays.asList(<span class="string">"hello"</span> , <span class="string">"world"</span>, <span class="string">"welcome"</span>, <span class="string">"hello"</span>);</div><div class="line"></div><div class="line">        Set&lt;String&gt; stringSet = words.stream().collect(<span class="keyword">new</span> MySetCollector&lt;&gt;());</div><div class="line">        System.out.println(stringSet);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现类里，我们分别实现了5个方法。 其中比较重要的两个方式 <code>finisher</code> 和 <code>characteristics</code>  方法</p>
<p>这俩方法是相互影响的。首先看 <code>characteristics</code>  方法，这个方法要求返回一个 <code>Characteristics</code> 枚举类型对的 <code>Set</code>。而  <code>Characteristics</code> 一共有三个枚举值。分别有不同的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 当我们采用并行流的时候，同时设置了  CONCURRENT 作为这个流的特性</div><div class="line">   * 那么，操作的是同一个集合，而不是多个</div><div class="line">   * 同样的道理，我们采用了并行流的方式，但是没有这个特性，我们就会生成多个</div><div class="line">   * 集合</div><div class="line">   */</div><div class="line">  CONCURRENT,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   *  代表集合是否是有序的</div><div class="line">   */</div><div class="line">  UNORDERED,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 表示 finisher function 可以被省略，因为中间结果和最后的返回的结果的类型是一致的。</div><div class="line">   * 所以当我们设置了这个属性之后，我们就必须了解到， 最后的返回的类型，可以由中间结果类型进行强制的返回。</div><div class="line">   */</div><div class="line">  IDENTITY_FINISH</div></pre></td></tr></table></figure>
<p>上面的例子中，我们为我们自己的 <code>collector</code> 设置了两个属性， <code>IDENTITY_FINISH</code> &amp; <code>UNORDERED</code> ; 意思就是这个收集器收集的元素是无序的。 而同时，返回的类型和中间结果类型是可以完全强制转换的（如果不可以，则会报错，下面会说到）；而 <code>finisher()</code>  函数是不会被执行的，即使你在函数内部直接抛出一个异常都没有问题，因为根本不会执行。<br>执行结果我们可以看一下：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/0cl0ol9dyihk63ocsh0qzjgi/14914603137015.jpg" alt="14914603137015.jpg-102.1kB"></p>
<p>这里需要注意两点：</p>
<ol>
<li>虽然 <code>combiner()</code> 函数被调用了，但是只是返回了一个 <code>BinaryOperator</code> 而已，而这个 <code>BinaryOperator</code> 并不会被调用。</li>
<li><code>finisher()</code> 函数并没有被调用，原因上面已经说过</li>
<li><code>characteristics()</code> 函数被调用了两次，分别代表不同的意思</li>
</ol>
<p>对于第3点，我们跟进 <code>collector()</code> 源代码里看一下, 便会有答案。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/nnftv5zwqcgildzp8ddyd1x3/14914608156971.jpg" alt="14914608156971.jpg-302.5kB"></p>
<p>图中书说法其实不准确，其实是 <code>evaluate</code> 方法中的 <code>ReduceOps.makeRef(collector)</code> 中，会逐个调用相关方法， 包括 <code>characteristics()</code> 方法。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/gj3bj52qxy1im34hvvznjt5s/14914612652241.jpg" alt="14914612652241.jpg-351.7kB"></p>
<p>所以 <code>characteristics()</code> 被调用了两次，第一次用于判断 <strong>是否是无序集合</strong> ；第二次用于判断 <strong>是否需要执行 finisher 用于中间结果和最终结果的类型转换</strong></p>
<h3 id="2-当中间结果与返回结果不一致"><a href="#2-当中间结果与返回结果不一致" class="headerlink" title="2 当中间结果与返回结果不一致"></a>2 当中间结果与返回结果不一致</h3><p>看下面这个改造的自定义收集器，中间结果是个 <code>set</code> 而返回的是个 <code>map</code>，也就是中间结果和最终最终结果是不一致的。这个时候，<code>finisher</code> 函数就会排上用场了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Map</span>&lt;<span class="title">T</span>,<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</div><div class="line">        System.out.println(<span class="string">"supplier invoked!!!!!"</span>);</div><div class="line">        <span class="keyword">return</span> HashSet::<span class="keyword">new</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</div><div class="line">        System.out.println(<span class="string">"accumulator invoked!!!!!"</span>);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">return</span> (set, item) -&gt; &#123;</div><div class="line">            System.out.println(set);</div><div class="line">            System.out.println(<span class="string">"threadName: "</span> + Thread.currentThread().getName());</div><div class="line">            set.add(item);</div><div class="line">        &#125;;</div><div class="line"><span class="comment">//        return Set&lt;T&gt;::add;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</div><div class="line">        System.out.println(<span class="string">"combiner invoked!!!!!"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</div><div class="line">            set1.addAll(set2);</div><div class="line">            <span class="keyword">return</span> set1;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"finisher invoked!!!!"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> set -&gt; &#123;</div><div class="line">            Map&lt;T, T&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            set.stream().forEach(item -&gt; map.put(item, item));</div><div class="line">            <span class="keyword">return</span> map;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当有 Characteristics.CONCURRENT 意味着如果有并发，则是多个线程操作一个集合。</div><div class="line">     * 这个时候 accumulator 如果有 遍历操作，就有可能会抛出  ConcurrentModificationException</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"characteristics invoked!!!!"</span>);</div><div class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</div><div class="line">            List&lt;String&gt; words = Arrays.asList(<span class="string">"hello"</span>, <span class="string">"word"</span>, <span class="string">"helloword"</span>, <span class="string">"hello"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>);</div><div class="line">            Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">            set.addAll(words);</div><div class="line"></div><div class="line">            Map&lt;String, String&gt; map = set.parallelStream().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</div><div class="line">            System.out.println(map);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里由于我输出与中间结果类型并不一致，所以如果我在 <code>characteristics()</code> 方法中，依旧使用  <code>IDENTITY_FINISH</code> ，也就是进行类型强转，则必然报错，类型转换异常。大家可以自己试一下。</p>
<h3 id="3-并发与并行的区别-并行时候的一些坑"><a href="#3-并发与并行的区别-并行时候的一些坑" class="headerlink" title="3 并发与并行的区别-并行时候的一些坑"></a>3 并发与并行的区别-并行时候的一些坑</h3><p>这里，有另外一个很要命的坑。</p>
<blockquote>
<p>在说这个概念之前，先说一下收集器中 <code>parallel</code> 和 <code>concurrent</code> 的区别</p>
<ul>
<li><code>parallel</code> 是<strong>并行</strong>，会将产生多个集合，多个线程操作，最后合并，也就是会调用 <code>combiner()</code> 方法</li>
</ul>
<ul>
<li><code>concurrent</code> 是<strong>并发</strong>， 是多个线程对同一个集合进行操作，首先 <code>combiner()</code> 函数不会被执行，而同时，如果你在 <code>accumulator()</code> 函数中进行累加操作，又进行遍历操作，就会抛出并发异常。</li>
</ul>
</blockquote>
<p>用例子说话，首先我们必须采用 <code>并行流</code> ， 在 <code>accumulator()</code> 函数中遍历 <code>set</code>, 同时将 <code>characteristics()</code> 函数中加入 <code>CONCURRENT</code> 这个属性，你执行100次，基本都会抛出异常</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/2bpiqnuxu4atmod39o4v090m/14914633115993.jpg" alt="14914633115993.jpg-397.3kB"></p>
<p>原因很简答也比较复杂： 程序采用了并行流 <code>set.parallelStream()</code>，同时设置了 <code>CONCURRENT</code> 属性；也就是说，多个线程操作同一个集合。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/0cy0jahcni4gnhbb00qjiivv/14914634695900.jpg" alt="14914634695900.jpg-105.6kB"></p>
<p>而在 <code>accumulator()</code> 函数中同时遍历了集合，也修改了集合。由于是多线程操作，很大的概率就会发生你一边遍历集合，一遍修改，就会报错。顺被大家可看看 <code>ConcurrentModificationException</code> 的 <em>javadoc</em>. </p>
<p><img src="http://static.zybuluo.com/zhumin1990719/bgpyjod0lm1fm796tszkxw0c/14914635854475.jpg" alt="14914635854475.jpg-77.1kB"></p>
<p>而如果，你不添加 <code>CONCURRENT</code> 这个属性，就不会报错。因为会生成多个中间集合。这一点，我们可以改造 <code>supplier()</code> 方法，在其中答应一条语句，通过打印了几条语句，就可以看出产生了几个集合。</p>
<blockquote>
<p>当然了，如果你在  <code>accumulator()</code> 中不去有那个遍历的操作，也是即使你添加了 <code>CONCURRENT</code> 属性，也是不会报错的。因为你没有并发的即遍历又修改一个集合</p>
</blockquote>
<p><img src="http://static.zybuluo.com/zhumin1990719/n73a6j6hol02our7kigqyo1x/14914638813587.jpg" alt="14914638813587.jpg-75.7kB"></p>
<p>而一般产生多少集合，由产生多少个线程决定，而产生多少线程一般由机器经过 <code>超线程</code> 技术之后有多少个处理器而确定的。当然也是可以修改的，但是一般没有必要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查看有多少处理器</span></div><div class="line">Runtime.getRuntime().availableProcessors();</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集器中有很5个抽象方法，每个抽象方法都有自己特殊的作用，如果说我们要自己实现要给收集器的话，我们就需要分别实现下面五个方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-2-流初步以及Function详解</title>
    <link href="http://yoursite.com/2017/02/14/jdk8-2-%E6%B5%81%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8AFunction%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/02/14/jdk8-2-流初步以及Function详解/</id>
    <published>2017-02-14T06:56:17.000Z</published>
    <updated>2017-04-14T07:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-流初步"><a href="#一-流初步" class="headerlink" title="一 流初步"></a>一 流初步</h3><p>java 8提供一种更加方便的操作集合方式，即流~ <code>Stream</code><br>Stream的概念其实类似于 <em>liunx</em> 操作系统的中的 <code>PipeLine</code> 的概念，可以将数据传输；</p>
<a id="more"></a>
<p>流 分为两种：</p>
<ol>
<li>中间流：数据通过后还返回一个流，不是数据的终点</li>
<li>节点流：数据流入后不再返回流，操作结束，没有返回</li>
</ol>
<p>使用java8 中的 <code>List</code> 来写一个例子，这个例子是将集合中的所有元素，全部变为大写，而后将元素逐一输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list1 = Arrays.asList(<span class="string">"min.zhu"</span>, <span class="string">"yi.yu"</span>, <span class="string">"nai.nai"</span>);</div><div class="line"><span class="comment">//        list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; System.out.println(item));</span></div><div class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        </div><div class="line">        <span class="comment">// 流的操作方式 类似 linux 的管道功能</span></div><div class="line">        <span class="comment">// 流 分为： 中间流 和 节点流</span></div><div class="line">        <span class="comment">// map 称之为 映射 与 mapper-reducer 阶段的map 功能是一致的，给定一个值，返回会一个由于之映射的值</span></div><div class="line">        list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; list2.add(item));</div><div class="line"></div><div class="line">        <span class="comment">// 函数引用的做法</span></div><div class="line">        <span class="comment">// String::toUpperCase 其实 和 item -&gt; item.toUpperCase()</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 一致，都是有输入有输出，而 toUpperCase 的输入，就是调用他的实例对象</div><div class="line">         * 因为一个类是无法调用他的实例方法的，一定是实例才可以调用实例方法</div><div class="line">         */</div><div class="line">        list1.stream().map(String::toUpperCase).forEach(System.out::println);</div><div class="line">        list1.stream().map(String::toUpperCase).forEach(list2::add);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>java8 的调用流的方式，是使用集合的 <code>stream()</code> 方法， 这个方法会返回一个流，之后就可以调用 <code>map()</code> 方法对 <code>list</code> 中的元素做一定的处理。 <code>map()</code> 函数，还是返回了一个流，这个流也有 <code>forEach</code> 方法，这个时候我们还可以调用 <code>forEach</code> 方法对流中的数据进行逐一的处理。</p>
<p>需要注意的是，<code>forEach</code> 函数中, 需要传递的函数的参数是一个 <code>Consumer</code> 的函数式接口，这个接口的抽象方法 <code>accpt()</code> 是没有返回值的，所以，他不在可以返回一个可以继续操作的流。</p>
<p>而我们在看看 <code>map</code> 方法中，需要传递的是一个我们没有见过的 <code>Function</code> 的函数式接口，这个函数式接口，有两个参数，一个是输入参数，一个是返回值。他的唯一的抽象方法中，是接受一个参数，返回一个值。具体见下图，唯一的方法是 <code>apply</code> 方法，它是有返回值的，这一点和现实中的函数很像</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/a0gnbt50hdkjtfdk2ug54yws/image_1b5ng26f4el33qb92s1itsgpl9.png" alt="image_1b5ng26f4el33qb92s1itsgpl9.png-43.2kB"></p>
<blockquote>
<p>我们之前说过，java8 中，新增了很多个函数式接口，分别用于不同的场景<br>如之前说的 <code>Consumer</code> 接口，他是没有返回值的一个场景，专用于处理数据<br>以及今天说的有返回值的 <code>Function</code> 接口</p>
</blockquote>
<p>那么这个 <code>Function</code> 的函数式接口，就是我们今天的重点。</p>
<h3 id="二-Functon-接口-以及-BiFunction简介"><a href="#二-Functon-接口-以及-BiFunction简介" class="headerlink" title="二 Functon 接口 以及 BiFunction简介"></a>二 Functon 接口 以及 BiFunction简介</h3><p>我们可以用一个例子来完整的说明问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 函数式接口 Function 的经典案例</div><div class="line"> * jdk 8 新增很多 函数式接口</div><div class="line"> * 之前看的 forEach 方法中的 Consumer 接口 ，他的作用就是 对给定的参数进行一系列操作，不返回值</div><div class="line"> * 而现在的 以及 Test3 中流的 map 方法中 Function 接口 ，他唯一的操作 是apply , 他有返回值，一个value 一个 Return ，与现实当中数学的函数很类似</div><div class="line"> *</div><div class="line"> * jdk 8 中，接口中 除了可以有 default 方法以外， 还可以有一个 static 方法， static 方法可以有默认的实现</div><div class="line"> * 可以参考 Function 这个函数式接口</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        FunctionTest functionTest = <span class="keyword">new</span> FunctionTest();</div><div class="line"></div><div class="line">        <span class="comment">// 函数式接口，以及 lambda 表达式，让我们可以在函数操作的时候，传递函数，即传递行为</span></div><div class="line">        <span class="comment">// 而之前的编程方法，行为必须已经确定，而后进行调用</span></div><div class="line">        <span class="comment">// 故而 之前的编程方法称之为命令式编程，而后面的方法称之为 函数式编程</span></div><div class="line">        <span class="comment">// 而 可以传递，或者 返回函数的函数，称之为高阶函数（ js 中随处可见高阶函数</span></div><div class="line">        System.out.println(functionTest.compute(<span class="number">1</span>, item -&gt; <span class="number">2</span> * item));</div><div class="line"></div><div class="line">        <span class="comment">// 这种返回方式是 statement 方法</span></div><div class="line">        <span class="comment">// 上面那种方式是 expression 方式</span></div><div class="line">        <span class="comment">// 一个是一个标准的语句，而一个是一个表达式</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 表达式是不需要分好结尾的</div><div class="line">         * 而使用 标准语句，则必须要 ； 而且要 &#123;&#125;</div><div class="line">         */</div><div class="line">        System.out.println(functionTest.compute(<span class="number">1</span>, item -&gt; &#123;<span class="keyword">return</span>  <span class="number">2</span> * item;&#125;));</div><div class="line">        System.out.println(functionTest.compute(<span class="number">2</span>, item -&gt; item * item));</div><div class="line">        System.out.println(functionTest.convert(<span class="string">"hello"</span>, item -&gt; item + <span class="string">" world !!"</span>));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> value, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> function.apply(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String value , Function&lt;String, String&gt; function)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> function.apply(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要去看代码的注释，上面写完了所有重点的内容，我们再去看看 <code>Function</code> 这个函数式接口的实现，我们知道，<code>java8</code> 允许接口有 <code>default</code> 方法，而 <code>Function</code> 接口中有两个默认方法：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/o6nkgv0l1c4kjmaot2r0hd9u/image_1b5ngi5f21mha13p0uu4d06851m.png" alt="image_1b5ngi5f21mha13p0uu4d06851m.png-66.8kB"></p>
<p>利用这个两个方法，可以做函数的组合，用一个函数的输出，作为一个函数的输入。</p>
<ul>
<li><code>compose</code> 方法，是先执行 <code>before</code> 这个function, 在执行本身这个function；</li>
<li><code>andThen</code> 方法，则是先执行 <code>Function</code> 本体的 <code>apply</code> 方法，在执行传入的 <code>after</code> 的方法</li>
</ul>
<p>我们来写个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        FunctionTest2 functionTest2 = <span class="keyword">new</span> FunctionTest2();</div><div class="line"></div><div class="line">        <span class="comment">// 12</span></div><div class="line">        System.out.println(functionTest2.compute(<span class="number">2</span>, item -&gt; item * <span class="number">3</span>, item -&gt; item * item));</div><div class="line">        <span class="comment">// 36</span></div><div class="line">        System.out.println(functionTest2.compute2(<span class="number">2</span>, item -&gt; item * <span class="number">3</span>, item -&gt; item * item));</div><div class="line">        <span class="comment">// 25</span></div><div class="line">        System.out.println(functionTest2.compute3(<span class="number">2</span>, <span class="number">3</span>, (a,b)-&gt; a+b , result -&gt; result * result));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span> <span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * compose 就是 先执行 function2.apply</div><div class="line">         * 再将 function2.apply 的返回值，作为 function1 的输入</div><div class="line">         * 此时再执行 function1 apply</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> function1.compose(function2).apply(a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute2</span> <span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * compose 就是 先执行 function1.apply</div><div class="line">         * 再将 function1.apply 的返回值，作为 function2 的输入</div><div class="line">         * 此时再执行 function2 apply</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> function1.andThen(function2).apply(a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 如果想做有两个参数的Function 就需要使用BiFunction</div><div class="line">     * 而 BiFunction 只有一个 andThen , andThen 的输入 是 Function，</div><div class="line">     * 因为是将 Apply 的结果返回，结果只有一个，所以 参数只能是 Function , 而不是 BiFunction</div><div class="line">     * 所以 BiFunction 方法不可能有 compose 方法</div><div class="line">     *</div><div class="line">     * 对应的  consumer 也有着 BiConsumer 同时，二者因为没有返回值，所以也只可能有 andThen 方法</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute3</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> biFunction.andThen(function).apply(a,b);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>compose</code> 和 <code>andThen</code> 的功能可以从例子中很好的看出来，例子中还有一个新的接口叫 <code>BiFunction</code>, 这个函数式接口是给定两个输入，返回一个输出，解决了有两个参数的函数的问题，对应的，其实 <code>Comsumer</code> 接口也还有一个对应的 <code>BiConsumer</code> 接口。</p>
<p>而当我们去观察这俩 <code>Bi</code> 的接口，都只有一个 <code>andThen</code> 的接口，为啥没有 <code>compose</code> 方法呢？<br>给读者自己思考吧~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-流初步&quot;&gt;&lt;a href=&quot;#一-流初步&quot; class=&quot;headerlink&quot; title=&quot;一 流初步&quot;&gt;&lt;/a&gt;一 流初步&lt;/h3&gt;&lt;p&gt;java 8提供一种更加方便的操作集合方式，即流~ &lt;code&gt;Stream&lt;/code&gt;&lt;br&gt;Stream的概念其实类似于 &lt;em&gt;liunx&lt;/em&gt; 操作系统的中的 &lt;code&gt;PipeLine&lt;/code&gt; 的概念，可以将数据传输；&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-1.1-方法引用：lambda表达式的语法糖</title>
    <link href="http://yoursite.com/2017/02/12/jdk8-1-1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://yoursite.com/2017/02/12/jdk8-1-1-方法引用：lambda表达式的语法糖/</id>
    <published>2017-02-12T07:31:46.000Z</published>
    <updated>2017-04-14T07:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>方法应用其实是 jdk 8 中的对于  <em>lambda</em> 表达式给予的一种 <strong>语法糖</strong></p>
</blockquote>
<p>而方法引用一共分为 4 种；</p>
<ul>
<li>1 <code>类名::静态方法名</code></li>
<li>2 <code>对象名::方法名</code></li>
<li>3 <code>类名::实例方法名</code></li>
<li>4 <code>构造方法引用::new</code></li>
</ul>
<a id="more"></a>
<p>我们有intellj 编写 lambda 表达式的时候，编译器总是标黄来告诉你，这里可以使用方法引用的方法来进行代码的简化</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/6sl7hr28156h9kmv9jsmstb6/image_1b7k0qtepmls15v3rjv19691om39.png" alt="image_1b7k0qtepmls15v3rjv19691om39.png-86kB"></p>
<p>而方法引用，<strong><em>method reference</em></strong> 其实就是lambda表达式一种语法糖<br>但是 </p>
<blockquote>
<p><strong>不是所有的 lambda 表达式，都可以用方法引用的方式来编写</strong><br>复杂的 lambda 表达式还是需要老老实实写相关代码</p>
</blockquote>
<p>我们通过一个例子来分别讲解这四种方法引用的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 第一种</span></div><div class="line"></div><div class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">"zhumin1"</span>,<span class="number">10</span>);</div><div class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">"zhumin2"</span>,<span class="number">20</span>);</div><div class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">"zhumin3"</span>,<span class="number">40</span>);</div><div class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">"zhumin4"</span>,<span class="number">80</span>);</div><div class="line"></div><div class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</div><div class="line"></div><div class="line">        <span class="comment">// jdk 1.8 的新方法  List 中新增加了 sort 方法</span></div><div class="line">        <span class="comment">// 传统的 lambda 表达式</span></div><div class="line">        students.sort((studentP1, studentP2) -&gt; Student.compareByScore(studentP1, studentP2));</div><div class="line">        <span class="comment">// 第一种方法引用的方式 类名::静态方法名</span></div><div class="line">        <span class="comment">// 不需要传参数，因为可以自动推断出 Student 类型</span></div><div class="line">        students.sort(Student::compareByScore);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 第二种 对象名称::方法名称</span></div><div class="line">        <span class="comment">// 其实和第一种很类似</span></div><div class="line">        StudentComparator studentComparator = <span class="keyword">new</span> StudentComparator();</div><div class="line"></div><div class="line">        students.sort((studentP1, studentP2) -&gt; studentComparator.comparator(studentP1, studentP2));</div><div class="line">        <span class="comment">// 对象名称::方法名称 (方法引用的第二种方式)</span></div><div class="line">        students.sort(studentComparator::comparator);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 第三种方法 类名::实例方法</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 比较难理解的的地方是，你会看到调用的函数，和 lambda 表达式需要的参数个数不一致， 会少一个</div><div class="line">         * 而且类名是没法调用方法名的</div><div class="line">         * 而理解方式是：调用方法的实例，就是传入lambda 表达式的第一个参数，而剩下所有参数，都作为 调用的实例方法 的参数</div><div class="line">         * 我们看下面的例子 ， Student 类调用的是其的实例方法 compare（Student） 只有一个参数</div><div class="line">         * 而 List 的默认方法需要的 Comparator 的函数式接口需要两个参数，看似对应不上，而且，类名也无法调用实例方法</div><div class="line">         * 实际是，传入的第一参数就是 comare（student）这个函数的调用者，而第二个参数以及后续所有的参数（如果有跟多也是一样），是作为实例方法的参数传入</div><div class="line">         * 所以少一个参数也没什么</div><div class="line">         * 而更为关键的是这个就是一个语法糖，为了简化代码而生。理解就好</div><div class="line">         * 如此一来； 这个第三种方式就很好理解了</div><div class="line">         *</div><div class="line">         * 类名::实例方法</div><div class="line">         * 即 lambda 表达式的第一参数就是 实例方法 的调用者，后续所有的参数就是 实例方法的传入参数</div><div class="line">         */</div><div class="line">        students.sort(Student::compare);</div><div class="line"></div><div class="line">        <span class="comment">// 再看一个例子</span></div><div class="line">        List&lt;String&gt; cities = Arrays.asList(<span class="string">"haha"</span>,<span class="string">"lala"</span>,<span class="string">"nihao"</span>,<span class="string">"memeda"</span>);</div><div class="line">        <span class="comment">// 对比二者</span></div><div class="line">        Collections.sort(cities, (city1, city2) -&gt; city1.compareToIgnoreCase(city2));</div><div class="line">        Collections.sort(cities, String::compareToIgnoreCase);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 对于第四种，构造方法引用，对于带参数和不带参数的都可以，编译器会自动的进行腿短</span></div><div class="line">        MethodRefrenceTest methodRefrenceTest = <span class="keyword">new</span> MethodRefrenceTest();</div><div class="line">        <span class="comment">// 点击 new 看看会跳到那个方法里去</span></div><div class="line">        methodRefrenceTest.getName(String::<span class="keyword">new</span>);</div><div class="line">        <span class="comment">// 点击 new 看看会跳到那个方法里去</span></div><div class="line">        methodRefrenceTest.getName2(<span class="string">"haa"</span>, String::<span class="keyword">new</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(Supplier&lt;String&gt; supplier)</span>  </span>&#123;</div><div class="line">        <span class="keyword">return</span> supplier.get() + <span class="string">"haha"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName2</span><span class="params">(String name, Function&lt;String ,String&gt; stringFunction)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringFunction.apply(name);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;方法应用其实是 jdk 8 中的对于  &lt;em&gt;lambda&lt;/em&gt; 表达式给予的一种 &lt;strong&gt;语法糖&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而方法引用一共分为 4 种；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &lt;code&gt;类名::静态方法名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2 &lt;code&gt;对象名::方法名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3 &lt;code&gt;类名::实例方法名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4 &lt;code&gt;构造方法引用::new&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-1-函数式接口&amp;lambda表达式</title>
    <link href="http://yoursite.com/2017/02/11/jdk8-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/02/11/jdk8-1-函数式接口-lambda表达式/</id>
    <published>2017-02-11T07:00:25.000Z</published>
    <updated>2017-04-14T07:13:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-lmabda表达式"><a href="#1-lmabda表达式" class="headerlink" title="1 lmabda表达式"></a>1 lmabda表达式</h3><p>首先看两段对比代码:<br>为jbutton 添加一个时间监听器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 老写法: 匿名内部类</span></div><div class="line">jButton.addActionListener(<span class="keyword">new</span> AbstractAction() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello Button"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">        </div><div class="line"><span class="comment">// lambda 表达式写法</span></div><div class="line">jButton.addActionListener(e -&gt; System.out.println(<span class="string">"Hello Button"</span>));</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>对比两个写法，lambda表达式的写法会简单很多，如果你有多行处理逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加个大括号</span></div><div class="line">jButton.addActionListener(e -&gt;&#123;</div><div class="line">    System.out.println(<span class="string">"Hello Button!!!!"</span>);</div><div class="line">    System.out.println(<span class="string">"Hello Button2!!!!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这里的e，没有声明类型，并不是表示java 不是一个静态语言了，而是，编译器的类型推断告诉可以推断出来这个 <code>e</code> 的类型肯定是一个 <code>AbstractAction</code>, 所以无需去写，当然如写上也没有问题，需要加上括号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jButton.addActionListener((AbstractAction e) -&gt;&#123;</div><div class="line">    System.out.println(<span class="string">"Hello Button!!!!"</span>);</div><div class="line">    System.out.println(<span class="string">"Hello Button2!!!!"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>所以 <strong>lambda</strong> 表达式的基本结构如下（根据单个参数和单个操作可以有一定的省略）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(event e1, event e2 ...) -&gt; &#123;</div><div class="line">    action1;</div><div class="line">    action2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一开始可能不是特别好理解，我们可以结合 <strong>java8</strong> 新增的另一个特性 <strong>函数式接口</strong> 来一起理解为何我们可以如此编写代码</p>
<h3 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2 函数式接口"></a>2 函数式接口</h3><p>什么叫函数式接口呢？ 函数式接口是 <code>jdk1.8</code> 中新增的一个接口类型，为此还新增了一个注解 <code>@FunctionalInterface</code> 用于标注函数接口；我们通过阅读 <code>@FunctionalInterface</code> 的 <em>jdk</em> 文档来进行概念认知。总结起来：</p>
<ul>
<li>当一个接口 有且只有一个抽象方法，并且这个抽象方法不是继承自 <code>Object</code> 的方法，就会被当做一个 <strong>函数式接口</strong></li>
<li>当一个接口被  <code>@FunctionalInterface</code> 注解时，可以当做一个函数式接口</li>
<li>当一个接口被  <code>@FunctionalInterface</code> 注解，但不满足第一个条件的时候，编译器会报错。</li>
<li>当一个接口 没有被 <code>@FunctionalInterface</code> 注解标注，但是满足函数式接口的条件，也会被当做函数式接口</li>
</ul>
<blockquote>
<p>这里的第一条后半部分很重要，如果一个接口，有两个抽象方法，但是其中一个是继承自 <code>Object</code> 类（因为其实万类师祖）, 他仍然是一个函数式接口。</p>
</blockquote>
<p>例如以下实例就是一个完整的函数式接口，即使他有2个抽象方法，但是toString是继承自 <code>Object</code> 的方法，所以不会算作函数式接口的抽象方法，所以其中的 <code>test()</code> 方法, 是函数式接口认定的唯一的抽象方法。<br>同理，如果下面的例子只有 <code>toString()</code> 方法，而没有 <code>test()</code> 方法，同时又有  <code>@FunctionalInterface</code> 注解的话，那么编译器会报错。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 函数式接口，只能有唯一的抽象方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 因为改抽象方法，继承自 Object，所以不算函数式接口的抽象方法</div><div class="line">     * 故而，接口可以算作一个函数式接口</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看一下  <code>@FunctionalInterface</code> 的jdk文档，里面有一句: </p>
<center><img src="http://static.zybuluo.com/zhumin1990719/xgz9c76x5q7q1fa3fyvrzilz/image_1b4cpml3c13mn1cju14uurjun9v9.png" alt="image_1b4cpml3c13mn1cju14uurjun9v9.png-24.9kB"></center>

<p>意思就是说，函数式接口的实现，可以通过 <code>lambda</code> 表达式 <strong>方法引用</strong> 以及 <strong>构造方法引用</strong> 的方式来实现。其实我们上面的 <code>lambda</code> 表达式的例子，就是实现的函数式接口。我们来新写一个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterface</span><span class="params">(MyInterface myInterface)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"start ------------------"</span>);</div><div class="line">        myInterface.test();</div><div class="line">        System.out.println(<span class="string">"end --------------------"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Test2 test2 = <span class="keyword">new</span> Test2();</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 因为函数式接口的里唯一的抽象方法test里面，没有参数</div><div class="line">         * 但是（）不能省略</div><div class="line">         * 参考Test1 程序里面的Jframe 里的ActionListener</div><div class="line">         */</div><div class="line">        test2.testInterface(() -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"函数式接口接口实现"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，<code>testInterface</code> 方法需要传递一个 <code>testInterface</code><br>的接口，而我们使用的方式就是 <code>lambda</code> 表达式来实现了一个函数式接口。 可以运用下面的形式来理解。</p>
<blockquote>
<p>(函数式接口唯一的抽象方法的参数列表) -&gt; {唯一抽象函数的实现}</p>
</blockquote>
<p>这个时候，我们看一下最开始的那个给 <strong>button</strong> 加 action 的例子。<br>其实实现就是 <code>ActionListener</code> 这个函数式接口的唯一的抽象方法：<br><img src="http://static.zybuluo.com/zhumin1990719/uy91dk519fbykpnmbovocu5h/image_1b4cq5u2j1548e4eif0l1t1t48m.png" alt="image_1b4cq5u2j1548e4eif0l1t1t48m.png-35.9kB"><br>虽然该类没有 <code>@FunctionalInterface</code> 注解，但是满足条件，只有一个抽象方法，所以他也是一个函数式接口，所以我们可以去使用 <code>lambda</code> 表达式去实现他。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-lmabda表达式&quot;&gt;&lt;a href=&quot;#1-lmabda表达式&quot; class=&quot;headerlink&quot; title=&quot;1 lmabda表达式&quot;&gt;&lt;/a&gt;1 lmabda表达式&lt;/h3&gt;&lt;p&gt;首先看两段对比代码:&lt;br&gt;为jbutton 添加一个时间监听器&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 老写法: 匿名内部类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;jButton.addActionListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AbstractAction() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;actionPerformed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ActionEvent e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello Button&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// lambda 表达式写法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;jButton.addActionListener(e -&amp;gt; System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello Button&quot;&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>new start</title>
    <link href="http://yoursite.com/2017/01/11/new-start/"/>
    <id>http://yoursite.com/2017/01/11/new-start/</id>
    <published>2017-01-11T13:42:13.000Z</published>
    <updated>2017-04-14T06:58:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>重新开始维护这个网站。让自己配得上这个不错的域名 <code>movingon.cn!</code></p>
<a id="more"></a>
<p>我14年买了这个域名，本来想自己要好好做，实在不行，这域名也是一个不错的督促。</p>
<p>然而，自己维护了一段时间之后，就忘记了要去维护。</p>
<p>但是这一次，我用这里记录自己的技术成长以及个人感悟，作为自己的成长的记录。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新开始维护这个网站。让自己配得上这个不错的域名 &lt;code&gt;movingon.cn!&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="鸡汤" scheme="http://yoursite.com/tags/%E9%B8%A1%E6%B1%A4/"/>
    
  </entry>
  
</feed>
