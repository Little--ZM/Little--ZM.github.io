<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>待葡萄嗖透</title>
  <subtitle>你说啥？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-02T01:55:40.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>朱老师&amp;敏哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jdk1.7新增自动关闭接口AutoCloseable</title>
    <link href="http://yoursite.com/2017/05/02/jdk1-7%E6%96%B0%E5%A2%9E%E8%87%AA%E5%8A%A8%E5%85%B3%E9%97%AD%E6%8E%A5%E5%8F%A3AutoCloseable/"/>
    <id>http://yoursite.com/2017/05/02/jdk1-7新增自动关闭接口AutoCloseable/</id>
    <published>2017-05-02T01:13:09.000Z</published>
    <updated>2017-05-02T01:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-AutoCloseable-接口"><a href="#1-AutoCloseable-接口" class="headerlink" title="1 AutoCloseable 接口"></a>1 AutoCloseable 接口</h3><p>这是JDK1.7 的新增语法。帮助你自动关闭一些资源。可能你还不知道这个接口<br><img src="http://static.zybuluo.com/zhumin1990719/rydvwpav6zkm6jhel6244jxl/image_1bf3bdg6r6da1bha17s9cm81bej13.png" alt="image_1bf3bdg6r6da1bha17s9cm81bej13.png-90.6kB"></p>
<a id="more"></a>
<p>这个接口好就好在，只有一个方法，名叫 <code>close()</code>, 而这正好有是我们各个资源关闭的方法名，所以使用起来相当方便，因为名称一样，代码兼容。</p>
<p>JDK8 中就在很多地方应用了这个接口，比如 <code>Stream</code> 继承了 <code>BaseStream</code>，而 <code>BaseStream</code> 则继承了 <code>AutoCloseable</code> 这个接口。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/tmv8f7uvw289fjrfibxcr77y/image_1bf3avqeh1sjr8061aa9kr1bpc9.png" alt="image_1bf3avqeh1sjr8061aa9kr1bpc9.png-45.6kB"></p>
<p>这个接口的说明很清楚，当你在使用 <code>try-with-resources block</code> 这种语法调用来进行资源获取的时候，在 <code>block</code> 退出之后自动关闭</p>
<p>你不用像之前写 <code>finally{}</code> 代码那样的进行关闭。就不会有资源未被释放的问题。</p>
<h3 id="2-测试代码"><a href="#2-测试代码" class="headerlink" title="2 测试代码"></a>2 测试代码</h3><p>简单测试代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Created by charleszhu on 2017/5/2.</div><div class="line"> */</div><div class="line">public class AutoCloseAbleTest implements AutoCloseable&#123;</div><div class="line"></div><div class="line">    public void doSth() &#123;</div><div class="line">        System.out.println(&quot;doStm&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void close() throws Exception &#123;</div><div class="line">        System.out.println(&quot;Close() 看到没，我被吊了&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) throws Exception &#123;</div><div class="line">        /**</div><div class="line">         * try-with-resources 语法块</div><div class="line">         */</div><div class="line">        try(AutoCloseAbleTest autoCloseAbleTest = new AutoCloseAbleTest()) &#123;</div><div class="line">            autoCloseAbleTest.doSth();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行一下，结果如下：<br><img src="http://static.zybuluo.com/zhumin1990719/c709aferpg4yr5myxks8txnu/image_1bf3bcj84433l37sm41vrf10dhm.png" alt="image_1bf3bcj84433l37sm41vrf10dhm.png-120.6kB"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-AutoCloseable-接口&quot;&gt;&lt;a href=&quot;#1-AutoCloseable-接口&quot; class=&quot;headerlink&quot; title=&quot;1 AutoCloseable 接口&quot;&gt;&lt;/a&gt;1 AutoCloseable 接口&lt;/h3&gt;&lt;p&gt;这是JDK1.7 的新增语法。帮助你自动关闭一些资源。可能你还不知道这个接口&lt;br&gt;&lt;img src=&quot;http://static.zybuluo.com/zhumin1990719/rydvwpav6zkm6jhel6244jxl/image_1bf3bdg6r6da1bha17s9cm81bej13.png&quot; alt=&quot;image_1bf3bdg6r6da1bha17s9cm81bej13.png-90.6kB&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
  </entry>
  
  <entry>
    <title>老版本MacBookPro (厚的) 格式化, U盘安装 MacOS Sierra</title>
    <link href="http://yoursite.com/2017/05/01/%E8%80%81%E7%89%88%E6%9C%ACMacBookPro-%E5%8E%9A%E7%9A%84-%E6%A0%BC%E5%BC%8F%E5%8C%96-U%E7%9B%98%E5%AE%89%E8%A3%85-MacOS-Sierra/"/>
    <id>http://yoursite.com/2017/05/01/老版本MacBookPro-厚的-格式化-U盘安装-MacOS-Sierra/</id>
    <published>2017-05-01T15:12:25.000Z</published>
    <updated>2017-05-02T00:51:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>主要写的点是：U 盘安装盘的制作，以及，为什么会有 </p>
<ul>
<li>can’t be verified</li>
<li>已损坏，重新下载</li>
</ul>
<p>这些问题，即使你是从 app store 中下载的完整版本。</p>
<a id="more"></a>
<p>前两天，我一个朋友拿了一台很老的 <code>MacBook pro</code> , 说他不小心格式化了硬盘，要我重装系统。。</p>
<p>电脑图如下。。<br><img src="http://static.zybuluo.com/zhumin1990719/ky6nya8775sxhivrqgdiqq7c/image_1bf10mmqp1ifr1lgpklstgs1h9o9.png" alt="image_1bf10mmqp1ifr1lgpklstgs1h9o9.png-308.8kB"></p>
<p>有点洁癖的我看到了想说说，要不你砸了吧（当然我没说。。）<br>但是碍于面子（毕竟我是程序员，外界都说是搞电脑的，约等于 修电脑的，近似于你是修电脑的，也就是说电脑相关的你全都会，不会就是大傻逼）。。</p>
<blockquote>
<p>我当然是很愤怒的，之所以没有发作是因为他是我老师。。</p>
</blockquote>
<h2 id="如何制作安装盘"><a href="#如何制作安装盘" class="headerlink" title="如何制作安装盘"></a>如何制作安装盘</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>你需要一下物品：</p>
<blockquote>
<ul>
<li>一个只要8G的U盘</li>
<li>一台工作良好的 macbook pro</li>
<li>良好的网络</li>
<li>我（你没戏了）</li>
</ul>
</blockquote>
<p>言归正传：</p>
<h3 id="步骤一-：-在App-Store-中下载最新的-macos"><a href="#步骤一-：-在App-Store-中下载最新的-macos" class="headerlink" title="步骤一 ： 在App Store 中下载最新的 macos"></a>步骤一 ： 在App Store 中下载最新的 macos</h3><p>连接如下 <a href="https://itunes.apple.com/cn/app/macos-sierra/id1127487414?mt=12" target="_blank" rel="external">下载地址</a><br>她会跳转到 app store. 点击下载即可。它会弹出提示让你更新啥的，不用管它，直接下载</p>
<p>下载好了之后，你在你的 <code>应用程序</code> 文件夹，你就可以看到这个了</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/y0agrs81opqu504ydcxb59nl/image_1bf1226d41kb315mb1ja21bi6fkbm.png" alt="image_1bf1226d41kb315mb1ja21bi6fkbm.png-253.8kB"></p>
<p>至此，你的第一任务完成。</p>
<h3 id="步骤二-：用磁盘工具格式化你的U盘"><a href="#步骤二-：用磁盘工具格式化你的U盘" class="headerlink" title="步骤二 ：用磁盘工具格式化你的U盘"></a>步骤二 ：用磁盘工具格式化你的U盘</h3><p>打开 “应用程序 → 实用工具 → 磁盘工具”，将U盘「抹掉」(格式化) 成「Mac OS X 扩展（日志式）」格式、GUID 分区图，并将U盘命名为<br>「Sierra」。(注意：这个盘符名称将会与后面的命令一一对应，如果你改了这盘符的名字，必须保证后面的命令里的名称也要一致。)</p>
<blockquote>
<p>如果不成功，你就多试几次</p>
</blockquote>
<h3 id="步骤三-：-制作安装盘"><a href="#步骤三-：-制作安装盘" class="headerlink" title="步骤三 ： 制作安装盘"></a>步骤三 ： 制作安装盘</h3><p>打开你的终端，输入如下命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /Applications/Install\ macOS\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/Sierra --applicationpath /Applications/Install\ macOS\ Sierra.app --nointeraction</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意空格前面需要有 <code>\</code> 进行转义</p>
</blockquote>
<p><img src="http://static.zybuluo.com/zhumin1990719/wx8yijvchu5smsimltbdgl9p/image_1bf28fv4l1uph1cvgv581u0uecs13.png" alt="image_1bf28fv4l1uph1cvgv581u0uecs13.png-51.3kB"></p>
<p>耐心得到 <code>done</code>,  你就可以拿着 U 盘去安装了</p>
<h2 id="无法验证？or-已经损坏？"><a href="#无法验证？or-已经损坏？" class="headerlink" title="无法验证？or 已经损坏？"></a>无法验证？or 已经损坏？</h2><p>重装的步骤简单，插入u盘，开机按住 <code>option</code>, 选择u 盘的安装盘。接下来选择安装就可以了。</p>
<p>但是，大部分情况下，都会遇到类似</p>
<blockquote>
<p> This copy of the Install OS X El Capitan application can’t be verified. It may have been corrupted or tampered with during downloading</p>
</blockquote>
<p><img src="http://static.zybuluo.com/zhumin1990719/v32y8u4lwltu78uco91rnee0/image_1bf28oaj5122pbej121d1nfgq831g.png" alt="image_1bf28oaj5122pbej121d1nfgq831g.png-57.5kB"></p>
<p>或者，直接告诉你损坏了，让你再去下载完整版本。</p>
<p>导致这个的原因是，当你决定将一台mac格式化后，在重装系统的时候，系统的时间已经被改变了。这个时候安装程序就会爆出各种错误。你可以通过 终端输入 date 进行查看，时间应该变成了 2001 年。</p>
<p>这个时候， 你只要通过 <code>date</code> 命令重置时间，就可以解决这个问题。<br>他的参数如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">date MMDDHHmmYY replacing the letters as follows.</div><div class="line">MM - 2 digit month  01 - 12</div><div class="line">DD - 2 digit date   01 - 31</div><div class="line">HH - 2 digit hour   01 - 24</div><div class="line">mm - 2 digit minute 01 - 59</div><div class="line">YY - 2 digit year   &gt; 15</div></pre></td></tr></table></figure>
<p>你将时间设置成，你要安装的系统发布之后的一个时间后，退出终端，再次点击操作，就不会有问题。</p>
<p>你也可以看做这个视频 <a href="https://www.youtube.com/watch?v=LRPiynS15_U" target="_blank" rel="external">土逼视频</a> ，需要翻墙。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;主要写的点是：U 盘安装盘的制作，以及，为什么会有 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;can’t be verified&lt;/li&gt;
&lt;li&gt;已损坏，重新下载&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些问题，即使你是从 app store 中下载的完整版本。&lt;/p&gt;
    
    </summary>
    
    
      <category term="mac" scheme="http://yoursite.com/tags/mac/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-32-groupingBy 源码分析</title>
    <link href="http://yoursite.com/2017/04/30/jdk8-32-groupingBy-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/04/30/jdk8-32-groupingBy-源码分析/</id>
    <published>2017-04-30T08:58:34.000Z</published>
    <updated>2017-04-30T09:02:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>jdk8 集合的工厂类 <code>Collectors</code> 提供了两个很好用的静态函数。</p>
<ul>
<li>groupingBy</li>
<li>partitioningBy</li>
</ul>
<a id="more"></a>
<p><code>groupingBy</code> 实现类似 Mysql 中分分组功能。返回一个 Map; 而 <code>partitioningBy</code>可以看做是 <code>groupingBy</code> 的特殊形式。我们后面会接着介绍。 使用的是比如统计每个城市人的“姓”，可以这么写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity,                                            mapping(Person::getLastName, toSet())));</div></pre></td></tr></table></figure>
<p>那么，他到底如何利用 <code>Collector</code> 的各个接口来实现的呢？下面我们将深入 JDK 的 <code>Collectors</code> 的源码中，分析一下他是如何工作的。 </p>
<h2 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h2><h3 id="1-第一个重载方法-要简单就别那么多要求，给你个List不错了"><a href="#1-第一个重载方法-要简单就别那么多要求，给你个List不错了" class="headerlink" title="1 第一个重载方法, 要简单就别那么多要求，给你个List不错了"></a>1 第一个重载方法, 要简单就别那么多要求，给你个List不错了</h3><p>分组 <code>groupingBy</code> 有三个重载方法。一个比一复杂。</p>
<p>先看最简单的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input elements</div><div class="line">     * <span class="doctag">@param</span> &lt;K&gt; the type of the keys</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</div><div class="line">    groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;</div><div class="line">        <span class="keyword">return</span> groupingBy(classifier, toList());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里 <code>T</code> 是输入集合的元素类型， <code>K</code> 是最后产生的 Map 的主键key 的类型。</p>
<p>函数需要传入一个 <code>Function</code> 的函数式接口，<code>Function</code> 的中作就是分类器，比如传入的类型是<code>T</code> 是一个 <code>Person</code>类型 ， 通过 <code>apply()</code> 方法，返回 <code>Person</code> 的属性 <code>name</code>；因为我们要按照 <code>name</code> 来分组。</p>
<p>所以，如果 <code>name</code> 的类型是 <code>String</code> ； 那么 <code>K</code> 就是 <code>String</code></p>
<p>故而，这个 <code>groupingBy(function)</code> 的功能就很清晰了，就是通过 <code>function</code> 对传入的 <code>T</code> 类型进行分类。然后调用 <code>toList()</code> 方法，也就是说每个分类的<code>Person</code> 会放进一个 <code>List&lt;Person&gt;</code> 中</p>
<p>最终返回的类型就是 <code>Map&lt;String, List&lt;Person&gt;&gt;</code>.</p>
<p>而如果你不想返回的是一个<code>List</code> , 希望是一个 <code>Set</code>. 你就要使用第二个重载方法~ 他允许你定义最后的输出函数。</p>
<h3 id="2-第二个重载方法：我要输出Set"><a href="#2-第二个重载方法：我要输出Set" class="headerlink" title="2 第二个重载方法：我要输出Set"></a>2 第二个重载方法：我要输出Set</h3><p>看一下函数的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input elements</div><div class="line">     * <span class="doctag">@param</span> &lt;K&gt; the type of the keys</div><div class="line">     * <span class="doctag">@param</span> &lt;A&gt; the intermediate accumulation type of the downstream collector</div><div class="line">     * <span class="doctag">@param</span> &lt;D&gt; the result type of the downstream reduction</div><div class="line">     * <span class="doctag">@param</span> classifier a classifier function mapping input elements to keys</div><div class="line">     * <span class="doctag">@param</span> downstream a &#123;<span class="doctag">@code</span> Collector&#125; implementing the downstream reduction</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt;</div><div class="line">    Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</div><div class="line">                                          Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</div><div class="line">        <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个函数，明显比上一个要复杂，可以看到，多了一个 <code>Collector</code> 的 <code>downstream</code> , 可以自定义输出的集合。上面那个简单版本的函数是是写死的 <code>List</code></p>
<p>这个函数有四个泛型。</p>
<ul>
<li><code>T</code> 原始元素类型，比如我们这是 <code>Person</code></li>
<li><code>K</code> 返回 Map 的 key, 即最终返回的Map 的建的类型。如果你想按照人的名字分类，那T就是 <code>String</code>, 如果按照年龄分类，那就是 <code>Interger</code></li>
<li><code>A</code> 是 downstream 的 accumulation 的中间结果类型</li>
<li><code>D</code> 是最终输出 Map 的 Value 的类型。比如 <code>List</code> 或者 <code>Set</code> </li>
</ul>
<p>这个方法会调用第三个重载函数，比第二个函数，多了中间的 <code>HashMap::new</code>； 这个是最终返回的 Map 的类型，这里写死的是 HashMap, 如果你想用其他类型，就需要使用最终的也是最复杂的第三个重载函数。</p>
<p>越是你用起来简单的函数，背后的实现就越来越复杂。</p>
<h3 id="3-第三个重载方法-能看懂就随便你怎么玩"><a href="#3-第三个重载方法-能看懂就随便你怎么玩" class="headerlink" title="3 第三个重载方法: 能看懂就随便你怎么玩"></a>3 第三个重载方法: 能看懂就随便你怎么玩</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; the type of the input elements</div><div class="line">* <span class="doctag">@param</span> &lt;K&gt; the type of the keys</div><div class="line">* <span class="doctag">@param</span> &lt;A&gt; the intermediate accumulation type of the downstream collector</div><div class="line">* <span class="doctag">@param</span> &lt;D&gt; the result type of the downstream reduction</div><div class="line">* <span class="doctag">@param</span> &lt;M&gt; the type of the resulting &#123;<span class="doctag">@code</span> Map&#125;</div><div class="line">* <span class="doctag">@param</span> classifier a classifier function mapping input elements to keys</div><div class="line">* <span class="doctag">@param</span> downstream a &#123;<span class="doctag">@code</span> Collector&#125; implementing the downstream reduction</div><div class="line">* <span class="doctag">@param</span> mapFactory a function which, when called, produces a new empty</div><div class="line">*                   &#123;<span class="doctag">@code</span> Map&#125; of the desired type</div><div class="line">*/</div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;</div><div class="line">    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</div><div class="line">                                  Supplier&lt;M&gt; mapFactory,</div><div class="line">                                  Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</div><div class="line">        Supplier&lt;A&gt; downstreamSupplier = downstream.supplier();</div><div class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> T&gt; downstreamAccumulator = downstream.accumulator();</div><div class="line">        BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123;</div><div class="line">            K key = Objects.requireNonNull(classifier.apply(t), <span class="string">"element cannot be mapped to a null key"</span>);</div><div class="line">            A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get());</div><div class="line">            downstreamAccumulator.accept(container, t);</div><div class="line">        &#125;;</div><div class="line">        BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner());</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher();</div><div class="line">            Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123;</div><div class="line">                intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v));</div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                M castResult = (M) intermediate;</div><div class="line">                <span class="keyword">return</span> castResult;</div><div class="line">            &#125;;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个函数有5个泛型，除去上面说的 <code>T</code>，<code>K</code>，<code>A</code>，<code>D</code><br>多了一个 mapFactory 的 Supplier() , 用于得到最终返回的 Map 的类型，第二个重载函数写死的 HashMap，这就可以进行自定义。</p>
<p>这个函数有连个值得注意的点：</p>
<ul>
<li>所有的Collectors 中函数，如果函数内部还要做集合处理的，都是使用 <code>downstream</code> 这种模式，利用 <code>downstream</code> 的各种已有的的 <code>Supplier</code> <code>Accumulator</code>等，修改来实现自己的功能。比如在 <code>groupingBy</code> 这个函数，一开始就获取了 <code>downstream</code> 的各个组件，组合成自己需要的收集器，进而用于完成分类的行为。（你还可以去看一看 <code>collectingAndThen()</code> 这个函数）</li>
</ul>
<p><img src="http://static.zybuluo.com/zhumin1990719/r9lzmhqejhu4poxfa65jrwg0/image_1be34fqkpdosrnqo8317uhcnc9.png" alt="image_1be34fqkpdosrnqo8317uhcnc9.png-228kB"></p>
<ul>
<li><code>groupingBy</code> 函数中有有两处强制类型转换。这里其实很难理解，为何可以直接成功的转换呢？</li>
</ul>
<p>第一处<br><img src="http://static.zybuluo.com/zhumin1990719/9aw6m36vtunxhzintfqzhw8x/image_1be351ek7187m19721kb3vijudj13.png" alt="image_1be351ek7187m19721kb3vijudj13.png-186.2kB"></p>
<p>第二处<br><img src="http://static.zybuluo.com/zhumin1990719/lqq4sk8y37vbchc9m7ajs0cn/image_1be353p451uuhvefd57r2u16ad1g.png" alt="image_1be353p451uuhvefd57r2u16ad1g.png-161.3kB"></p>
<p>两处其实都是将最终结果泛型 <code>D</code> 转成 中间结果 <code>A</code>。<br>对于第一处， mapFactory 是作为一个 <code>Supplier</code> 出现，而他的目的是提供中间结果类型，而他上面的 <code>accumulator</code> 的中间结果类型，就是<strong>K,A</strong>， 所以这样的强转是一定可以成功的</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/sqtr5d56vcc4y5qtm6yhv271/image_1be35m758itj1grmlc71nu81rrm1t.png" alt="image_1be35m758itj1grmlc71nu81rrm1t.png-139.5kB"></p>
<p>第二处也是一样的，因为全称都使用了 <code>A</code>，其实 <code>A</code> 和 <code>D</code> 在这里，是等价的。所以转换都可以成功。</p>
<p>你去可以从这么一个角度思考问题：</p>
<blockquote>
<p>你最终需要生成 <code>D</code> 类型，为何中间要给自己生成一个不一样的 <code>A</code> 类型添堵呢？ 你 4 不 4 sa？</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk8 集合的工厂类 &lt;code&gt;Collectors&lt;/code&gt; 提供了两个很好用的静态函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;groupingBy&lt;/li&gt;
&lt;li&gt;partitioningBy&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-31-工厂方法收集器Collectors的中的常用函数</title>
    <link href="http://yoursite.com/2017/04/13/jdk8-31-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86%E5%99%A8Collectors%E7%9A%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/04/13/jdk8-31-工厂方法收集器Collectors的中的常用函数/</id>
    <published>2017-04-13T13:28:28.000Z</published>
    <updated>2017-04-14T07:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-collectorImpl"><a href="#1-collectorImpl" class="headerlink" title="1   collectorImpl"></a>1   collectorImpl</h3><ul>
<li><code>Collectors</code> 中的 的基础 <code>collectorImpl</code> 两个构造方法一个有 <code>finisher()</code>, 一个没有。这个很容易理解，一个需要转换中间结果，一个中间结果和最终结果一致，所以不需要使用 <code>finisher()</code> 方法</li>
</ul>
<a id="more"></a>
<h3 id="2-两种实现方式"><a href="#2-两种实现方式" class="headerlink" title="2  两种实现方式"></a>2  两种实现方式</h3><p>对于工厂类 两种实现方式</p>
<ol>
<li><code>CollectorImpl</code> 来实现。</li>
<li><code>reduceing</code> 来实现， 而 <code>reducing</code> 方法归根还是用的是 <code>CollectorImpl</code> 方法来实现</li>
</ol>
<h3 id="3-常见函数"><a href="#3-常见函数" class="headerlink" title="3  常见函数"></a>3  常见函数</h3><h4 id="1）-toList-amp-toCollection"><a href="#1）-toList-amp-toCollection" class="headerlink" title="1）  toList() &amp; toCollection"></a>1）  <code>toList()</code> &amp; <code>toCollection</code></h4><ul>
<li><p>两个最常用的方法 <code>toList()</code> &amp; <code>toCollection</code><br><img src="http://ooapi4q4v.bkt.clouddn.com/14918251558881.jpg" alt=""></p>
</li>
<li><p><code>toSet()</code> 方法是也是 <code>toCollection</code> 的特化。</p>
</li>
</ul>
<h4 id="2）-joining"><a href="#2）-joining" class="headerlink" title="2）  joining()"></a>2）  <code>joining()</code></h4><ul>
<li><code>joining</code> 三种重载方法</li>
</ul>
<h4 id="3）-mapping"><a href="#3）-mapping" class="headerlink" title="3）  mapping()"></a>3）  <code>mapping()</code></h4><ul>
<li><code>mapping()</code> 将输入元素转换成输出元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity= people.stream().collect(groupingBy(</div><div class="line">Person::getCity,</div><div class="line">mapping(Person::getLastName, toSet()) <span class="comment">// Mapping , 将Person 转换成String , 提供给下游 Collector 使用</span></div><div class="line">));</div></pre></td></tr></table></figure>
<h4 id="4）-collectingAndThen"><a href="#4）-collectingAndThen" class="headerlink" title="4）  collectingAndThen()"></a>4）  <code>collectingAndThen()</code></h4><ul>
<li><p><code>collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher)</code>  先过完上层收集器 <code>downstream</code> ，在进行一次 <code>finisher()</code> 转换结果</p>
<p> 比如说，你在 <code>toList()</code> 之后，想将它转换成一个 <code>immutableList()</code> 就可以如下使用</p>
</li>
</ul>
<pre><code class="java">List&lt;String&gt; people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));
</code></pre>
<p>实现其实很有意思<br><img src="http://ooapi4q4v.bkt.clouddn.com/14918263223655.jpg" alt=""></p>
<h4 id="5）-counting-minBy-maxBy"><a href="#5）-counting-minBy-maxBy" class="headerlink" title="5）  counting() , minBy() , maxBy()"></a>5）  <code>counting()</code> , <code>minBy()</code> , <code>maxBy()</code></h4><ul>
<li><code>counting()</code> , <code>minBy()</code> , <code>maxBy()</code> 用 <code>reducing()</code> 实现, <code>reducing()</code> 又是基于 <code>CollectorImpl</code> 实现</li>
</ul>
<h4 id="6）-summingInt-averagingInt-averagingDouble"><a href="#6）-summingInt-averagingInt-averagingDouble" class="headerlink" title="6）  summingInt() , averagingInt() , averagingDouble()"></a>6）  <code>summingInt()</code> , <code>averagingInt()</code> , <code>averagingDouble()</code></h4><ul>
<li><code>summingInt()</code> 对每一个元素使用 <code>toIntFunction</code> 在累加，实现很有意思</li>
</ul>
<p><img src="http://ooapi4q4v.bkt.clouddn.com/14918267966242.jpg" alt=""></p>
<p><code>Supplier()</code> 采用生成了一个 长度为1 的 <code>int</code> 数组，而不是直接使用的整形数字？<br>因为数字是一个 <code>值</code>， 值是无法传递的，而数组是一个 <code>引用</code>， 引用是可以传递的。</p>
<ul>
<li><code>averagingInt()</code> 求平均值</li>
</ul>
<p><img src="http://ooapi4q4v.bkt.clouddn.com/14918270760778.jpg" alt=""></p>
<ul>
<li>对于<code>averagingDouble()</code> 的实现可以再去看一下，他的初始数组长度为4，他们视为浮点数计算的补偿产生的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-collectorImpl&quot;&gt;&lt;a href=&quot;#1-collectorImpl&quot; class=&quot;headerlink&quot; title=&quot;1   collectorImpl&quot;&gt;&lt;/a&gt;1   collectorImpl&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Collectors&lt;/code&gt; 中的 的基础 &lt;code&gt;collectorImpl&lt;/code&gt; 两个构造方法一个有 &lt;code&gt;finisher()&lt;/code&gt;, 一个没有。这个很容易理解，一个需要转换中间结果，一个中间结果和最终结果一致，所以不需要使用 &lt;code&gt;finisher()&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-28-30-自定义收集器&amp;坑</title>
    <link href="http://yoursite.com/2017/04/12/jdk8-28-30-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%94%B6%E9%9B%86%E5%99%A8-%E5%9D%91/"/>
    <id>http://yoursite.com/2017/04/12/jdk8-28-30-自定义收集器-坑/</id>
    <published>2017-04-12T00:32:03.000Z</published>
    <updated>2017-05-02T01:57:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>收集器中有很5个抽象方法，每个抽象方法都有自己特殊的作用，如果说我们要自己实现要给收集器的话，我们就需要分别实现下面五个方法。</p>
<a id="more"></a>
<h3 id="1-简单自定义一个收集器"><a href="#1-简单自定义一个收集器" class="headerlink" title="1 简单自定义一个收集器"></a>1 简单自定义一个收集器</h3><p>这个收集器的目的是将一个 <code>list</code> 转换成一个 <code>set</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</div><div class="line">        System.out.println(<span class="string">"supplier invoked!!!"</span>);</div><div class="line">        <span class="keyword">return</span> HashSet::<span class="keyword">new</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</div><div class="line">	    System.out.println(<span class="string">"accumulator invoked!!!"</span>);</div><div class="line">        <span class="keyword">return</span> Set&lt;T&gt;::add;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 并行性流才会调用，将两个分段的集合</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</div><div class="line">        System.out.println(<span class="string">"combiner invoked!!!"</span>);</div><div class="line">        <span class="keyword">return</span> (t1, t2) -&gt; &#123;</div><div class="line">            t1.addAll(t2);</div><div class="line">            <span class="keyword">return</span> t1;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Set&lt;T&gt;&gt; finisher() &#123;</div><div class="line">        System.out.println(<span class="string">"finisher invoked!!!"</span>);</div><div class="line">        <span class="keyword">return</span> Function.identity();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 描述这个集合的特性</div><div class="line">     * IDENTITY_FINISH 表示结果容器和中间容器是一致的，这个时候 JDK 会在返回的时候自动帮助我们做类型转换。而不用再去调用 finisher</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"characteristics invoked!!!"</span>);</div><div class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH,UNORDERED));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; words = Arrays.asList(<span class="string">"hello"</span> , <span class="string">"world"</span>, <span class="string">"welcome"</span>, <span class="string">"hello"</span>);</div><div class="line"></div><div class="line">        Set&lt;String&gt; stringSet = words.stream().collect(<span class="keyword">new</span> MySetCollector&lt;&gt;());</div><div class="line">        System.out.println(stringSet);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现类里，我们分别实现了5个方法。 其中比较重要的两个方式 <code>finisher</code> 和 <code>characteristics</code>  方法</p>
<p>这俩方法是相互影响的。首先看 <code>characteristics</code>  方法，这个方法要求返回一个 <code>Characteristics</code> 枚举类型对的 <code>Set</code>。而  <code>Characteristics</code> 一共有三个枚举值。分别有不同的含义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 当我们采用并行流的时候，同时设置了  CONCURRENT 作为这个流的特性</div><div class="line">   * 那么，操作的是同一个集合，而不是多个</div><div class="line">   * 同样的道理，我们采用了并行流的方式，但是没有这个特性，我们就会生成多个</div><div class="line">   * 集合</div><div class="line">   */</div><div class="line">  CONCURRENT,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   *  代表集合是否是有序的</div><div class="line">   */</div><div class="line">  UNORDERED,</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 表示 finisher function 可以被省略，因为中间结果和最后的返回的结果的类型是一致的。</div><div class="line">   * 所以当我们设置了这个属性之后，我们就必须了解到， 最后的返回的类型，可以由中间结果类型进行强制的返回。</div><div class="line">   */</div><div class="line">  IDENTITY_FINISH</div></pre></td></tr></table></figure>
<p>上面的例子中，我们为我们自己的 <code>collector</code> 设置了两个属性， <code>IDENTITY_FINISH</code> &amp; <code>UNORDERED</code> ; 意思就是这个收集器收集的元素是无序的。 而同时，返回的类型和中间结果类型是可以完全强制转换的（如果不可以，则会报错，下面会说到）；而 <code>finisher()</code>  函数是不会被执行的，即使你在函数内部直接抛出一个异常都没有问题，因为根本不会执行。<br>执行结果我们可以看一下：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/0cl0ol9dyihk63ocsh0qzjgi/14914603137015.jpg" alt="14914603137015.jpg-102.1kB"></p>
<p>这里需要注意两点：</p>
<ol>
<li>虽然 <code>combiner()</code> 函数被调用了，但是只是返回了一个 <code>BinaryOperator</code> 而已，而这个 <code>BinaryOperator</code> 并不会被调用。</li>
<li><code>finisher()</code> 函数并没有被调用，原因上面已经说过</li>
<li><code>characteristics()</code> 函数被调用了两次，分别代表不同的意思</li>
</ol>
<p>对于第3点，我们跟进 <code>collector()</code> 源代码里看一下, 便会有答案。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/nnftv5zwqcgildzp8ddyd1x3/14914608156971.jpg" alt="14914608156971.jpg-302.5kB"></p>
<p>图中书说法其实不准确，其实是 <code>evaluate</code> 方法中的 <code>ReduceOps.makeRef(collector)</code> 中，会逐个调用相关方法， 包括 <code>characteristics()</code> 方法。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/gj3bj52qxy1im34hvvznjt5s/14914612652241.jpg" alt="14914612652241.jpg-351.7kB"></p>
<p>所以 <code>characteristics()</code> 被调用了两次，第一次用于判断 <strong>是否是无序集合</strong> ；第二次用于判断 <strong>是否需要执行 finisher 用于中间结果和最终结果的类型转换</strong></p>
<h3 id="2-当中间结果与返回结果不一致"><a href="#2-当中间结果与返回结果不一致" class="headerlink" title="2 当中间结果与返回结果不一致"></a>2 当中间结果与返回结果不一致</h3><p>看下面这个改造的自定义收集器，中间结果是个 <code>set</code> 而返回的是个 <code>map</code>，也就是中间结果和最终最终结果是不一致的。这个时候，<code>finisher</code> 函数就会排上用场了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Map</span>&lt;<span class="title">T</span>,<span class="title">T</span>&gt;&gt; </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</div><div class="line">        System.out.println(<span class="string">"supplier invoked!!!!!"</span>);</div><div class="line">        <span class="keyword">return</span> HashSet::<span class="keyword">new</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</div><div class="line">        System.out.println(<span class="string">"accumulator invoked!!!!!"</span>);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">return</span> (set, item) -&gt; &#123;</div><div class="line">            System.out.println(set);</div><div class="line">            System.out.println(<span class="string">"threadName: "</span> + Thread.currentThread().getName());</div><div class="line">            set.add(item);</div><div class="line">        &#125;;</div><div class="line"><span class="comment">//        return Set&lt;T&gt;::add;</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</div><div class="line">        System.out.println(<span class="string">"combiner invoked!!!!!"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</div><div class="line">            set1.addAll(set2);</div><div class="line">            <span class="keyword">return</span> set1;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"finisher invoked!!!!"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> set -&gt; &#123;</div><div class="line">            Map&lt;T, T&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">            set.stream().forEach(item -&gt; map.put(item, item));</div><div class="line">            <span class="keyword">return</span> map;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 当有 Characteristics.CONCURRENT 意味着如果有并发，则是多个线程操作一个集合。</div><div class="line">     * 这个时候 accumulator 如果有 遍历操作，就有可能会抛出  ConcurrentModificationException</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"characteristics invoked!!!!"</span>);</div><div class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++) &#123;</div><div class="line">            List&lt;String&gt; words = Arrays.asList(<span class="string">"hello"</span>, <span class="string">"word"</span>, <span class="string">"helloword"</span>, <span class="string">"hello"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>);</div><div class="line">            Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</div><div class="line">            set.addAll(words);</div><div class="line"></div><div class="line">            Map&lt;String, String&gt; map = set.parallelStream().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</div><div class="line">            System.out.println(map);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里由于我输出与中间结果类型并不一致，所以如果我在 <code>characteristics()</code> 方法中，依旧使用  <code>IDENTITY_FINISH</code> ，也就是进行类型强转，则必然报错，类型转换异常。大家可以自己试一下。</p>
<h3 id="3-并发与并行的区别-并行时候的一些坑"><a href="#3-并发与并行的区别-并行时候的一些坑" class="headerlink" title="3 并发与并行的区别-并行时候的一些坑"></a>3 并发与并行的区别-并行时候的一些坑</h3><p>这里，有另外一个很要命的坑。</p>
<blockquote>
<p>在说这个概念之前，先说一下收集器中 <code>parallel</code> 和 <code>concurrent</code> 的区别</p>
<ul>
<li><code>parallel</code> 是<strong>并行</strong>，会将产生多个集合，多个线程操作，最后合并，也就是会调用 <code>combiner()</code> 方法</li>
</ul>
<ul>
<li><code>concurrent</code> 是<strong>并发</strong>， 是多个线程对同一个集合进行操作，首先 <code>combiner()</code> 函数不会被执行，而同时，如果你在 <code>accumulator()</code> 函数中进行累加操作，又进行遍历操作，就会抛出并发异常。</li>
</ul>
</blockquote>
<p>用例子说话，首先我们必须采用 <code>并行流</code> ， 在 <code>accumulator()</code> 函数中遍历 <code>set</code>, 同时将 <code>characteristics()</code> 函数中加入 <code>CONCURRENT</code> 这个属性，你执行100次，基本都会抛出异常</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/2bpiqnuxu4atmod39o4v090m/14914633115993.jpg" alt="14914633115993.jpg-397.3kB"></p>
<p>原因很简答也比较复杂： 程序采用了并行流 <code>set.parallelStream()</code>，同时设置了 <code>CONCURRENT</code> 属性；也就是说，多个线程操作同一个集合。</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/0cy0jahcni4gnhbb00qjiivv/14914634695900.jpg" alt="14914634695900.jpg-105.6kB"></p>
<p>而在 <code>accumulator()</code> 函数中同时遍历了集合，也修改了集合。由于是多线程操作，很大的概率就会发生你一边遍历集合，一遍修改，就会报错。顺被大家可看看 <code>ConcurrentModificationException</code> 的 <em>javadoc</em>. </p>
<p><img src="http://static.zybuluo.com/zhumin1990719/bgpyjod0lm1fm796tszkxw0c/14914635854475.jpg" alt="14914635854475.jpg-77.1kB"></p>
<p>而如果，你不添加 <code>CONCURRENT</code> 这个属性，就不会报错。因为会生成多个中间集合。这一点，我们可以改造 <code>supplier()</code> 方法，在其中答应一条语句，通过打印了几条语句，就可以看出产生了几个集合。</p>
<blockquote>
<p>当然了，如果你在  <code>accumulator()</code> 中不去有那个遍历的操作，也是即使你添加了 <code>CONCURRENT</code> 属性，也是不会报错的。因为你没有并发的即遍历又修改一个集合</p>
</blockquote>
<p><img src="http://static.zybuluo.com/zhumin1990719/n73a6j6hol02our7kigqyo1x/14914638813587.jpg" alt="14914638813587.jpg-75.7kB"></p>
<p>而一般产生多少集合，由产生多少个线程决定，而产生多少线程一般由机器经过 <code>超线程</code> 技术之后有多少个处理器而确定的。当然也是可以修改的，但是一般没有必要。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 查看有多少处理器</span></div><div class="line">Runtime.getRuntime().availableProcessors();</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集器中有很5个抽象方法，每个抽象方法都有自己特殊的作用，如果说我们要自己实现要给收集器的话，我们就需要分别实现下面五个方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-2-流初步以及Function详解</title>
    <link href="http://yoursite.com/2017/02/14/jdk8-2-%E6%B5%81%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8AFunction%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/02/14/jdk8-2-流初步以及Function详解/</id>
    <published>2017-02-14T06:56:17.000Z</published>
    <updated>2017-04-14T07:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-流初步"><a href="#一-流初步" class="headerlink" title="一 流初步"></a>一 流初步</h3><p>java 8提供一种更加方便的操作集合方式，即流~ <code>Stream</code><br>Stream的概念其实类似于 <em>liunx</em> 操作系统的中的 <code>PipeLine</code> 的概念，可以将数据传输；</p>
<a id="more"></a>
<p>流 分为两种：</p>
<ol>
<li>中间流：数据通过后还返回一个流，不是数据的终点</li>
<li>节点流：数据流入后不再返回流，操作结束，没有返回</li>
</ol>
<p>使用java8 中的 <code>List</code> 来写一个例子，这个例子是将集合中的所有元素，全部变为大写，而后将元素逐一输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list1 = Arrays.asList(<span class="string">"min.zhu"</span>, <span class="string">"yi.yu"</span>, <span class="string">"nai.nai"</span>);</div><div class="line"><span class="comment">//        list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; System.out.println(item));</span></div><div class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        </div><div class="line">        <span class="comment">// 流的操作方式 类似 linux 的管道功能</span></div><div class="line">        <span class="comment">// 流 分为： 中间流 和 节点流</span></div><div class="line">        <span class="comment">// map 称之为 映射 与 mapper-reducer 阶段的map 功能是一致的，给定一个值，返回会一个由于之映射的值</span></div><div class="line">        list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; list2.add(item));</div><div class="line"></div><div class="line">        <span class="comment">// 函数引用的做法</span></div><div class="line">        <span class="comment">// String::toUpperCase 其实 和 item -&gt; item.toUpperCase()</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 一致，都是有输入有输出，而 toUpperCase 的输入，就是调用他的实例对象</div><div class="line">         * 因为一个类是无法调用他的实例方法的，一定是实例才可以调用实例方法</div><div class="line">         */</div><div class="line">        list1.stream().map(String::toUpperCase).forEach(System.out::println);</div><div class="line">        list1.stream().map(String::toUpperCase).forEach(list2::add);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>java8 的调用流的方式，是使用集合的 <code>stream()</code> 方法， 这个方法会返回一个流，之后就可以调用 <code>map()</code> 方法对 <code>list</code> 中的元素做一定的处理。 <code>map()</code> 函数，还是返回了一个流，这个流也有 <code>forEach</code> 方法，这个时候我们还可以调用 <code>forEach</code> 方法对流中的数据进行逐一的处理。</p>
<p>需要注意的是，<code>forEach</code> 函数中, 需要传递的函数的参数是一个 <code>Consumer</code> 的函数式接口，这个接口的抽象方法 <code>accpt()</code> 是没有返回值的，所以，他不在可以返回一个可以继续操作的流。</p>
<p>而我们在看看 <code>map</code> 方法中，需要传递的是一个我们没有见过的 <code>Function</code> 的函数式接口，这个函数式接口，有两个参数，一个是输入参数，一个是返回值。他的唯一的抽象方法中，是接受一个参数，返回一个值。具体见下图，唯一的方法是 <code>apply</code> 方法，它是有返回值的，这一点和现实中的函数很像</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/a0gnbt50hdkjtfdk2ug54yws/image_1b5ng26f4el33qb92s1itsgpl9.png" alt="image_1b5ng26f4el33qb92s1itsgpl9.png-43.2kB"></p>
<blockquote>
<p>我们之前说过，java8 中，新增了很多个函数式接口，分别用于不同的场景<br>如之前说的 <code>Consumer</code> 接口，他是没有返回值的一个场景，专用于处理数据<br>以及今天说的有返回值的 <code>Function</code> 接口</p>
</blockquote>
<p>那么这个 <code>Function</code> 的函数式接口，就是我们今天的重点。</p>
<h3 id="二-Functon-接口-以及-BiFunction简介"><a href="#二-Functon-接口-以及-BiFunction简介" class="headerlink" title="二 Functon 接口 以及 BiFunction简介"></a>二 Functon 接口 以及 BiFunction简介</h3><p>我们可以用一个例子来完整的说明问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 函数式接口 Function 的经典案例</div><div class="line"> * jdk 8 新增很多 函数式接口</div><div class="line"> * 之前看的 forEach 方法中的 Consumer 接口 ，他的作用就是 对给定的参数进行一系列操作，不返回值</div><div class="line"> * 而现在的 以及 Test3 中流的 map 方法中 Function 接口 ，他唯一的操作 是apply , 他有返回值，一个value 一个 Return ，与现实当中数学的函数很类似</div><div class="line"> *</div><div class="line"> * jdk 8 中，接口中 除了可以有 default 方法以外， 还可以有一个 static 方法， static 方法可以有默认的实现</div><div class="line"> * 可以参考 Function 这个函数式接口</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        FunctionTest functionTest = <span class="keyword">new</span> FunctionTest();</div><div class="line"></div><div class="line">        <span class="comment">// 函数式接口，以及 lambda 表达式，让我们可以在函数操作的时候，传递函数，即传递行为</span></div><div class="line">        <span class="comment">// 而之前的编程方法，行为必须已经确定，而后进行调用</span></div><div class="line">        <span class="comment">// 故而 之前的编程方法称之为命令式编程，而后面的方法称之为 函数式编程</span></div><div class="line">        <span class="comment">// 而 可以传递，或者 返回函数的函数，称之为高阶函数（ js 中随处可见高阶函数</span></div><div class="line">        System.out.println(functionTest.compute(<span class="number">1</span>, item -&gt; <span class="number">2</span> * item));</div><div class="line"></div><div class="line">        <span class="comment">// 这种返回方式是 statement 方法</span></div><div class="line">        <span class="comment">// 上面那种方式是 expression 方式</span></div><div class="line">        <span class="comment">// 一个是一个标准的语句，而一个是一个表达式</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 表达式是不需要分好结尾的</div><div class="line">         * 而使用 标准语句，则必须要 ； 而且要 &#123;&#125;</div><div class="line">         */</div><div class="line">        System.out.println(functionTest.compute(<span class="number">1</span>, item -&gt; &#123;<span class="keyword">return</span>  <span class="number">2</span> * item;&#125;));</div><div class="line">        System.out.println(functionTest.compute(<span class="number">2</span>, item -&gt; item * item));</div><div class="line">        System.out.println(functionTest.convert(<span class="string">"hello"</span>, item -&gt; item + <span class="string">" world !!"</span>));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> value, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> function.apply(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String value , Function&lt;String, String&gt; function)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> function.apply(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要去看代码的注释，上面写完了所有重点的内容，我们再去看看 <code>Function</code> 这个函数式接口的实现，我们知道，<code>java8</code> 允许接口有 <code>default</code> 方法，而 <code>Function</code> 接口中有两个默认方法：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/o6nkgv0l1c4kjmaot2r0hd9u/image_1b5ngi5f21mha13p0uu4d06851m.png" alt="image_1b5ngi5f21mha13p0uu4d06851m.png-66.8kB"></p>
<p>利用这个两个方法，可以做函数的组合，用一个函数的输出，作为一个函数的输入。</p>
<ul>
<li><code>compose</code> 方法，是先执行 <code>before</code> 这个function, 在执行本身这个function；</li>
<li><code>andThen</code> 方法，则是先执行 <code>Function</code> 本体的 <code>apply</code> 方法，在执行传入的 <code>after</code> 的方法</li>
</ul>
<p>我们来写个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        FunctionTest2 functionTest2 = <span class="keyword">new</span> FunctionTest2();</div><div class="line"></div><div class="line">        <span class="comment">// 12</span></div><div class="line">        System.out.println(functionTest2.compute(<span class="number">2</span>, item -&gt; item * <span class="number">3</span>, item -&gt; item * item));</div><div class="line">        <span class="comment">// 36</span></div><div class="line">        System.out.println(functionTest2.compute2(<span class="number">2</span>, item -&gt; item * <span class="number">3</span>, item -&gt; item * item));</div><div class="line">        <span class="comment">// 25</span></div><div class="line">        System.out.println(functionTest2.compute3(<span class="number">2</span>, <span class="number">3</span>, (a,b)-&gt; a+b , result -&gt; result * result));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span> <span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * compose 就是 先执行 function2.apply</div><div class="line">         * 再将 function2.apply 的返回值，作为 function1 的输入</div><div class="line">         * 此时再执行 function1 apply</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> function1.compose(function2).apply(a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute2</span> <span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * compose 就是 先执行 function1.apply</div><div class="line">         * 再将 function1.apply 的返回值，作为 function2 的输入</div><div class="line">         * 此时再执行 function2 apply</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> function1.andThen(function2).apply(a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 如果想做有两个参数的Function 就需要使用BiFunction</div><div class="line">     * 而 BiFunction 只有一个 andThen , andThen 的输入 是 Function，</div><div class="line">     * 因为是将 Apply 的结果返回，结果只有一个，所以 参数只能是 Function , 而不是 BiFunction</div><div class="line">     * 所以 BiFunction 方法不可能有 compose 方法</div><div class="line">     *</div><div class="line">     * 对应的  consumer 也有着 BiConsumer 同时，二者因为没有返回值，所以也只可能有 andThen 方法</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute3</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> biFunction.andThen(function).apply(a,b);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>compose</code> 和 <code>andThen</code> 的功能可以从例子中很好的看出来，例子中还有一个新的接口叫 <code>BiFunction</code>, 这个函数式接口是给定两个输入，返回一个输出，解决了有两个参数的函数的问题，对应的，其实 <code>Comsumer</code> 接口也还有一个对应的 <code>BiConsumer</code> 接口。</p>
<p>而当我们去观察这俩 <code>Bi</code> 的接口，都只有一个 <code>andThen</code> 的接口，为啥没有 <code>compose</code> 方法呢？<br>给读者自己思考吧~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-流初步&quot;&gt;&lt;a href=&quot;#一-流初步&quot; class=&quot;headerlink&quot; title=&quot;一 流初步&quot;&gt;&lt;/a&gt;一 流初步&lt;/h3&gt;&lt;p&gt;java 8提供一种更加方便的操作集合方式，即流~ &lt;code&gt;Stream&lt;/code&gt;&lt;br&gt;Stream的概念其实类似于 &lt;em&gt;liunx&lt;/em&gt; 操作系统的中的 &lt;code&gt;PipeLine&lt;/code&gt; 的概念，可以将数据传输；&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-1.1-方法引用：lambda表达式的语法糖</title>
    <link href="http://yoursite.com/2017/02/12/jdk8-1-1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://yoursite.com/2017/02/12/jdk8-1-1-方法引用：lambda表达式的语法糖/</id>
    <published>2017-02-12T07:31:46.000Z</published>
    <updated>2017-04-14T07:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>方法应用其实是 jdk 8 中的对于  <em>lambda</em> 表达式给予的一种 <strong>语法糖</strong></p>
</blockquote>
<p>而方法引用一共分为 4 种；</p>
<ul>
<li>1 <code>类名::静态方法名</code></li>
<li>2 <code>对象名::方法名</code></li>
<li>3 <code>类名::实例方法名</code></li>
<li>4 <code>构造方法引用::new</code></li>
</ul>
<a id="more"></a>
<p>我们有intellj 编写 lambda 表达式的时候，编译器总是标黄来告诉你，这里可以使用方法引用的方法来进行代码的简化</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/6sl7hr28156h9kmv9jsmstb6/image_1b7k0qtepmls15v3rjv19691om39.png" alt="image_1b7k0qtepmls15v3rjv19691om39.png-86kB"></p>
<p>而方法引用，<strong><em>method reference</em></strong> 其实就是lambda表达式一种语法糖<br>但是 </p>
<blockquote>
<p><strong>不是所有的 lambda 表达式，都可以用方法引用的方式来编写</strong><br>复杂的 lambda 表达式还是需要老老实实写相关代码</p>
</blockquote>
<p>我们通过一个例子来分别讲解这四种方法引用的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 第一种</span></div><div class="line"></div><div class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">"zhumin1"</span>,<span class="number">10</span>);</div><div class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">"zhumin2"</span>,<span class="number">20</span>);</div><div class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">"zhumin3"</span>,<span class="number">40</span>);</div><div class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">"zhumin4"</span>,<span class="number">80</span>);</div><div class="line"></div><div class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</div><div class="line"></div><div class="line">        <span class="comment">// jdk 1.8 的新方法  List 中新增加了 sort 方法</span></div><div class="line">        <span class="comment">// 传统的 lambda 表达式</span></div><div class="line">        students.sort((studentP1, studentP2) -&gt; Student.compareByScore(studentP1, studentP2));</div><div class="line">        <span class="comment">// 第一种方法引用的方式 类名::静态方法名</span></div><div class="line">        <span class="comment">// 不需要传参数，因为可以自动推断出 Student 类型</span></div><div class="line">        students.sort(Student::compareByScore);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 第二种 对象名称::方法名称</span></div><div class="line">        <span class="comment">// 其实和第一种很类似</span></div><div class="line">        StudentComparator studentComparator = <span class="keyword">new</span> StudentComparator();</div><div class="line"></div><div class="line">        students.sort((studentP1, studentP2) -&gt; studentComparator.comparator(studentP1, studentP2));</div><div class="line">        <span class="comment">// 对象名称::方法名称 (方法引用的第二种方式)</span></div><div class="line">        students.sort(studentComparator::comparator);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 第三种方法 类名::实例方法</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 比较难理解的的地方是，你会看到调用的函数，和 lambda 表达式需要的参数个数不一致， 会少一个</div><div class="line">         * 而且类名是没法调用方法名的</div><div class="line">         * 而理解方式是：调用方法的实例，就是传入lambda 表达式的第一个参数，而剩下所有参数，都作为 调用的实例方法 的参数</div><div class="line">         * 我们看下面的例子 ， Student 类调用的是其的实例方法 compare（Student） 只有一个参数</div><div class="line">         * 而 List 的默认方法需要的 Comparator 的函数式接口需要两个参数，看似对应不上，而且，类名也无法调用实例方法</div><div class="line">         * 实际是，传入的第一参数就是 comare（student）这个函数的调用者，而第二个参数以及后续所有的参数（如果有跟多也是一样），是作为实例方法的参数传入</div><div class="line">         * 所以少一个参数也没什么</div><div class="line">         * 而更为关键的是这个就是一个语法糖，为了简化代码而生。理解就好</div><div class="line">         * 如此一来； 这个第三种方式就很好理解了</div><div class="line">         *</div><div class="line">         * 类名::实例方法</div><div class="line">         * 即 lambda 表达式的第一参数就是 实例方法 的调用者，后续所有的参数就是 实例方法的传入参数</div><div class="line">         */</div><div class="line">        students.sort(Student::compare);</div><div class="line"></div><div class="line">        <span class="comment">// 再看一个例子</span></div><div class="line">        List&lt;String&gt; cities = Arrays.asList(<span class="string">"haha"</span>,<span class="string">"lala"</span>,<span class="string">"nihao"</span>,<span class="string">"memeda"</span>);</div><div class="line">        <span class="comment">// 对比二者</span></div><div class="line">        Collections.sort(cities, (city1, city2) -&gt; city1.compareToIgnoreCase(city2));</div><div class="line">        Collections.sort(cities, String::compareToIgnoreCase);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 对于第四种，构造方法引用，对于带参数和不带参数的都可以，编译器会自动的进行腿短</span></div><div class="line">        MethodRefrenceTest methodRefrenceTest = <span class="keyword">new</span> MethodRefrenceTest();</div><div class="line">        <span class="comment">// 点击 new 看看会跳到那个方法里去</span></div><div class="line">        methodRefrenceTest.getName(String::<span class="keyword">new</span>);</div><div class="line">        <span class="comment">// 点击 new 看看会跳到那个方法里去</span></div><div class="line">        methodRefrenceTest.getName2(<span class="string">"haa"</span>, String::<span class="keyword">new</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(Supplier&lt;String&gt; supplier)</span>  </span>&#123;</div><div class="line">        <span class="keyword">return</span> supplier.get() + <span class="string">"haha"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName2</span><span class="params">(String name, Function&lt;String ,String&gt; stringFunction)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringFunction.apply(name);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;方法应用其实是 jdk 8 中的对于  &lt;em&gt;lambda&lt;/em&gt; 表达式给予的一种 &lt;strong&gt;语法糖&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而方法引用一共分为 4 种；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &lt;code&gt;类名::静态方法名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2 &lt;code&gt;对象名::方法名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3 &lt;code&gt;类名::实例方法名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4 &lt;code&gt;构造方法引用::new&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-1-函数式接口&amp;lambda表达式</title>
    <link href="http://yoursite.com/2017/02/11/jdk8-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/02/11/jdk8-1-函数式接口-lambda表达式/</id>
    <published>2017-02-11T07:00:25.000Z</published>
    <updated>2017-04-14T07:13:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-lmabda表达式"><a href="#1-lmabda表达式" class="headerlink" title="1 lmabda表达式"></a>1 lmabda表达式</h3><p>首先看两段对比代码:<br>为jbutton 添加一个时间监听器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 老写法: 匿名内部类</span></div><div class="line">jButton.addActionListener(<span class="keyword">new</span> AbstractAction() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello Button"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">        </div><div class="line"><span class="comment">// lambda 表达式写法</span></div><div class="line">jButton.addActionListener(e -&gt; System.out.println(<span class="string">"Hello Button"</span>));</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>对比两个写法，lambda表达式的写法会简单很多，如果你有多行处理逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加个大括号</span></div><div class="line">jButton.addActionListener(e -&gt;&#123;</div><div class="line">    System.out.println(<span class="string">"Hello Button!!!!"</span>);</div><div class="line">    System.out.println(<span class="string">"Hello Button2!!!!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这里的e，没有声明类型，并不是表示java 不是一个静态语言了，而是，编译器的类型推断告诉可以推断出来这个 <code>e</code> 的类型肯定是一个 <code>AbstractAction</code>, 所以无需去写，当然如写上也没有问题，需要加上括号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jButton.addActionListener((AbstractAction e) -&gt;&#123;</div><div class="line">    System.out.println(<span class="string">"Hello Button!!!!"</span>);</div><div class="line">    System.out.println(<span class="string">"Hello Button2!!!!"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>所以 <strong>lambda</strong> 表达式的基本结构如下（根据单个参数和单个操作可以有一定的省略）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(event e1, event e2 ...) -&gt; &#123;</div><div class="line">    action1;</div><div class="line">    action2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一开始可能不是特别好理解，我们可以结合 <strong>java8</strong> 新增的另一个特性 <strong>函数式接口</strong> 来一起理解为何我们可以如此编写代码</p>
<h3 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2 函数式接口"></a>2 函数式接口</h3><p>什么叫函数式接口呢？ 函数式接口是 <code>jdk1.8</code> 中新增的一个接口类型，为此还新增了一个注解 <code>@FunctionalInterface</code> 用于标注函数接口；我们通过阅读 <code>@FunctionalInterface</code> 的 <em>jdk</em> 文档来进行概念认知。总结起来：</p>
<ul>
<li>当一个接口 有且只有一个抽象方法，并且这个抽象方法不是继承自 <code>Object</code> 的方法，就会被当做一个 <strong>函数式接口</strong></li>
<li>当一个接口被  <code>@FunctionalInterface</code> 注解时，可以当做一个函数式接口</li>
<li>当一个接口被  <code>@FunctionalInterface</code> 注解，但不满足第一个条件的时候，编译器会报错。</li>
<li>当一个接口 没有被 <code>@FunctionalInterface</code> 注解标注，但是满足函数式接口的条件，也会被当做函数式接口</li>
</ul>
<blockquote>
<p>这里的第一条后半部分很重要，如果一个接口，有两个抽象方法，但是其中一个是继承自 <code>Object</code> 类（因为其实万类师祖）, 他仍然是一个函数式接口。</p>
</blockquote>
<p>例如以下实例就是一个完整的函数式接口，即使他有2个抽象方法，但是toString是继承自 <code>Object</code> 的方法，所以不会算作函数式接口的抽象方法，所以其中的 <code>test()</code> 方法, 是函数式接口认定的唯一的抽象方法。<br>同理，如果下面的例子只有 <code>toString()</code> 方法，而没有 <code>test()</code> 方法，同时又有  <code>@FunctionalInterface</code> 注解的话，那么编译器会报错。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 函数式接口，只能有唯一的抽象方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 因为改抽象方法，继承自 Object，所以不算函数式接口的抽象方法</div><div class="line">     * 故而，接口可以算作一个函数式接口</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看一下  <code>@FunctionalInterface</code> 的jdk文档，里面有一句: </p>
<center><img src="http://static.zybuluo.com/zhumin1990719/xgz9c76x5q7q1fa3fyvrzilz/image_1b4cpml3c13mn1cju14uurjun9v9.png" alt="image_1b4cpml3c13mn1cju14uurjun9v9.png-24.9kB"></center>

<p>意思就是说，函数式接口的实现，可以通过 <code>lambda</code> 表达式 <strong>方法引用</strong> 以及 <strong>构造方法引用</strong> 的方式来实现。其实我们上面的 <code>lambda</code> 表达式的例子，就是实现的函数式接口。我们来新写一个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterface</span><span class="params">(MyInterface myInterface)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"start ------------------"</span>);</div><div class="line">        myInterface.test();</div><div class="line">        System.out.println(<span class="string">"end --------------------"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Test2 test2 = <span class="keyword">new</span> Test2();</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 因为函数式接口的里唯一的抽象方法test里面，没有参数</div><div class="line">         * 但是（）不能省略</div><div class="line">         * 参考Test1 程序里面的Jframe 里的ActionListener</div><div class="line">         */</div><div class="line">        test2.testInterface(() -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"函数式接口接口实现"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，<code>testInterface</code> 方法需要传递一个 <code>testInterface</code><br>的接口，而我们使用的方式就是 <code>lambda</code> 表达式来实现了一个函数式接口。 可以运用下面的形式来理解。</p>
<blockquote>
<p>(函数式接口唯一的抽象方法的参数列表) -&gt; {唯一抽象函数的实现}</p>
</blockquote>
<p>这个时候，我们看一下最开始的那个给 <strong>button</strong> 加 action 的例子。<br>其实实现就是 <code>ActionListener</code> 这个函数式接口的唯一的抽象方法：<br><img src="http://static.zybuluo.com/zhumin1990719/uy91dk519fbykpnmbovocu5h/image_1b4cq5u2j1548e4eif0l1t1t48m.png" alt="image_1b4cq5u2j1548e4eif0l1t1t48m.png-35.9kB"><br>虽然该类没有 <code>@FunctionalInterface</code> 注解，但是满足条件，只有一个抽象方法，所以他也是一个函数式接口，所以我们可以去使用 <code>lambda</code> 表达式去实现他。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-lmabda表达式&quot;&gt;&lt;a href=&quot;#1-lmabda表达式&quot; class=&quot;headerlink&quot; title=&quot;1 lmabda表达式&quot;&gt;&lt;/a&gt;1 lmabda表达式&lt;/h3&gt;&lt;p&gt;首先看两段对比代码:&lt;br&gt;为jbutton 添加一个时间监听器&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 老写法: 匿名内部类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;jButton.addActionListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AbstractAction() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;actionPerformed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ActionEvent e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello Button&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// lambda 表达式写法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;jButton.addActionListener(e -&amp;gt; System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello Button&quot;&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
  </entry>
  
  <entry>
    <title>new start</title>
    <link href="http://yoursite.com/2017/01/11/new-start/"/>
    <id>http://yoursite.com/2017/01/11/new-start/</id>
    <published>2017-01-11T13:42:13.000Z</published>
    <updated>2017-04-14T06:58:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>重新开始维护这个网站。让自己配得上这个不错的域名 <code>movingon.cn!</code></p>
<a id="more"></a>
<p>我14年买了这个域名，本来想自己要好好做，实在不行，这域名也是一个不错的督促。</p>
<p>然而，自己维护了一段时间之后，就忘记了要去维护。</p>
<p>但是这一次，我用这里记录自己的技术成长以及个人感悟，作为自己的成长的记录。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新开始维护这个网站。让自己配得上这个不错的域名 &lt;code&gt;movingon.cn!&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="鸡汤" scheme="http://yoursite.com/tags/%E9%B8%A1%E6%B1%A4/"/>
    
  </entry>
  
</feed>
