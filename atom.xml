<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>待葡萄嗖透</title>
  <subtitle>你说啥？</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-04-30T08:59:27.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>朱老师&amp;敏哥</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jdk8-32-groupingBy 源码分析</title>
    <link href="http://yoursite.com/2017/04/30/jdk8-32-groupingBy-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2017/04/30/jdk8-32-groupingBy-源码分析/</id>
    <published>2017-04-30T08:58:34.000Z</published>
    <updated>2017-04-30T08:59:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>jdk8 集合的工厂类 <code>Collectors</code> 提供了两个很好用的静态函数。</p>
<ul>
<li>groupingBy</li>
<li>partitioningBy</li>
</ul>
<p><code>groupingBy</code> 实现类似 Mysql 中分分组功能。返回一个 Map; 而 <code>partitioningBy</code>可以看做是 <code>groupingBy</code> 的特殊形式。我们后面会接着介绍。 使用的是比如统计每个城市人的“姓”，可以这么写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream().collect(groupingBy(Person::getCity,                                            mapping(Person::getLastName, toSet())));</div></pre></td></tr></table></figure>
<p>那么，他到底如何利用 <code>Collector</code> 的各个接口来实现的呢？下面我们将深入 JDK 的 <code>Collectors</code> 的源码中，分析一下他是如何工作的。 </p>
<h2 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy"></a>groupingBy</h2><h3 id="1-第一个重载方法-要简单就别那么多要求，给你个List不错了"><a href="#1-第一个重载方法-要简单就别那么多要求，给你个List不错了" class="headerlink" title="1 第一个重载方法, 要简单就别那么多要求，给你个List不错了"></a>1 第一个重载方法, 要简单就别那么多要求，给你个List不错了</h3><p>分组 <code>groupingBy</code> 有三个重载方法。一个比一复杂。</p>
<p>先看最简单的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input elements</div><div class="line">     * <span class="doctag">@param</span> &lt;K&gt; the type of the keys</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;</div><div class="line">    groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;</div><div class="line">        <span class="keyword">return</span> groupingBy(classifier, toList());</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这里 <code>T</code> 是输入集合的元素类型， <code>K</code> 是最后产生的 Map 的主键key 的类型。</p>
<p>函数需要传入一个 <code>Function</code> 的函数式接口，<code>Function</code> 的中作就是分类器，比如传入的类型是<code>T</code> 是一个 <code>Person</code>类型 ， 通过 <code>apply()</code> 方法，返回 <code>Person</code> 的属性 <code>name</code>；因为我们要按照 <code>name</code> 来分组。</p>
<p>所以，如果 <code>name</code> 的类型是 <code>String</code> ； 那么 <code>K</code> 就是 <code>String</code></p>
<p>故而，这个 <code>groupingBy(function)</code> 的功能就很清晰了，就是通过 <code>function</code> 对传入的 <code>T</code> 类型进行分类。然后调用 <code>toList()</code> 方法，也就是说每个分类的<code>Person</code> 会放进一个 <code>List&lt;Person&gt;</code> 中</p>
<p>最终返回的类型就是 <code>Map&lt;String, List&lt;Person&gt;&gt;</code>.</p>
<p>而如果你不想返回的是一个<code>List</code> , 希望是一个 <code>Set</code>. 你就要使用第二个重载方法~ 他允许你定义最后的输出函数。</p>
<h3 id="2-第二个重载方法：我要输出Set"><a href="#2-第二个重载方法：我要输出Set" class="headerlink" title="2 第二个重载方法：我要输出Set"></a>2 第二个重载方法：我要输出Set</h3><p>看一下函数的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input elements</div><div class="line">     * <span class="doctag">@param</span> &lt;K&gt; the type of the keys</div><div class="line">     * <span class="doctag">@param</span> &lt;A&gt; the intermediate accumulation type of the downstream collector</div><div class="line">     * <span class="doctag">@param</span> &lt;D&gt; the result type of the downstream reduction</div><div class="line">     * <span class="doctag">@param</span> classifier a classifier function mapping input elements to keys</div><div class="line">     * <span class="doctag">@param</span> downstream a &#123;<span class="doctag">@code</span> Collector&#125; implementing the downstream reduction</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt;</div><div class="line">    Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</div><div class="line">                                          Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</div><div class="line">        <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个函数，明显比上一个要复杂，可以看到，多了一个 <code>Collector</code> 的 <code>downstream</code> , 可以自定义输出的集合。上面那个简单版本的函数是是写死的 <code>List</code></p>
<p>这个函数有四个泛型。</p>
<ul>
<li><code>T</code> 原始元素类型，比如我们这是 <code>Person</code></li>
<li><code>K</code> 返回 Map 的 key, 即最终返回的Map 的建的类型。如果你想按照人的名字分类，那T就是 <code>String</code>, 如果按照年龄分类，那就是 <code>Interger</code></li>
<li><code>A</code> 是 downstream 的 accumulation 的中间结果类型</li>
<li><code>D</code> 是最终输出 Map 的 Value 的类型。比如 <code>List</code> 或者 <code>Set</code> </li>
</ul>
<p>这个方法会调用第三个重载函数，比第二个函数，多了中间的 <code>HashMap::new</code>； 这个是最终返回的 Map 的类型，这里写死的是 HashMap, 如果你想用其他类型，就需要使用最终的也是最复杂的第三个重载函数。</p>
<p>越是你用起来简单的函数，背后的实现就越来越复杂。</p>
<h3 id="3-第三个重载方法-能看懂就随便你怎么玩"><a href="#3-第三个重载方法-能看懂就随便你怎么玩" class="headerlink" title="3 第三个重载方法: 能看懂就随便你怎么玩"></a>3 第三个重载方法: 能看懂就随便你怎么玩</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* <span class="doctag">@param</span> &lt;T&gt; the type of the input elements</div><div class="line">* <span class="doctag">@param</span> &lt;K&gt; the type of the keys</div><div class="line">* <span class="doctag">@param</span> &lt;A&gt; the intermediate accumulation type of the downstream collector</div><div class="line">* <span class="doctag">@param</span> &lt;D&gt; the result type of the downstream reduction</div><div class="line">* <span class="doctag">@param</span> &lt;M&gt; the type of the resulting &#123;<span class="doctag">@code</span> Map&#125;</div><div class="line">* <span class="doctag">@param</span> classifier a classifier function mapping input elements to keys</div><div class="line">* <span class="doctag">@param</span> downstream a &#123;<span class="doctag">@code</span> Collector&#125; implementing the downstream reduction</div><div class="line">* <span class="doctag">@param</span> mapFactory a function which, when called, produces a new empty</div><div class="line">*                   &#123;<span class="doctag">@code</span> Map&#125; of the desired type</div><div class="line">*/</div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;</div><div class="line">    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier,</div><div class="line">                                  Supplier&lt;M&gt; mapFactory,</div><div class="line">                                  Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</div><div class="line">        Supplier&lt;A&gt; downstreamSupplier = downstream.supplier();</div><div class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> T&gt; downstreamAccumulator = downstream.accumulator();</div><div class="line">        BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123;</div><div class="line">            K key = Objects.requireNonNull(classifier.apply(t), <span class="string">"element cannot be mapped to a null key"</span>);</div><div class="line">            A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get());</div><div class="line">            downstreamAccumulator.accept(container, t);</div><div class="line">        &#125;;</div><div class="line">        BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner());</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher();</div><div class="line">            Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123;</div><div class="line">                intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v));</div><div class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                M castResult = (M) intermediate;</div><div class="line">                <span class="keyword">return</span> castResult;</div><div class="line">            &#125;;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个函数有5个泛型，除去上面说的 <code>T</code>，<code>K</code>，<code>A</code>，<code>D</code><br>多了一个 mapFactory 的 Supplier() , 用于得到最终返回的 Map 的类型，第二个重载函数写死的 HashMap，这就可以进行自定义。</p>
<p>这个函数有连个值得注意的点：</p>
<ul>
<li>所有的Collectors 中函数，如果函数内部还要做集合处理的，都是使用 <code>downstream</code> 这种模式，利用 <code>downstream</code> 的各种已有的的 <code>Supplier</code> <code>Accumulator</code>等，修改来实现自己的功能。比如在 <code>groupingBy</code> 这个函数，一开始就获取了 <code>downstream</code> 的各个组件，组合成自己需要的收集器，进而用于完成分类的行为。（你还可以去看一看 <code>collectingAndThen()</code> 这个函数）</li>
</ul>
<p><img src="http://static.zybuluo.com/zhumin1990719/r9lzmhqejhu4poxfa65jrwg0/image_1be34fqkpdosrnqo8317uhcnc9.png" alt="image_1be34fqkpdosrnqo8317uhcnc9.png-228kB"></p>
<ul>
<li><code>groupingBy</code> 函数中有有两处强制类型转换。这里其实很难理解，为何可以直接成功的转换呢？</li>
</ul>
<p>第一处<br><img src="http://static.zybuluo.com/zhumin1990719/9aw6m36vtunxhzintfqzhw8x/image_1be351ek7187m19721kb3vijudj13.png" alt="image_1be351ek7187m19721kb3vijudj13.png-186.2kB"></p>
<p>第二处<br><img src="http://static.zybuluo.com/zhumin1990719/lqq4sk8y37vbchc9m7ajs0cn/image_1be353p451uuhvefd57r2u16ad1g.png" alt="image_1be353p451uuhvefd57r2u16ad1g.png-161.3kB"></p>
<p>两处其实都是将最终结果泛型 <code>D</code> 转成 中间结果 <code>A</code>。<br>对于第一处， mapFactory 是作为一个 <code>Supplier</code> 出现，而他的目的是提供中间结果类型，而他上面的 <code>accumulator</code> 的中间结果类型，就是<strong>K,A</strong>， 所以这样的强转是一定可以成功的</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/sqtr5d56vcc4y5qtm6yhv271/image_1be35m758itj1grmlc71nu81rrm1t.png" alt="image_1be35m758itj1grmlc71nu81rrm1t.png-139.5kB"></p>
<p>第二处也是一样的，因为全称都使用了 <code>A</code>，其实 <code>A</code> 和 <code>D</code> 在这里，是等价的。所以转换都可以成功。</p>
<p>你去可以从这么一个角度思考问题：</p>
<blockquote>
<p>你最终需要生成 <code>D</code> 类型，为何中间要给自己生成一个不一样的 <code>A</code> 类型添堵呢？ 你 4 不 4 sa？</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jdk8 集合的工厂类 &lt;code&gt;Collectors&lt;/code&gt; 提供了两个很好用的静态函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;groupingBy&lt;/li&gt;
&lt;li&gt;partitioningBy&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;groupingBy&lt;/code&gt; 
    
    </summary>
    
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-31-工厂方法收集器Collectors的中的常用函数</title>
    <link href="http://yoursite.com/2017/04/13/jdk8-31-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%94%B6%E9%9B%86%E5%99%A8Collectors%E7%9A%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2017/04/13/jdk8-31-工厂方法收集器Collectors的中的常用函数/</id>
    <published>2017-04-13T13:28:28.000Z</published>
    <updated>2017-04-14T07:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-collectorImpl"><a href="#1-collectorImpl" class="headerlink" title="1   collectorImpl"></a>1   collectorImpl</h3><ul>
<li><code>Collectors</code> 中的 的基础 <code>collectorImpl</code> 两个构造方法一个有 <code>finisher()</code>, 一个没有。这个很容易理解，一个需要转换中间结果，一个中间结果和最终结果一致，所以不需要使用 <code>finisher()</code> 方法</li>
</ul>
<a id="more"></a>
<h3 id="2-两种实现方式"><a href="#2-两种实现方式" class="headerlink" title="2  两种实现方式"></a>2  两种实现方式</h3><p>对于工厂类 两种实现方式</p>
<ol>
<li><code>CollectorImpl</code> 来实现。</li>
<li><code>reduceing</code> 来实现， 而 <code>reducing</code> 方法归根还是用的是 <code>CollectorImpl</code> 方法来实现</li>
</ol>
<h3 id="3-常见函数"><a href="#3-常见函数" class="headerlink" title="3  常见函数"></a>3  常见函数</h3><h4 id="1）-toList-amp-toCollection"><a href="#1）-toList-amp-toCollection" class="headerlink" title="1）  toList() &amp; toCollection"></a>1）  <code>toList()</code> &amp; <code>toCollection</code></h4><ul>
<li><p>两个最常用的方法 <code>toList()</code> &amp; <code>toCollection</code><br><img src="http://ooapi4q4v.bkt.clouddn.com/14918251558881.jpg" alt=""></p>
</li>
<li><p><code>toSet()</code> 方法是也是 <code>toCollection</code> 的特化。</p>
</li>
</ul>
<h4 id="2）-joining"><a href="#2）-joining" class="headerlink" title="2）  joining()"></a>2）  <code>joining()</code></h4><ul>
<li><code>joining</code> 三种重载方法</li>
</ul>
<h4 id="3）-mapping"><a href="#3）-mapping" class="headerlink" title="3）  mapping()"></a>3）  <code>mapping()</code></h4><ul>
<li><code>mapping()</code> 将输入元素转换成输出元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Map&lt;City, Set&lt;String&gt;&gt; lastNamesByCity= people.stream().collect(groupingBy(</div><div class="line">Person::getCity,</div><div class="line">mapping(Person::getLastName, toSet()) <span class="comment">// Mapping , 将Person 转换成String , 提供给下游 Collector 使用</span></div><div class="line">));</div></pre></td></tr></table></figure>
<h4 id="4）-collectingAndThen"><a href="#4）-collectingAndThen" class="headerlink" title="4）  collectingAndThen()"></a>4）  <code>collectingAndThen()</code></h4><ul>
<li><p><code>collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher)</code>  先过完上层收集器 <code>downstream</code> ，在进行一次 <code>finisher()</code> 转换结果</p>
<p> 比如说，你在 <code>toList()</code> 之后，想将它转换成一个 <code>immutableList()</code> 就可以如下使用</p>
</li>
</ul>
<pre><code class="java">List&lt;String&gt; people = people.stream().collect(collectingAndThen(toList(), Collections::unmodifiableList));
</code></pre>
<p>实现其实很有意思<br><img src="http://ooapi4q4v.bkt.clouddn.com/14918263223655.jpg" alt=""></p>
<h4 id="5）-counting-minBy-maxBy"><a href="#5）-counting-minBy-maxBy" class="headerlink" title="5）  counting() , minBy() , maxBy()"></a>5）  <code>counting()</code> , <code>minBy()</code> , <code>maxBy()</code></h4><ul>
<li><code>counting()</code> , <code>minBy()</code> , <code>maxBy()</code> 用 <code>reducing()</code> 实现, <code>reducing()</code> 又是基于 <code>CollectorImpl</code> 实现</li>
</ul>
<h4 id="6）-summingInt-averagingInt-averagingDouble"><a href="#6）-summingInt-averagingInt-averagingDouble" class="headerlink" title="6）  summingInt() , averagingInt() , averagingDouble()"></a>6）  <code>summingInt()</code> , <code>averagingInt()</code> , <code>averagingDouble()</code></h4><ul>
<li><code>summingInt()</code> 对每一个元素使用 <code>toIntFunction</code> 在累加，实现很有意思</li>
</ul>
<p><img src="http://ooapi4q4v.bkt.clouddn.com/14918267966242.jpg" alt=""></p>
<p><code>Supplier()</code> 采用生成了一个 长度为1 的 <code>int</code> 数组，而不是直接使用的整形数字？<br>因为数字是一个 <code>值</code>， 值是无法传递的，而数组是一个 <code>引用</code>， 引用是可以传递的。</p>
<ul>
<li><code>averagingInt()</code> 求平均值</li>
</ul>
<p><img src="http://ooapi4q4v.bkt.clouddn.com/14918270760778.jpg" alt=""></p>
<ul>
<li>对于<code>averagingDouble()</code> 的实现可以再去看一下，他的初始数组长度为4，他们视为浮点数计算的补偿产生的。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-collectorImpl&quot;&gt;&lt;a href=&quot;#1-collectorImpl&quot; class=&quot;headerlink&quot; title=&quot;1   collectorImpl&quot;&gt;&lt;/a&gt;1   collectorImpl&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Collectors&lt;/code&gt; 中的 的基础 &lt;code&gt;collectorImpl&lt;/code&gt; 两个构造方法一个有 &lt;code&gt;finisher()&lt;/code&gt;, 一个没有。这个很容易理解，一个需要转换中间结果，一个中间结果和最终结果一致，所以不需要使用 &lt;code&gt;finisher()&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-2-流初步以及Function详解</title>
    <link href="http://yoursite.com/2017/02/14/jdk8-2-%E6%B5%81%E5%88%9D%E6%AD%A5%E4%BB%A5%E5%8F%8AFunction%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/02/14/jdk8-2-流初步以及Function详解/</id>
    <published>2017-02-14T06:56:17.000Z</published>
    <updated>2017-04-14T07:07:10.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-流初步"><a href="#一-流初步" class="headerlink" title="一 流初步"></a>一 流初步</h3><p>java 8提供一种更加方便的操作集合方式，即流~ <code>Stream</code><br>Stream的概念其实类似于 <em>liunx</em> 操作系统的中的 <code>PipeLine</code> 的概念，可以将数据传输；</p>
<a id="more"></a>
<p>流 分为两种：</p>
<ol>
<li>中间流：数据通过后还返回一个流，不是数据的终点</li>
<li>节点流：数据流入后不再返回流，操作结束，没有返回</li>
</ol>
<p>使用java8 中的 <code>List</code> 来写一个例子，这个例子是将集合中的所有元素，全部变为大写，而后将元素逐一输出<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list1 = Arrays.asList(<span class="string">"min.zhu"</span>, <span class="string">"yi.yu"</span>, <span class="string">"nai.nai"</span>);</div><div class="line"><span class="comment">//        list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; System.out.println(item));</span></div><div class="line">        List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        </div><div class="line">        <span class="comment">// 流的操作方式 类似 linux 的管道功能</span></div><div class="line">        <span class="comment">// 流 分为： 中间流 和 节点流</span></div><div class="line">        <span class="comment">// map 称之为 映射 与 mapper-reducer 阶段的map 功能是一致的，给定一个值，返回会一个由于之映射的值</span></div><div class="line">        list1.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; list2.add(item));</div><div class="line"></div><div class="line">        <span class="comment">// 函数引用的做法</span></div><div class="line">        <span class="comment">// String::toUpperCase 其实 和 item -&gt; item.toUpperCase()</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 一致，都是有输入有输出，而 toUpperCase 的输入，就是调用他的实例对象</div><div class="line">         * 因为一个类是无法调用他的实例方法的，一定是实例才可以调用实例方法</div><div class="line">         */</div><div class="line">        list1.stream().map(String::toUpperCase).forEach(System.out::println);</div><div class="line">        list1.stream().map(String::toUpperCase).forEach(list2::add);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>java8 的调用流的方式，是使用集合的 <code>stream()</code> 方法， 这个方法会返回一个流，之后就可以调用 <code>map()</code> 方法对 <code>list</code> 中的元素做一定的处理。 <code>map()</code> 函数，还是返回了一个流，这个流也有 <code>forEach</code> 方法，这个时候我们还可以调用 <code>forEach</code> 方法对流中的数据进行逐一的处理。</p>
<p>需要注意的是，<code>forEach</code> 函数中, 需要传递的函数的参数是一个 <code>Consumer</code> 的函数式接口，这个接口的抽象方法 <code>accpt()</code> 是没有返回值的，所以，他不在可以返回一个可以继续操作的流。</p>
<p>而我们在看看 <code>map</code> 方法中，需要传递的是一个我们没有见过的 <code>Function</code> 的函数式接口，这个函数式接口，有两个参数，一个是输入参数，一个是返回值。他的唯一的抽象方法中，是接受一个参数，返回一个值。具体见下图，唯一的方法是 <code>apply</code> 方法，它是有返回值的，这一点和现实中的函数很像</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/a0gnbt50hdkjtfdk2ug54yws/image_1b5ng26f4el33qb92s1itsgpl9.png" alt="image_1b5ng26f4el33qb92s1itsgpl9.png-43.2kB"></p>
<blockquote>
<p>我们之前说过，java8 中，新增了很多个函数式接口，分别用于不同的场景<br>如之前说的 <code>Consumer</code> 接口，他是没有返回值的一个场景，专用于处理数据<br>以及今天说的有返回值的 <code>Function</code> 接口</p>
</blockquote>
<p>那么这个 <code>Function</code> 的函数式接口，就是我们今天的重点。</p>
<h3 id="二-Functon-接口-以及-BiFunction简介"><a href="#二-Functon-接口-以及-BiFunction简介" class="headerlink" title="二 Functon 接口 以及 BiFunction简介"></a>二 Functon 接口 以及 BiFunction简介</h3><p>我们可以用一个例子来完整的说明问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 函数式接口 Function 的经典案例</div><div class="line"> * jdk 8 新增很多 函数式接口</div><div class="line"> * 之前看的 forEach 方法中的 Consumer 接口 ，他的作用就是 对给定的参数进行一系列操作，不返回值</div><div class="line"> * 而现在的 以及 Test3 中流的 map 方法中 Function 接口 ，他唯一的操作 是apply , 他有返回值，一个value 一个 Return ，与现实当中数学的函数很类似</div><div class="line"> *</div><div class="line"> * jdk 8 中，接口中 除了可以有 default 方法以外， 还可以有一个 static 方法， static 方法可以有默认的实现</div><div class="line"> * 可以参考 Function 这个函数式接口</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        FunctionTest functionTest = <span class="keyword">new</span> FunctionTest();</div><div class="line"></div><div class="line">        <span class="comment">// 函数式接口，以及 lambda 表达式，让我们可以在函数操作的时候，传递函数，即传递行为</span></div><div class="line">        <span class="comment">// 而之前的编程方法，行为必须已经确定，而后进行调用</span></div><div class="line">        <span class="comment">// 故而 之前的编程方法称之为命令式编程，而后面的方法称之为 函数式编程</span></div><div class="line">        <span class="comment">// 而 可以传递，或者 返回函数的函数，称之为高阶函数（ js 中随处可见高阶函数</span></div><div class="line">        System.out.println(functionTest.compute(<span class="number">1</span>, item -&gt; <span class="number">2</span> * item));</div><div class="line"></div><div class="line">        <span class="comment">// 这种返回方式是 statement 方法</span></div><div class="line">        <span class="comment">// 上面那种方式是 expression 方式</span></div><div class="line">        <span class="comment">// 一个是一个标准的语句，而一个是一个表达式</span></div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 表达式是不需要分好结尾的</div><div class="line">         * 而使用 标准语句，则必须要 ； 而且要 &#123;&#125;</div><div class="line">         */</div><div class="line">        System.out.println(functionTest.compute(<span class="number">1</span>, item -&gt; &#123;<span class="keyword">return</span>  <span class="number">2</span> * item;&#125;));</div><div class="line">        System.out.println(functionTest.compute(<span class="number">2</span>, item -&gt; item * item));</div><div class="line">        System.out.println(functionTest.convert(<span class="string">"hello"</span>, item -&gt; item + <span class="string">" world !!"</span>));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> value, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> function.apply(value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String value , Function&lt;String, String&gt; function)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> function.apply(value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要去看代码的注释，上面写完了所有重点的内容，我们再去看看 <code>Function</code> 这个函数式接口的实现，我们知道，<code>java8</code> 允许接口有 <code>default</code> 方法，而 <code>Function</code> 接口中有两个默认方法：</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/o6nkgv0l1c4kjmaot2r0hd9u/image_1b5ngi5f21mha13p0uu4d06851m.png" alt="image_1b5ngi5f21mha13p0uu4d06851m.png-66.8kB"></p>
<p>利用这个两个方法，可以做函数的组合，用一个函数的输出，作为一个函数的输入。</p>
<ul>
<li><code>compose</code> 方法，是先执行 <code>before</code> 这个function, 在执行本身这个function；</li>
<li><code>andThen</code> 方法，则是先执行 <code>Function</code> 本体的 <code>apply</code> 方法，在执行传入的 <code>after</code> 的方法</li>
</ul>
<p>我们来写个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        FunctionTest2 functionTest2 = <span class="keyword">new</span> FunctionTest2();</div><div class="line"></div><div class="line">        <span class="comment">// 12</span></div><div class="line">        System.out.println(functionTest2.compute(<span class="number">2</span>, item -&gt; item * <span class="number">3</span>, item -&gt; item * item));</div><div class="line">        <span class="comment">// 36</span></div><div class="line">        System.out.println(functionTest2.compute2(<span class="number">2</span>, item -&gt; item * <span class="number">3</span>, item -&gt; item * item));</div><div class="line">        <span class="comment">// 25</span></div><div class="line">        System.out.println(functionTest2.compute3(<span class="number">2</span>, <span class="number">3</span>, (a,b)-&gt; a+b , result -&gt; result * result));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span> <span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * compose 就是 先执行 function2.apply</div><div class="line">         * 再将 function2.apply 的返回值，作为 function1 的输入</div><div class="line">         * 此时再执行 function1 apply</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> function1.compose(function2).apply(a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute2</span> <span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * compose 就是 先执行 function1.apply</div><div class="line">         * 再将 function1.apply 的返回值，作为 function2 的输入</div><div class="line">         * 此时再执行 function2 apply</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> function1.andThen(function2).apply(a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 如果想做有两个参数的Function 就需要使用BiFunction</div><div class="line">     * 而 BiFunction 只有一个 andThen , andThen 的输入 是 Function，</div><div class="line">     * 因为是将 Apply 的结果返回，结果只有一个，所以 参数只能是 Function , 而不是 BiFunction</div><div class="line">     * 所以 BiFunction 方法不可能有 compose 方法</div><div class="line">     *</div><div class="line">     * 对应的  consumer 也有着 BiConsumer 同时，二者因为没有返回值，所以也只可能有 andThen 方法</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute3</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> biFunction.andThen(function).apply(a,b);</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><code>compose</code> 和 <code>andThen</code> 的功能可以从例子中很好的看出来，例子中还有一个新的接口叫 <code>BiFunction</code>, 这个函数式接口是给定两个输入，返回一个输出，解决了有两个参数的函数的问题，对应的，其实 <code>Comsumer</code> 接口也还有一个对应的 <code>BiConsumer</code> 接口。</p>
<p>而当我们去观察这俩 <code>Bi</code> 的接口，都只有一个 <code>andThen</code> 的接口，为啥没有 <code>compose</code> 方法呢？<br>给读者自己思考吧~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-流初步&quot;&gt;&lt;a href=&quot;#一-流初步&quot; class=&quot;headerlink&quot; title=&quot;一 流初步&quot;&gt;&lt;/a&gt;一 流初步&lt;/h3&gt;&lt;p&gt;java 8提供一种更加方便的操作集合方式，即流~ &lt;code&gt;Stream&lt;/code&gt;&lt;br&gt;Stream的概念其实类似于 &lt;em&gt;liunx&lt;/em&gt; 操作系统的中的 &lt;code&gt;PipeLine&lt;/code&gt; 的概念，可以将数据传输；&lt;/p&gt;
    
    </summary>
    
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-1.1-方法引用：lambda表达式的语法糖</title>
    <link href="http://yoursite.com/2017/02/12/jdk8-1-1-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%9Alambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96/"/>
    <id>http://yoursite.com/2017/02/12/jdk8-1-1-方法引用：lambda表达式的语法糖/</id>
    <published>2017-02-12T07:31:46.000Z</published>
    <updated>2017-04-14T07:33:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>方法应用其实是 jdk 8 中的对于  <em>lambda</em> 表达式给予的一种 <strong>语法糖</strong></p>
</blockquote>
<p>而方法引用一共分为 4 种；</p>
<ul>
<li>1 <code>类名::静态方法名</code></li>
<li>2 <code>对象名::方法名</code></li>
<li>3 <code>类名::实例方法名</code></li>
<li>4 <code>构造方法引用::new</code></li>
</ul>
<a id="more"></a>
<p>我们有intellj 编写 lambda 表达式的时候，编译器总是标黄来告诉你，这里可以使用方法引用的方法来进行代码的简化</p>
<p><img src="http://static.zybuluo.com/zhumin1990719/6sl7hr28156h9kmv9jsmstb6/image_1b7k0qtepmls15v3rjv19691om39.png" alt="image_1b7k0qtepmls15v3rjv19691om39.png-86kB"></p>
<p>而方法引用，<strong><em>method reference</em></strong> 其实就是lambda表达式一种语法糖<br>但是 </p>
<blockquote>
<p><strong>不是所有的 lambda 表达式，都可以用方法引用的方式来编写</strong><br>复杂的 lambda 表达式还是需要老老实实写相关代码</p>
</blockquote>
<p>我们通过一个例子来分别讲解这四种方法引用的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">// 第一种</span></div><div class="line"></div><div class="line">        Student student1 = <span class="keyword">new</span> Student(<span class="string">"zhumin1"</span>,<span class="number">10</span>);</div><div class="line">        Student student2 = <span class="keyword">new</span> Student(<span class="string">"zhumin2"</span>,<span class="number">20</span>);</div><div class="line">        Student student3 = <span class="keyword">new</span> Student(<span class="string">"zhumin3"</span>,<span class="number">40</span>);</div><div class="line">        Student student4 = <span class="keyword">new</span> Student(<span class="string">"zhumin4"</span>,<span class="number">80</span>);</div><div class="line"></div><div class="line">        List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</div><div class="line"></div><div class="line">        <span class="comment">// jdk 1.8 的新方法  List 中新增加了 sort 方法</span></div><div class="line">        <span class="comment">// 传统的 lambda 表达式</span></div><div class="line">        students.sort((studentP1, studentP2) -&gt; Student.compareByScore(studentP1, studentP2));</div><div class="line">        <span class="comment">// 第一种方法引用的方式 类名::静态方法名</span></div><div class="line">        <span class="comment">// 不需要传参数，因为可以自动推断出 Student 类型</span></div><div class="line">        students.sort(Student::compareByScore);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 第二种 对象名称::方法名称</span></div><div class="line">        <span class="comment">// 其实和第一种很类似</span></div><div class="line">        StudentComparator studentComparator = <span class="keyword">new</span> StudentComparator();</div><div class="line"></div><div class="line">        students.sort((studentP1, studentP2) -&gt; studentComparator.comparator(studentP1, studentP2));</div><div class="line">        <span class="comment">// 对象名称::方法名称 (方法引用的第二种方式)</span></div><div class="line">        students.sort(studentComparator::comparator);</div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 第三种方法 类名::实例方法</span></div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 比较难理解的的地方是，你会看到调用的函数，和 lambda 表达式需要的参数个数不一致， 会少一个</div><div class="line">         * 而且类名是没法调用方法名的</div><div class="line">         * 而理解方式是：调用方法的实例，就是传入lambda 表达式的第一个参数，而剩下所有参数，都作为 调用的实例方法 的参数</div><div class="line">         * 我们看下面的例子 ， Student 类调用的是其的实例方法 compare（Student） 只有一个参数</div><div class="line">         * 而 List 的默认方法需要的 Comparator 的函数式接口需要两个参数，看似对应不上，而且，类名也无法调用实例方法</div><div class="line">         * 实际是，传入的第一参数就是 comare（student）这个函数的调用者，而第二个参数以及后续所有的参数（如果有跟多也是一样），是作为实例方法的参数传入</div><div class="line">         * 所以少一个参数也没什么</div><div class="line">         * 而更为关键的是这个就是一个语法糖，为了简化代码而生。理解就好</div><div class="line">         * 如此一来； 这个第三种方式就很好理解了</div><div class="line">         *</div><div class="line">         * 类名::实例方法</div><div class="line">         * 即 lambda 表达式的第一参数就是 实例方法 的调用者，后续所有的参数就是 实例方法的传入参数</div><div class="line">         */</div><div class="line">        students.sort(Student::compare);</div><div class="line"></div><div class="line">        <span class="comment">// 再看一个例子</span></div><div class="line">        List&lt;String&gt; cities = Arrays.asList(<span class="string">"haha"</span>,<span class="string">"lala"</span>,<span class="string">"nihao"</span>,<span class="string">"memeda"</span>);</div><div class="line">        <span class="comment">// 对比二者</span></div><div class="line">        Collections.sort(cities, (city1, city2) -&gt; city1.compareToIgnoreCase(city2));</div><div class="line">        Collections.sort(cities, String::compareToIgnoreCase);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="comment">// 对于第四种，构造方法引用，对于带参数和不带参数的都可以，编译器会自动的进行腿短</span></div><div class="line">        MethodRefrenceTest methodRefrenceTest = <span class="keyword">new</span> MethodRefrenceTest();</div><div class="line">        <span class="comment">// 点击 new 看看会跳到那个方法里去</span></div><div class="line">        methodRefrenceTest.getName(String::<span class="keyword">new</span>);</div><div class="line">        <span class="comment">// 点击 new 看看会跳到那个方法里去</span></div><div class="line">        methodRefrenceTest.getName2(<span class="string">"haa"</span>, String::<span class="keyword">new</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(Supplier&lt;String&gt; supplier)</span>  </span>&#123;</div><div class="line">        <span class="keyword">return</span> supplier.get() + <span class="string">"haha"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName2</span><span class="params">(String name, Function&lt;String ,String&gt; stringFunction)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> stringFunction.apply(name);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;方法应用其实是 jdk 8 中的对于  &lt;em&gt;lambda&lt;/em&gt; 表达式给予的一种 &lt;strong&gt;语法糖&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而方法引用一共分为 4 种；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &lt;code&gt;类名::静态方法名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2 &lt;code&gt;对象名::方法名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3 &lt;code&gt;类名::实例方法名&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;4 &lt;code&gt;构造方法引用::new&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
  </entry>
  
  <entry>
    <title>jdk8-1-函数式接口&amp;lambda表达式</title>
    <link href="http://yoursite.com/2017/02/11/jdk8-1-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2017/02/11/jdk8-1-函数式接口-lambda表达式/</id>
    <published>2017-02-11T07:00:25.000Z</published>
    <updated>2017-04-14T07:13:39.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-lmabda表达式"><a href="#1-lmabda表达式" class="headerlink" title="1 lmabda表达式"></a>1 lmabda表达式</h3><p>首先看两段对比代码:<br>为jbutton 添加一个时间监听器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 老写法: 匿名内部类</span></div><div class="line">jButton.addActionListener(<span class="keyword">new</span> AbstractAction() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello Button"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">        </div><div class="line"><span class="comment">// lambda 表达式写法</span></div><div class="line">jButton.addActionListener(e -&gt; System.out.println(<span class="string">"Hello Button"</span>));</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>对比两个写法，lambda表达式的写法会简单很多，如果你有多行处理逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 加个大括号</span></div><div class="line">jButton.addActionListener(e -&gt;&#123;</div><div class="line">    System.out.println(<span class="string">"Hello Button!!!!"</span>);</div><div class="line">    System.out.println(<span class="string">"Hello Button2!!!!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这里的e，没有声明类型，并不是表示java 不是一个静态语言了，而是，编译器的类型推断告诉可以推断出来这个 <code>e</code> 的类型肯定是一个 <code>AbstractAction</code>, 所以无需去写，当然如写上也没有问题，需要加上括号</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">jButton.addActionListener((AbstractAction e) -&gt;&#123;</div><div class="line">    System.out.println(<span class="string">"Hello Button!!!!"</span>);</div><div class="line">    System.out.println(<span class="string">"Hello Button2!!!!"</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>所以 <strong>lambda</strong> 表达式的基本结构如下（根据单个参数和单个操作可以有一定的省略）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(event e1, event e2 ...) -&gt; &#123;</div><div class="line">    action1;</div><div class="line">    action2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一开始可能不是特别好理解，我们可以结合 <strong>java8</strong> 新增的另一个特性 <strong>函数式接口</strong> 来一起理解为何我们可以如此编写代码</p>
<h3 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2 函数式接口"></a>2 函数式接口</h3><p>什么叫函数式接口呢？ 函数式接口是 <code>jdk1.8</code> 中新增的一个接口类型，为此还新增了一个注解 <code>@FunctionalInterface</code> 用于标注函数接口；我们通过阅读 <code>@FunctionalInterface</code> 的 <em>jdk</em> 文档来进行概念认知。总结起来：</p>
<ul>
<li>当一个接口 有且只有一个抽象方法，并且这个抽象方法不是继承自 <code>Object</code> 的方法，就会被当做一个 <strong>函数式接口</strong></li>
<li>当一个接口被  <code>@FunctionalInterface</code> 注解时，可以当做一个函数式接口</li>
<li>当一个接口被  <code>@FunctionalInterface</code> 注解，但不满足第一个条件的时候，编译器会报错。</li>
<li>当一个接口 没有被 <code>@FunctionalInterface</code> 注解标注，但是满足函数式接口的条件，也会被当做函数式接口</li>
</ul>
<blockquote>
<p>这里的第一条后半部分很重要，如果一个接口，有两个抽象方法，但是其中一个是继承自 <code>Object</code> 类（因为其实万类师祖）, 他仍然是一个函数式接口。</p>
</blockquote>
<p>例如以下实例就是一个完整的函数式接口，即使他有2个抽象方法，但是toString是继承自 <code>Object</code> 的方法，所以不会算作函数式接口的抽象方法，所以其中的 <code>test()</code> 方法, 是函数式接口认定的唯一的抽象方法。<br>同理，如果下面的例子只有 <code>toString()</code> 方法，而没有 <code>test()</code> 方法，同时又有  <code>@FunctionalInterface</code> 注解的话，那么编译器会报错。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 函数式接口，只能有唯一的抽象方法</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 因为改抽象方法，继承自 Object，所以不算函数式接口的抽象方法</div><div class="line">     * 故而，接口可以算作一个函数式接口</div><div class="line">     */</div><div class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看一下  <code>@FunctionalInterface</code> 的jdk文档，里面有一句: </p>
<center><img src="http://static.zybuluo.com/zhumin1990719/xgz9c76x5q7q1fa3fyvrzilz/image_1b4cpml3c13mn1cju14uurjun9v9.png" alt="image_1b4cpml3c13mn1cju14uurjun9v9.png-24.9kB"></center>

<p>意思就是说，函数式接口的实现，可以通过 <code>lambda</code> 表达式 <strong>方法引用</strong> 以及 <strong>构造方法引用</strong> 的方式来实现。其实我们上面的 <code>lambda</code> 表达式的例子，就是实现的函数式接口。我们来新写一个例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInterface</span><span class="params">(MyInterface myInterface)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"start ------------------"</span>);</div><div class="line">        myInterface.test();</div><div class="line">        System.out.println(<span class="string">"end --------------------"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Test2 test2 = <span class="keyword">new</span> Test2();</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 因为函数式接口的里唯一的抽象方法test里面，没有参数</div><div class="line">         * 但是（）不能省略</div><div class="line">         * 参考Test1 程序里面的Jframe 里的ActionListener</div><div class="line">         */</div><div class="line">        test2.testInterface(() -&gt; &#123;</div><div class="line">            System.out.println(<span class="string">"函数式接口接口实现"</span>);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，<code>testInterface</code> 方法需要传递一个 <code>testInterface</code><br>的接口，而我们使用的方式就是 <code>lambda</code> 表达式来实现了一个函数式接口。 可以运用下面的形式来理解。</p>
<blockquote>
<p>(函数式接口唯一的抽象方法的参数列表) -&gt; {唯一抽象函数的实现}</p>
</blockquote>
<p>这个时候，我们看一下最开始的那个给 <strong>button</strong> 加 action 的例子。<br>其实实现就是 <code>ActionListener</code> 这个函数式接口的唯一的抽象方法：<br><img src="http://static.zybuluo.com/zhumin1990719/uy91dk519fbykpnmbovocu5h/image_1b4cq5u2j1548e4eif0l1t1t48m.png" alt="image_1b4cq5u2j1548e4eif0l1t1t48m.png-35.9kB"><br>虽然该类没有 <code>@FunctionalInterface</code> 注解，但是满足条件，只有一个抽象方法，所以他也是一个函数式接口，所以我们可以去使用 <code>lambda</code> 表达式去实现他。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-lmabda表达式&quot;&gt;&lt;a href=&quot;#1-lmabda表达式&quot; class=&quot;headerlink&quot; title=&quot;1 lmabda表达式&quot;&gt;&lt;/a&gt;1 lmabda表达式&lt;/h3&gt;&lt;p&gt;首先看两段对比代码:&lt;br&gt;为jbutton 添加一个时间监听器&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 老写法: 匿名内部类&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;jButton.addActionListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AbstractAction() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;actionPerformed&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ActionEvent e)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello Button&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// lambda 表达式写法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;jButton.addActionListener(e -&amp;gt; System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;Hello Button&quot;&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java8" scheme="http://yoursite.com/tags/java8/"/>
    
      <category term="coding life" scheme="http://yoursite.com/tags/coding-life/"/>
    
  </entry>
  
  <entry>
    <title>new start</title>
    <link href="http://yoursite.com/2017/01/11/new-start/"/>
    <id>http://yoursite.com/2017/01/11/new-start/</id>
    <published>2017-01-11T13:42:13.000Z</published>
    <updated>2017-04-14T06:58:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>重新开始维护这个网站。让自己配得上这个不错的域名 <code>movingon.cn!</code></p>
<a id="more"></a>
<p>我14年买了这个域名，本来想自己要好好做，实在不行，这域名也是一个不错的督促。</p>
<p>然而，自己维护了一段时间之后，就忘记了要去维护。</p>
<p>但是这一次，我用这里记录自己的技术成长以及个人感悟，作为自己的成长的记录。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;重新开始维护这个网站。让自己配得上这个不错的域名 &lt;code&gt;movingon.cn!&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="鸡汤" scheme="http://yoursite.com/tags/%E9%B8%A1%E6%B1%A4/"/>
    
  </entry>
  
</feed>
